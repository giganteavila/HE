{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>00.-KVM</p> <p>01.-Introducci\u00f3n al Hacking \u00c9tico</p>"},{"location":"00.-KVM/","title":"Index","text":"<p>Las m\u00e1quinas virtuales basadas en el kernel (KVM) son una tecnolog\u00eda de virtualizaci\u00f3n open source integrada a Linux\u00ae. Con ellas, se puede transformar Linux en un hipervisor que permite que una m\u00e1quina host ejecute varios entornos virtuales aislados llamados m\u00e1quinas virtuales (VM) o guests.</p> <p>Las KVM forman parte de Linux. Por eso, si se cuenta con una versi\u00f3n de Linux 2.6.20 o posterior, ya est\u00e1n a nuestra a su disposici\u00f3n. Se anunciaron por primera vez en 2006, y un a\u00f1o despu\u00e9s se incorporaron a la versi\u00f3n principal del kernel de Linux. Dado que forman parte del c\u00f3digo actual de Linux, reciben inmediatamente todas las mejoras, las correcciones y las funciones nuevas de este  sistema, sin requerir ning\u00fan tipo de ingenier\u00eda adicional.</p> <p></p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/01.-Qu%C3%A9%20es%20la%20virtualizaci%C3%B3n/","title":"01.-Qu\u00e9 es la virtualizaci\u00f3n","text":"<p>Seg\u00fan la Wikipedia: La virtualizaci\u00f3n utiliza el software para imitar las caracter\u00edsticas del hardware y crear un sistema inform\u00e1tico virtual.</p> <p>Esto nos permite ejecutar m\u00e1s de un sistema virtual, y m\u00faltiples sistemas operativos y aplicaciones, en un solo servidor, aumentando el rendimiento del hardware disponible e incrementando el tiempo de procesamiento de un equipo, ya que habitualmente se desaprovecha gran parte.</p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/01.-Qu%C3%A9%20es%20la%20virtualizaci%C3%B3n/#para-que-se-utiliza-la-virtualizacion","title":"Para qu\u00e9 se utiliza la virtualizaci\u00f3n","text":"<ul> <li>Aislamiento e independencia de servicios y contenidos.</li> <li>Laboratorio de pruebas.</li> <li>Virtualizaci\u00f3n de arquitecturas de las que no se dispone.</li> <li>Creaci\u00f3n de cl\u00faster de m\u00e1quinas y sistemas distribuidos.</li> <li>Herramientas de aprendizajes</li> </ul>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/01.-Qu%C3%A9%20es%20la%20virtualizaci%C3%B3n/#ventajas-e-inconvenientes-de-la-virtualizacion","title":"Ventajas e inconvenientes de la virtualizaci\u00f3n","text":"<p>Las principales ventajas que podemos indicar ser\u00edan:</p> <ul> <li>Importante ahorro econ\u00f3mico.</li> <li>Seguridad.</li> <li>Mayor aprovechamiento de recursos.</li> <li>Migraci\u00f3n en vivo. </li> <li>Importante ahorro energ\u00e9tico.</li> </ul> <p>Como desventajas podr\u00edamos se\u00f1alar:</p> <ul> <li>Muchos sistemas dependen de un s\u00f3lo equipo f\u00edsico.</li> <li>Penalizaciones en rendimiento.</li> </ul>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/01.-Qu%C3%A9%20es%20la%20virtualizaci%C3%B3n/#conceptos-de-virtualizacion","title":"Conceptos de virtualizaci\u00f3n","text":"<ul> <li>Al sistema operativo que ejecuta el software de virtualizaci\u00f3n se le conoce como anfitri\u00f3n (host). El anfitri\u00f3n controla el hardware real.</li> <li>Al sistema operativo virtualizado se le conoce como invitado o hu\u00e9sped (guest).</li> <li>Al software de virtualizaci\u00f3n se le suele llamar Hipervisor.</li> <li>Desde 2005, Intel y AMD han a\u00f1adido soporte hardware para la virtualizaci\u00f3n: Intel Virtualization Technology (VT) y AMD Virtualization (AMD-V), y permiten a los hipervisores un rendimiento mayor en su labor de virtualizar.</li> </ul>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/02.-Tipos/","title":"02.-Tipos","text":"<p>En el punto anterior aprendimos que un Hipervisor es el software que nos permite realizar la virtualizaci\u00f3n. Seg\u00fan como funcione el Hipervisor podemos clasificar distintas t\u00e9cnicas de virtualizaci\u00f3n:</p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/02.-Tipos/#emulacion","title":"Emulaci\u00f3n","text":"<p>El hipervisor imita o suplanta v\u00eda software una arquitectura al completo (procesador, memoria, conjunto de instrucciones, comunicaciones...). De esta forma puede hacer creer a los programas y sistemas operativos dise\u00f1ados para una arquitectura concreta que son ejecutados sobre ella. La emulaci\u00f3n suele ofrecer un rendimiento bastante bajo debido a que hay que realizar un proceso completo de traducci\u00f3n. Ejemplo: QEMU, Microsoft Virtual PC, Wine, ...</p> <p></p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/02.-Tipos/#virtualizacion-completa-o-por-hardware","title":"Virtualizaci\u00f3n completa o por hardware","text":"<p>El hipervisor simula un hardware suficiente para permitir que un sistema operativo no adaptado se ejecute de forma aislada. En este caso podemos hacer una subdivisi\u00f3n seg\u00fan el tipo de hipervisor que estemos utilizando:</p> <ul> <li> <p>Virtualizaci\u00f3n por hardware: En este caso usamos hipervisores de tipo 1, que controlan directamente el hardware f\u00edsico del host ofreci\u00e9ndolo directamente a la m\u00e1quina virtual. Es imprescindible que la CPU del host tenga las extensiones de virtualizaci\u00f3n. Ejemplos: Xen, Kernel-based Virtual Machine (KVM), Microsoft Hyper-V, VMware ESXi,...</p> <p></p> </li> <li> <p>Virtualizaci\u00f3n completa: En este tipo se usan hipervisores de tipo 2. Este software se instala sobre el sistema operativo del host, pero no controla directamente el hardware f\u00edsico. Ofrecen menos rendimiento que la virtualizaci\u00f3n por hardware. Ejemplos: VMware Workstation, Parallels Desktop, VirtualBox, VMware Player, ...</p> <p></p> </li> </ul>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/02.-Tipos/#virtualizacion-parcial-o-paravirtualizacion","title":"Virtualizaci\u00f3n parcial o paravirtualizaci\u00f3n","text":"<p>El hipervisor ofrece un interfaz especial para acceder a los recursos. En ocasiones, es necesario la adaptaci\u00f3n del sistema operativo de la m\u00e1quina virtual. Ofrecen el m\u00e1ximo rendimiento, pero no se pueden usar sistemas operativos sin modificaciones o hardware especifico. Ejemplos: XEN, Microsoft Hyper-V, VMware ESXi, ...</p> <p></p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/02.-Tipos/#virtualizacion-ligera","title":"Virtualizaci\u00f3n ligera","text":"<p>O tambi\u00e9n llamada virtualizaci\u00f3n a nivel de sistema operativo, o virtualizaci\u00f3n basada en contenedores. Es un m\u00e9todo de virtualizaci\u00f3n en el que, sobre el n\u00facleo del sistema operativo se ejecuta una capa de virtualizaci\u00f3n que permite que existan m\u00faltiples instancias aisladas de espacios de usuario. A cada espacio de usuario aislado lo llamamos contenedor. Por lo tanto, un contenedor es un conjunto de procesos aislados, que se ejecutan en un servidor, y que acceden a un sistema de ficheros propio, tienen una configuraci\u00f3n red propio y accede a los recursos del host (memoria y CPU). Podemos hacer la siguiente clasificaci\u00f3n de contenedores:</p> <ul> <li>Contenedores de Sistemas: El uso que se hace de ellos es muy similar al que hacemos sobre una m\u00e1quina virtual: se accede a ellos (normalmente por ssh), se instalan servicios, se actualizan, ejecutan un conjunto de procesos, ... Ejemplo: LXC(Linux Container).</li> <li>Contenedores de Aplicaci\u00f3n: Se suelen usar para el despliegue de aplicaciones web Ejemplo: Docker, Podman, ...</li> </ul> <p></p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/03.-qemu-kvm/","title":"03.-qemu-kvm","text":"<p>De acuerdo con la wiki de QEMU, \"QEMU es un emulador gen\u00e9rico y de c\u00f3digo abierto de m\u00e1quinas virtuales.\". Se puede usar como emulador, permitiendo ejecutar sistemas operativos de una determinada arquitectura (por ejemplo ARM) sobre otra arquitectura (por ejemplo amd64). Pero tambi\u00e9n, puede ofrecer una soluci\u00f3n de virtualizaci\u00f3n completa, usando hipervidores como KVM para utilizar las extensiones del procesador para la virtualizaci\u00f3n y ofrecer un rendimiento mayor.</p> <p>KVM, la Maquina virtual basada en el kernel (Kernel-based Virtual Machine), es un hipervisor de tipo 1 integrado al kernel de Linux. Es una soluci\u00f3n de virtualizaci\u00f3n completa para Linux, que contienen las extensiones de virtualizaci\u00f3n Intel VT o AMD-V. Se compone de un m\u00f3dulo del kernel <code>kvm.ko</code>, que provee la infraestructura de virtualizaci\u00f3n base, y un m\u00f3dulo espec\u00edfico para el tipo de procesador, <code>kvm-intel.ko</code> o <code>kvm-amd.ko</code>.</p> <p>Por lo tanto, podemos usar QEMU junto a KVM para permitir la ejecuci\u00f3n de m\u00e1quinas virtuales utilizando im\u00e1genes de disco que contienen sistemas operativos sin modificar. Cada m\u00e1quina virtual tiene su propio hardware virtualizado: una tarjeta de red, discos duros, tarjeta gr\u00e1fica, ...</p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/03.-qemu-kvm/#dispositivos-paravirtualizados","title":"Dispositivos paravirtualizados","text":"<p>Al crear las m\u00e1quinas virtuales, adem\u00e1s de las caracter\u00edsticas b\u00e1sicas como la cantidad de RAM asignada, el espacio de almacenamiento o la CPU, se deben seleccionar los diferentes dispositivos que van a formar parte de ella: interfaz de red, controladores de disco duro, interfaz gr\u00e1fica, etc. En un sistema de virtualizaci\u00f3n completa como QEMU/KVM todos los dispositivos est\u00e1n inicialmente emulados por software, de manera que la m\u00e1quina virtual interact\u00faa con un dispositivo como si lo hiciera con uno f\u00edsico equivalente. De esta manera podemos encontrar una interfaz de red emulando a la cl\u00e1sica tarjeta de red Realtek 8139 o una interfaz IDE para conectar con un disco duro virtual. Estos dispositivos emulados tienen la ventaja de que pueden utilizar los controladores de dispositivos de sus equivalentes f\u00edsicos, por lo que se suelen utilizar dispositivos emulados muy comunes, que proporcionan compatibilidad con la mayor\u00eda de sistemas operativos y hacen muy sencilla la instalaci\u00f3n de los mismos dentro de una m\u00e1quina virtual. Sin embargo, tienen un inconveniente y es que cuando son dispositivos muy usados, tienen un rendimiento pobre, aumentan el consumo de recursos de la CPU y aumentan la latencia de E/S.</p> <p>El proyecto KVM proporciona una alternativa al uso de dispositivos emulados, que se conocen como dispositivos paravirtualizados y se engloban bajo la denominaci\u00f3n virtIO. El nombre de dispositivos paravirtualizados hace referencia a la t\u00e9cnica que utilizan, m\u00e1s cercana a la paravirtualizaci\u00f3n y que proporciona un rendimiento muy cercano al real, por lo que es muy recomendable utilizar dispositivos virtIO en los dispositivos de E/S que consumen m\u00e1s recursos, por ejemplo, la red y el acceso a discos duros. El \u00fanico inconveniente que tiene utilizar dispositivos virtIO es que son espec\u00edficos para KVM y no todos los sistemas operativos los reconocen por defecto. Evidentemente los sistemas linux s\u00ed reconocen los dispositivos virtIO y en ese caso siempre es recomendable usarlos, pero otros sistemas operativos, como por ejemplo Windows, no incluyen inicialmente soporte virtio, si queremos usarlos en ese caso, ser\u00e1 necesario instalar los controladores de dispositivos durante la instalaci\u00f3n del sistema operativo de la m\u00e1quina virtual.</p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/03.-qemu-kvm/#libvirt-una-api-de-virtualizacion","title":"libvirt: una API de virtualizaci\u00f3n","text":"<p>Normalmente no trabajamos directamente con las aplicaciones ofrecidas por QEMU/KVM para la gesti\u00f3n de recursos virtualizados. Es m\u00e1s f\u00e1cil usar libvirt, una API intermedia que nos facilita la comunicaci\u00f3n con QEMU/KVM.</p> <p>\u00cdndice</p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/04.-libvirt/","title":"04.-libvirt","text":"<p>libvirt proporciona una API gen\u00e9rica, un demonio y un conjunto de herramientas de gesti\u00f3n para diferentes sistemas de virtualizaci\u00f3n, en particular los sistemas de virtualizaci\u00f3n nativos de linux: KVM, LXC o Xen. Tambi\u00e9n es posible,  manejar a trav\u00e9s de libvirt otros sistemas de virtualizaci\u00f3n como VMware ESXi o Hyper-V.</p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/04.-libvirt/#mecanismos-de-conexion","title":"Mecanismos de conexi\u00f3n","text":"<p>libvirt proporciona varios mecanismos para conectarse a un hipervisor Qemu/KVM, tanto de forma local como remota, los que veremos en este curso son:</p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/04.-libvirt/#acceso-local-con-un-usuario-no-privilegiado","title":"Acceso local con un usuario no privilegiado","text":"<p>Nos conectamos a la URI <code>qemu:///session</code>. Se acceden a las m\u00e1quinas virtuales de ese usuario. En este modo de conexi\u00f3n, el usuario no suele tener permisos para crear conexiones de red, por lo que se limita su uso de la red no privilegiada de qemu (SLIRP) que es \u00fatil para casos simples, pero que tiene bajo rendimiento y es poco configurable. </p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/04.-libvirt/#acceso-local-privilegiado","title":"Acceso local privilegiado","text":"<p>Nos conectamos a la URI <code>qemu:///system</code>. Se acceden a las m\u00e1quinas virtuales del sistema. Por las limitaciones vistas anteriormente en el acceso local con usuarios no privilegiados, se utiliza la conexi\u00f3n <code>qemu:///system</code>, que es \u00fanica para todo el sistema y que puede utilizar tanto el usuario <code>root</code> como cualquier miembro del grupo <code>libvirt</code>.</p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/04.-libvirt/#acceso-remoto-privilegiado-por-ssh","title":"Acceso remoto privilegiado por ssh","text":"<p>Nos conectamos a la URI <code>qemu+ssh:///system</code>. En las conexiones citadas anteriormente nos conectamos a un socket linux <code>/var/run/libvirt/libvirt-sock</code>. A este socket tambi\u00e9n nos podemos conectar a trav\u00e9s de un t\u00fanel ssh (qemu+ssh).</p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/04.-libvirt/#aplicaciones-para-usar-libvirt","title":"Aplicaciones para usar libvirt","text":"<p>libvirt proporciona una API que puede ser utilizada por diferentes aplicaciones (CLI, GUI o web). Podemos destacar algunas que vamos a utilizar en este curso:</p> <ul> <li>virsh: Es el cliente por l\u00ednea de comandos \"oficial\" de libvirt. Ofrece una shell completa para el manejo de la API.</li> <li>virt-manager: Es una aplicaci\u00f3n gr\u00e1fica (GUI) que nos proporciona muchas de las funcionalidades para trabajar con libvirt.</li> <li>virtinst: Paquete que proporciona los comandos <code>virt-clone</code>, <code>virt-install</code> y <code>virt-xml</code> \u00fatiles para crear y copiar m\u00e1quinas virtuales.</li> <li>virt-viewer: Programa que nos permite acceder a a la consola gr\u00e1fica de una m\u00e1quina virtual.</li> <li>gnome-boxes: Aplicaci\u00f3n gr\u00e1fica muy simple, que utilizando el acceso local con usuario no privilegiado, nos permite gestionar, de forma sencilla, m\u00e1quinas virtuales.</li> </ul> <p>Cuando cualquier aplicaci\u00f3n se conecta a libvirt (con cualquiera de los m\u00e9todos que hemos estudiado) el formato de la informaci\u00f3n que se intercambian a trav\u00e9s de la API es XML. Puedes encontrar la definici\u00f3n de este formato en la documentaci\u00f3n oficial: XML Format.</p> <p>\u00cdndice</p>"},{"location":"00.-KVM/01.-Introducci%C3%B3n/05.-LXC/","title":"05.-LXC","text":"<p>LinuX Containers, tambi\u00e9n conocido por el acr\u00f3nimo LXC, es una tecnolog\u00eda de virtualizaci\u00f3n ligera o por contenedores, que es un m\u00e9todo de virtualizaci\u00f3n en el que, sobre el n\u00facleo del sistema operativo se ejecuta una capa de virtualizaci\u00f3n que permite que existan m\u00faltiples instancias aisladas de espacios de usuario, en lugar de solo uno. A estas instancias la llamamos contenedores.</p> <p>Todo esto ha sido posible por el desarrollo de dos componentes del nucleo de Linux:</p> <ul> <li>Los Grupos de Control cgroups, en concreto en Debian 11 se utiliza cgroupsv2: que limita el uso de recursos (l\u00edmite de memoria, cpu, I/O o red) para un proceso y sus hijos.</li> <li>Los Espacios de Nombres namespaces: que proporcionan un punto de vista diferente a un proceso (interfaces de red, procesos, usuarios, etc.).</li> </ul> <p>LXC pertenece a los denominados contenedores de sistemas, su gesti\u00f3n y ciclo de vida es similar al de una m\u00e1quina virtual tradicional. Est\u00e1 mantenido por Canonical y la p\u00e1gina oficial es linuxcontainers.org.</p>"},{"location":"00.-KVM/02.-Instalaci%C3%B3n/01.-Escenario%20de%20instalaci%C3%B3n/","title":"01.-Escenario de instalaci\u00f3n","text":"<p>En un entorno de producci\u00f3n, QEMU/KVM se instalar\u00e1 sobre una m\u00e1quina f\u00edsica con suficientes recursos. Si el sistema operativo tiene entorno gr\u00e1fico, podremos instalar herramientas gr\u00e1ficas, aunque siempre nos podemos conectar remotamente al servidor para gestionar QEMU/KVM.</p> <p>Para ejecutar QEMU/KVM necesitamos que el procesador soporte extensiones de virtualizaci\u00f3n en su juego de instrucciones. Para comprobar si tenemos esta caracter\u00edstica ejecutamos la siguiente instrucci\u00f3n como <code>root</code>:</p> <pre><code>egrep 'svm|vmx' /proc/cpuinfo --color\n</code></pre> <p>El resultado deber\u00eda mostrar varias l\u00edneas con el texto buscado resaltado en color. Si este es el caso entonces nuestro procesador soporta KVM. Los procesadores Intel mostrar\u00e1n el texto vmx resaltado y los procesadores AMD mostrar\u00e1n el texto svm resaltado.</p> <p>NOTA: Es importante comprobar que en la BIOS est\u00e1n activados las instrucciones virtuales VT/x, de lo contrario KVM no funcionar\u00e1.</p>"},{"location":"00.-KVM/02.-Instalaci%C3%B3n/01.-Escenario%20de%20instalaci%C3%B3n/#virtualizacion-anidada","title":"Virtualizaci\u00f3n anidada","text":"<p>Con esta caracter\u00edstica se permite la ejecuci\u00f3n de instrucciones KVM dentro de m\u00e1quinas virtuales KVM, lo cual nos posibilita la ejecuci\u00f3n de m\u00e1quinas virtuales dentro de m\u00e1quinas virtuales. De esta manera,podemos crear un laboratorio de prueba de QEMU/KVM ejecut\u00e1ndolos en una m\u00e1quina virtual.</p>"},{"location":"00.-KVM/02.-Instalaci%C3%B3n/01.-Escenario%20de%20instalaci%C3%B3n/#requerimientos-minimos","title":"Requerimientos m\u00ednimos","text":"<p>Si tenemos un entorno de producci\u00f3n, utilizaremos una m\u00e1quina f\u00edsica para la instalaci\u00f3n de QEMU/KVM. Tambi\u00e9n podr\u00edamos usar una m\u00e1quina virtual (con virtualizaci\u00f3n anidada activa) para tener un laboratorio de pruebas.</p> <p>Dependiendo de la cantidad de memoria RAM, espacio de disco duro y VCPU que tengamos, podremos virtualizar m\u00e1s o menos m\u00e1quinas virtuales:</p> <ul> <li>Por ejemplo, desde el punto de vista de la RAM: si virtualizamos una m\u00e1quina virtual sin entorno gr\u00e1fico podemos asignarle 512Mb, si tiene entorno gr\u00e1fico ya tendr\u00edamos que usar 1 o 2GB, si virtualizamos una m\u00e1quina Windows al menos tendremos que asignar 2Gb de RAM.</li> <li>Desde el punto de vista del almacenamiento: Este factor no es tan importante, pero tenemos que pensar que hay que almacenar las ISO para la instalaci\u00f3n de las m\u00e1quinas y los discos duros de las m\u00e1quinas virtuales. </li> <li> <p>Al crear m\u00e1quinas virtuales o contenedores podremos asignarle cores virtuales de CPU, por lo que aumentar\u00e1 el rendimiento si asignamos a nuestra m\u00e1quina virtual suficientes n\u00facleos de CPU. Por todo lo explicado a continuaci\u00f3n la configuraci\u00f3n recomendada para la m\u00e1quina virtual ser\u00eda:</p> </li> <li> <p>8 Gb de RAM</p> </li> <li>100 Gb de disco duro</li> <li>4 n\u00facleos de CPU</li> </ul>"},{"location":"00.-KVM/02.-Instalaci%C3%B3n/02.-Instalacion/","title":"02.-Instalacion","text":"<p>Para trabajar con el sistema de virtualizaci\u00f3n QEMU/KVM + libvirt en nuestra distribuci\u00f3n Linux Debian/Ubuntu, vamos a instalar los siguientes paquetes:</p> <pre><code>$ sudo apt install qemu-system libvirt-clients libvirt-daemon-system\n</code></pre> <p>libvirt proporciona varios mecanismos para conectarse a un hipervisor qemu-kvm.</p> <p>Podemos obtener las versiones de las aplicaciones que hemos instalado, ejecutando:</p> <pre><code>$ virsh version\nCompiled against library: libvirt 10.8.0\nUsing library: libvirt 10.8.0\nUsing API: QEMU 10.8.0\nRunning hypervisor: QEMU 9.1.0\n</code></pre>"},{"location":"00.-KVM/02.-Instalaci%C3%B3n/02.-Instalacion/#conexion-a-qemukvm","title":"Conexi\u00f3n a QEMU/KVM","text":"<p>Vamos a usar la utilidad <code>virsh</code>, que nos proporciona una shell completa para el manejo de <code>libvirt</code>. Con el comando <code>list</code> mostramos las m\u00e1quinas virtuales que hemos creado.</p> <p>Con un usuario sin privilegios ejecutamos:</p> <pre><code>$ virsh list\n</code></pre> <p>Estar\u00edamos haciendo una conexi\u00f3n local con un usuario no privilegiado (estar\u00edamos conectando con la URI <code>qemu:///session</code> y estar\u00edamos mostrando las m\u00e1quinas virtuales de este usuario.</p> <p>Si por el contrario, como <code>root</code> ejecutamos:</p> <pre><code>root@kvm:~# virsh list\n</code></pre> <p>Estar\u00edamos haciendo una conexi\u00f3n local privilegiada (estar\u00edamos conectando con la URI <code>qemu:///system</code>) y mostrar\u00edamos las m\u00e1quinas virtuales del sistema.</p> <p>Si queremos que un usuario sin privilegios pueda hacer conexiones privilegiadas, el usuario debe pertenecer el grupo <code>libvirt</code>:</p> <pre><code>root@kvm:~# adduser usuario libvirt\n</code></pre> <p>Para que el usuario <code>usuario</code> haga una conexi\u00f3n privilegiada tendr\u00e1 que indicar expl\u00edcitamente la conexi\u00f3n a la URI <code>qemu:///system</code>:</p> <pre><code>usuario@kvm:~$ virsh -c qemu:///system list\n</code></pre> <p>De forma alternativa y seg\u00fan la wiki de Debian, podemos usar la variable de entorno <code>LIBVIRT_DEFAULT_URI</code> con el siguiente comando:</p> <pre><code>export LIBVIRT_DEFAULT_URI='qemu:///system'\n</code></pre>"},{"location":"00.-KVM/02.-Instalaci%C3%B3n/03.-Conexi%C3%B3n%20local%20no%20privilegiada%20a%20libvirt/","title":"03.-Conexi\u00f3n local no privilegiada a libvirt","text":"<p>Como hemos comentado en el punto anterior, un usuario sin privilegio puede crear sus m\u00e1quinas virtuales. Para ello realizar\u00e1 una conexi\u00f3n local a la URI <code>qemu:///session</code>. En este modo de conexi\u00f3n, el usuario no tiene permisos para crear conexiones de red, por lo que se limita su uso de la red no privilegiada de qemu (SLIRP) que es \u00fatil para casos simples, pero que tiene bajo rendimiento y es poco configurable. </p> <p>El usuario podr\u00eda usar cualquier aplicaci\u00f3n que nos permite la creaci\u00f3n de m\u00e1quinas virtuales (<code>virsh</code>, <code>virt-install</code>, <code>virt-manager</code>,...), pero en este apartado vamos a usar Gnome Boxes, que es una aplicaci\u00f3n gr\u00e1fica que nos permite crear m\u00e1quinas virtuales, de forma sencilla, en el espacio de usuario.</p>"},{"location":"00.-KVM/02.-Instalaci%C3%B3n/03.-Conexi%C3%B3n%20local%20no%20privilegiada%20a%20libvirt/#gnome-boxes","title":"Gnome Boxes","text":"<p>Instalamos esta aplicaci\u00f3n:</p> <pre><code># apt install gnome-boxes\n</code></pre> <p>o en Arch:</p> <pre><code># pacman -S gnome-boxes\n</code></pre> <p>La utilizaci\u00f3n de esta aplicaci\u00f3n es muy sencilla. Podemos descargar distribuciones Linux preconfiguradas o elegir un fichero ISO para realizar la instalaci\u00f3n. Siguiendo la documentaci\u00f3n de la aplicaci\u00f3n, seguimos los siguientes pasos para crear una nueva maquina virtual:</p> <p>Pulsamos el bot\u00f3n \"+\" y elegimos la opci\u00f3n Crea una m\u00e1quina virtual.... A continuaci\u00f3n podemos escoger un sistema predefinido o un fichero ISO para realizar la instalaci\u00f3n. Elegimos un sistema preconfigurado:</p> <p></p> <p>A continuaci\u00f3n buscamos las versiones de Ubuntu:</p> <p></p> <p>Despu\u00e9s de la descarga, configuramos la nueva m\u00e1quina:</p> <p></p> <p>Y al terminar la instalaci\u00f3n  podemos acceder a la m\u00e1quina:</p> <p></p> <p>La m\u00e1quina se conecta a la red de usuario de QEMU (SLIRP) que configura la m\u00e1quina con la direcci\u00f3n IP <code>10.0.2.15</code>, su puerta de enlace, que es el anfitri\u00f3n (la m\u00e1quina f\u00edsica) es la direcci\u00f3n IP <code>10.0.2.2</code> y configura un servidor DNS en la direcci\u00f3n IP <code>10.0.2.3</code>. Esta red permite que la m\u00e1quina tenga acceso a internet, pero no tendr\u00e1 conectividad con el anfitri\u00f3n u otras m\u00e1quinas que creemos.</p> <p></p>"},{"location":"00.-KVM/02.-Instalaci%C3%B3n/03.-Conexi%C3%B3n%20local%20no%20privilegiada%20a%20libvirt/#acceso-a-las-maquinas-desde-la-linea-de-comandos","title":"Acceso a las m\u00e1quinas desde la l\u00ednea de comandos","text":"<p>Para comprobar que la m\u00e1quina virtual que hemos creado est\u00e1 virtualizada con QEMU/KVM + libvirt en el espacio de usuario, podemos ejecutar en el anfitri\u00f3n con el usuario con el que estamos trabajando:</p> <pre><code>usuario@kvm:~$ virsh -c qemu:///session list\n Id   Nombre          Estado\n----------------------------------\n 2    ubuntu20.10-2   ejecutando\n</code></pre> <p>o si queremos ver todas las m\u00e1quinas, tanto las que est\u00e1n en ejecuci\u00f3n como las que est\u00e1n apagadas:</p> <pre><code>usuario@kvm:~$ sudo virsh list --all\n</code></pre> <p>Vemos que la m\u00e1quina est\u00e1 creado en la sesi\u00f3n del usuario <code>usuario</code>. Nota: No es necesario indicar la conexi\u00f3n <code>-c qemu:///session</code>, pero de esa forma se ve m\u00e1s claro que estamos haciendo una conexi\u00f3n local con un usuario sin privilegios.</p> <p>Por \u00faltimo, indicar que la imagen del disco se guarda por defecto en el directorio <code>~/.local/share/gnome-boxes/images</code>:</p> <pre><code>usuario@kvm:~$ ls -l .local/share/gnome-boxes/images\ntotal 196\n-rwxr--r-- 1 usuario usuario 196816 may 15 21:52 ubuntu20.10-2\n</code></pre>"},{"location":"00.-KVM/02.-Instalaci%C3%B3n/04.-Conexi%C3%B3n%20local%20privilegiada%20a%20libvirt/","title":"04.-Conexi\u00f3n local privilegiada a libvirt","text":"<p>Generalmente vamos a trabajar realizando conexiones locales privilegiadas, por lo tanto si queremos ver todas las m\u00e1quinas creadas en el sistema debemos ejecutar:</p> <pre><code>usuario@kvm:~$ virsh -c qemu:///system list --all\n</code></pre> <ul> <li>Nota 1: La opci\u00f3n <code>--all</code> muestra las m\u00e1quinas que se est\u00e1n ejecutando y las que est\u00e1n paradas.</li> <li>Nota 2: Si nos conectaremos con el usuario <code>root</code> no har\u00eda falta indicar la URI <code>-c qemu:///system</code>.</li> </ul>"},{"location":"00.-KVM/02.-Instalaci%C3%B3n/04.-Conexi%C3%B3n%20local%20privilegiada%20a%20libvirt/#redes-disponibles","title":"Redes disponibles","text":"<p>Cuando instalamos QEMU/KVM + libvirt se crea una red por defecto de tipo NAT, que no est\u00e1 iniciada. Para verla, ejecutamos la siguiente instrucci\u00f3n:</p> <pre><code>usuario@kvm:~$ virsh -c qemu:///system net-list --all\n Nombre    Estado     Inicio autom\u00e1tico   Persistente\n-------------------------------------------------------\n default   inactivo   no                  si\n</code></pre> <ul> <li>Nota: La opci\u00f3n <code>--all</code> muestra las redes activas e inactivas.</li> </ul> <p>Como vemos, el estado es inactivo, para iniciarla, ejecutamos:</p> <pre><code>usuario@kvm:~$ virsh -c qemu:///system net-start default \nLa red default se ha iniciado\n</code></pre> <p>Adem\u00e1s es recomendable activar la propiedad de Incio aut\u00f3matico, para que se inicie de forma autom\u00e1tica despu\u00e9s de reiniciar el host, para ello:</p> <pre><code>usuario@kvm:~$ virsh -c qemu:///system net-autostart default\nLa red default ha sido marcada para iniciarse autom\u00e1ticamente\n</code></pre> <p>Y ejecutando de nuevo <code>virsh -c qemu:///system net-list</code>, aparece la red como activa y Inicio autom\u00e1tico a si.</p> <p>Aunque estudiaremos la redes con profundidad en el m\u00f3dulo correspondiente, podemos se\u00f1alar que las m\u00e1quinas virtuales que se conecten a esta red, tendr\u00e1n las siguientes caracter\u00edsticas:</p> <ul> <li>Tomar\u00e1n una direcci\u00f3n IP de forma din\u00e1mica en el rango <code>192.168.122.2</code> - <code>192.168.122.254</code>. Es decir, existe un servidor DHCP (que se encuentra en el host) asignando de forma din\u00e1mica el direccionamiento.</li> <li>La puerta de enlace ser\u00e1 la direcci\u00f3n IP <code>192.168.122.1</code> que corresponde al host. Est\u00e1 direcci\u00f3n tambi\u00e9n corresponde al servidor DNS que tiene configurado (que tambi\u00e9n se encuentra en el host).</li> <li>La m\u00e1quina virtual estar\u00e1 conectada a un Linux Bridge (switch virtual) llamado <code>virbr0</code> por la que se conectar\u00e1 al host.</li> <li>El host har\u00e1 de router/nat para que la m\u00e1quina tenga conectividad al exterior.</li> </ul> <p>Por defecto, las nuevas m\u00e1quinas que creemos se conectar\u00e1n a esta red.</p>"},{"location":"00.-KVM/02.-Instalaci%C3%B3n/04.-Conexi%C3%B3n%20local%20privilegiada%20a%20libvirt/#almacenamiento-disponible","title":"Almacenamiento disponible","text":"<p>Estudiaremos en profundidad el almacenamiento con el que podemos trabajar en el m\u00f3dulo correspondiente. En este momento, indicar que los ficheros correspondientes a las im\u00e1genes de discos de las nuevas m\u00e1quinas virtuales que creemos se guardar\u00e1n, por defecto, en el directorio <code>/var/lib/libvirt/images</code>.</p>"},{"location":"00.-KVM/02.-Instalaci%C3%B3n/05.-Conexi%C3%B3n%20remota%20a%20libvirt/","title":"05.-Conexi\u00f3n remota a libvirt","text":"<p>Podemos conectar al hypervisor libvirt que se est\u00e1 ejecutando en un servidor desde otra m\u00e1quina remota. Es decir, desde una m\u00e1quina cliente podemos usar, por ejemplo, <code>virsh</code> para conectarnos a un hypervisor libvirt remoto. Para ello, la sintaxis es la siguiente:</p> <pre><code>usuario@cliente:~$ virsh -c qemu+ssh://usuario_remoto@ip_servidor_remoto/system comando\n</code></pre> <p>Es decir, se va a producir una conexi\u00f3n ssh entre la m\u00e1quina cliente y el servidor donde se ejecuta libvirt. Por lo tanto hay que configurar las m\u00e1quinas para que el usuario <code>usuario</code> de la m\u00e1quina <code>cliente</code> pueda acceder por SSH al servidor remoto con el usuario <code>usuario_remoto</code>, sin que se se le pida la contrase\u00f1a.</p> <p>Para ello tendremos que copiar la clave p\u00fablica SSH del usuario <code>cliente</code> al fichero <code>~/.ssh/authorized_keys</code> del usuario <code>usuario_remoto</code> en el servidor que queremos acceder.</p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/01.-Creaci%C3%B3n%20de%20MV%20con%20virt-install/","title":"Creaci\u00f3n de m\u00e1quinas virtuales con virt-install","text":"<p>Vamos a crear nuestra primera m\u00e1quina virtual desde la l\u00ednea de comandos con la aplicaci\u00f3n <code>virt-install</code>.</p> <p>Lo primero que tenemos que hacer es instalar el paquete <code>virtinst</code>, que adem\u00e1s de este programa, tiene otras utilidades que iremos usando a los largo del curso.</p> <pre><code>apt install virtinst\n</code></pre> <p>La informaci\u00f3n que tenemos que proporcionar a <code>virt-install</code> para la creaci\u00f3n de la nueva m\u00e1quina virtual ser\u00e1 la siguiente:</p> <ul> <li>El nombre de la m\u00e1quina virtual (par\u00e1metro <code>--name</code>).</li> <li>El tipo de virtualizaci\u00f3n (par\u00e1metro <code>--virt-type</code>). en nuestro caso ser\u00e1 <code>kvm</code>.</li> <li>En nuestro caso vamos a realizar una instalaci\u00f3n desde un fichero ISO, por lo que tendremos que indicar que la nueva m\u00e1quina tendr\u00e1 un CDROM con la ISO que indiquemos (par\u00e1metro <code>--cdrom</code>).</li> <li>La variante del sistema operativo que vamos a utilizar (par\u00e1metro <code>--os-variant</code>). Para obtener la lista de variantes de sistemas operativos, podemos ejecutar <code>osinfo-query os</code> (Instalar el paquete <code>libosinfo-bin</code> si no reconoce el comando). </li> <li>El tama\u00f1o del disco (par\u00e1metro <code>--disk size</code>). Se crear\u00e1 un fichero con la imagen del disco que se guardar\u00e1 en <code>/var/lib/libvirt/images</code>.</li> <li>La cantidad de memoria RAM (par\u00e1metro <code>--memory</code>).</li> <li>La cantidad de vCPU asignadas a la m\u00e1quina (par\u00e1metro <code>--vcpus</code>).</li> </ul> <p>Podemos indicar muchos m\u00e1s par\u00e1metros a la hora de crear la nueva m\u00e1quina. Puedes obtener toda la informaci\u00f3n en la documentaci\u00f3n oficial de la aplicaci\u00f3n. Iremos usando, a lo largo del curso, diferentes par\u00e1metros de esta herramienta.</p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/01.-Creaci%C3%B3n%20de%20MV%20con%20virt-install/#creacion-de-nuestra-primera-maquina-virtual","title":"Creaci\u00f3n de nuestra primera m\u00e1quina virtual.","text":"<p>Vamos a crear una m\u00e1quina con las siguientes caracter\u00edsticas: se va a llamar <code>prueba1</code>, se va a usar una ISO de la distribuci\u00f3n GNU/Linux Debian 11, la variante de sistema operativo podemos poner <code>debian10</code>, el tama\u00f1o del disco ser\u00e1 de 10 GB, la memoria RAM ser\u00e1 de 1 GB y le vamos a asignar 1 vCPU. No vamos a indicar la red a la que se conecta ya que, por defecto, se conectar\u00e1 a la red predefinida <code>default</code>.</p> <p>Tenemos que tener en cuenta dos cosas:</p> <ol> <li>La red <code>default</code> debe estar activa: <code>virsh -c qemu:///system net-start default</code>.</li> <li>Hemos bajado una imagen ISO para la instalaci\u00f3n del sistema operativo y la tenemos guardad en el directorio <code>~/iso</code>.</li> </ol> <p>Para crear la nueva m\u00e1quina con esas caracter\u00edsticas, ejecutamos con usuario sin privilegios:</p> <pre><code>virt-install --connect qemu:///system \\\n             --virt-type kvm \\\n             --name prueba1 \\\n             --cdrom ~/iso/debian-11.3.0-amd64-netinst.iso \\\n             --os-variant debian10 \\\n             --disk size=10 \\\n             --memory 1024 \\\n             --vcpus 1\n</code></pre> <p>A continuaci\u00f3n, se iniciar\u00e1 la m\u00e1quina y se abrir\u00e1 una terminal en la aplicaci\u00f3n <code>virt-viewer</code> para que realicemos la instalaci\u00f3n:</p> <p></p> <p>\u00cdndice</p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/02.-Caracter%C3%ADsticas%20de%20la%20MV/","title":"Caracter\u00edsticas de las m\u00e1quinas virtuales","text":"<p>Despu\u00e9s de instalar nuestra primera m\u00e1quina, podemos comprobar la lista de m\u00e1quinas ejecutando la siguiente instrucci\u00f3n:</p> <pre><code>virsh -c qemu:///system list\n Id   Nombre    Estado\n----------------------------\n 2    prueba1   ejecutando\n</code></pre> <p>Si queremos acceder a la terminal de una m\u00e1quina podemos usar <code>virt-view</code> de la siguiente forma:</p> <pre><code>virt-viewer -c qemu:///system prueba1\n</code></pre>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/02.-Caracter%C3%ADsticas%20de%20la%20MV/#red","title":"Red","text":"<p>Como coment\u00e1bamos en el punto anterior, la m\u00e1quina que hemos creado se conecta, por defcto, a la red <code>default</code>. Esta red es de tipo NAT, y comprobamos que la m\u00e1quina ha recibido una IP de forma din\u00e1mica y que su puerta de enlace corresponde a la direcci\u00f3n IP <code>192.168.122.1</code>, que corresponde con el host, el servidor DNS corresponde a la misma IP y comprobamos que tiene resoluci\u00f3n y acceso a internet:</p> <p></p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/02.-Caracter%C3%ADsticas%20de%20la%20MV/#recursos-hardware","title":"Recursos hardware","text":"<p>Podemos comprobar que la maq\u00faina tiene un disco de 10 Gb y de memoria RAM 1Gb:</p> <p></p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/02.-Caracter%C3%ADsticas%20de%20la%20MV/#almacenamiento","title":"Almacenamiento","text":"<p>Un Pool de almacenamiento es un recurso de almacenamiento. Lo m\u00e1s usual es tener pools de almacenamiento que sean locales, por ejemplo un directorio. En el momento de crear la primera m\u00e1quina se han creado dos pools de almacenamiento de tipo dir y que corresponden a los dos directorios con los que estamos trabajando:</p> <ul> <li><code>default</code>: Es un pool de almacenamiento que corresponde con el directorio <code>/usr/lib/libvirt/images</code> y donde se guardar\u00e1n los ficheros correspondientes a las im\u00e1genes de disco.</li> <li><code>iso</code>: Este pool de almacenamiento se ha creado al indicar en <code>virt-install</code>el directorio donde estaba almacenado el fichero ISO. En este caso es otro pool de almacenamiento de tipo dir, y corresponde al directorio <code>~/ISO</code>.</li> </ul> <p>Podemos ver los pools de almacenamiento, que tenemos creado, ejecutando:</p> <pre><code>virsh -c qemu:///system pool-list \n Nombre    Estado   Inicio autom\u00e1tico\n---------------------------------------\n default   activo   si\n iso       activo   si\n</code></pre> <p>Un volumen es un medio de almacenamiento que podemos crear en un pool de almacenamiento en kvm. Si el pool de almacenamiento es de tipo dir, entonces el volumen ser\u00e1 un fichero de imagen.</p> <p>Veamos el volumen que se ha creado el pool <code>default</code>:</p> <pre><code>virsh -c qemu:///system vol-list default\n Nombre          Ruta\n--------------------------------------------------------\n prueba1.qcow2   /var/lib/libvirt/images/prueba1.qcow2\n</code></pre> <p>Vemos que la imagen del disco de la m\u00e1quina virtual est\u00e1 guardada en un fichero QCOW2. Tambi\u00e9n podemos ver el volumen que est\u00e1 creado en el pool <code>iso</code>:</p> <pre><code>virsh -c qemu:///system vol-list iso\n Nombre                            Ruta\n--------------------------------------------------------------------------------------\n debian-11.3.0-amd64-netinst.iso   /home/usuario/iso/debian-11.3.0-amd64-netinst.iso\n</code></pre> <p>Que corresponde al fichero de la imagen ISO que hemos copiado en el directorio <code>~/ISO</code>.</p> <p>En todos estos conceptos sobre almacenamiento profundizaremos en el m\u00f3dulo correspondiente.</p> <p>\u00cdndice</p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/03.-Gesti%C3%B3n%20de%20MV%20con%20virsh/","title":"Gesti\u00f3n de m\u00e1quinas virtuales con virsh","text":"<p>virsh es el cliente por l\u00ednea de comandos \"oficial\" de libvirt. Ofrece una shell completa para el manejo de la API.</p> <p>Cuando obtenga la ayuda de esta herramienta ver\u00e1s que en mucha ocasiones habla de dominio. Un dominio en QEMU/KVM es una m\u00e1quina virtual.</p> <p>Para obtener ayuda sobre todos los comandos que podemos ejecutar:</p> <pre><code>virsh --help\n</code></pre> <p>Si queremos pedir ayuda de un comando en concreto, por ejemplo el comando <code>list</code>, ejecutamos:</p> <pre><code>virsh list --help\n</code></pre> <p>Ya hemos usado el comando <code>list</code> para mostrar las m\u00e1quinas virtuales que tenemos creada:</p> <pre><code>virsh -c qemu:///system list --all\n Id   Nombre    Estado\n----------------------------\n 2    prueba1   ejecutando\n</code></pre> <p>Nota: Podemos referencia una m\u00e1quina virtual por su nombre o por su id.</p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/03.-Gesti%C3%B3n%20de%20MV%20con%20virsh/#ciclo-de-vida-de-una-maquina-virtual","title":"Ciclo de vida de una m\u00e1quina virtual","text":"<p>Para apagar de forma adecuada una m\u00e1quina virtual:</p> <pre><code>virsh -c qemu:///system shutdown prueba1\nDomain 'prueba1' is being shutdown\n</code></pre> <p>Para iniciar una m\u00e1quina que est\u00e1 detenida:</p> <pre><code>virsh -c qemu:///system start prueba1\nDomain 'prueba1' started\n</code></pre> <p>Si la propiedad autostart de una maquina est\u00e1 activa, cada vez que se inicie el host, esa m\u00e1quina se encender\u00e1 de forma autom\u00e1tica. Para activarlo:</p> <pre><code>virsh -c qemu:///system autostart prueba1\nDomain 'prueba1' marked as autostarted\n</code></pre> <p>Reiniciamos una m\u00e1quina virtual, ejecutando:</p> <pre><code>virsh -c qemu:///system reboot prueba1\nDomain 'prueba1' is being rebooted\n</code></pre> <p>Podemos forzar el apagado de una m\u00e1quina:</p> <pre><code>virsh -c qemu:///system destroy prueba1\nDomain 'prueba1' destroyed\n</code></pre> <p>Podemos pausar la ejecuci\u00f3n de una m\u00e1quina</p> <pre><code>virsh -c qemu:///system suspend prueba1\nDomain 'prueba1' suspended\n</code></pre> <p>Y continuar la ejecuci\u00f3n:</p> <pre><code>virsh -c qemu:///system resume prueba1\nDomain 'prueba1' resumed\n</code></pre> <p>Por \u00faltimo, para eliminar una m\u00e1quina virtual que est\u00e9 parada (eliminando los vol\u00famenes asociados):</p> <pre><code>virsh -c qemu:///system undefine --remove-all-storage  prueba1\n</code></pre>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/03.-Gesti%C3%B3n%20de%20MV%20con%20virsh/#obtener-informacion-de-la-maquina-virtual","title":"Obtener informaci\u00f3n de la m\u00e1quina virtual","text":"<p>Todos los comandos de <code>virsh</code> que empiezan por dom nos permiten obtener informaci\u00f3n de la m\u00e1quina. </p> <p>Para obtener informaci\u00f3n de la m\u00e1quina:</p> <pre><code>virsh -c qemu:///system dominfo prueba1 \n</code></pre> <p>Obtener la direcci\u00f3n IP de la interfaz de red:</p> <pre><code>virsh -c qemu:///system domifaddr prueba1\n</code></pre> <p>Obtener los discos que tiene la m\u00e1quina:</p> <pre><code>virsh -c qemu:///system domblklist prueba1\n</code></pre> <p>Puedes buscar informaci\u00f3n de m\u00e1s comandos para obtener distinta informaci\u00f3n de la m\u00e1quina virtual.</p> <p>\u00cdndice</p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/04.-Definici%C3%B3n%20XML%20de%20una%20MV/","title":"Definici\u00f3n XML de una m\u00e1quina virtual","text":"<p>Las caracter\u00edsticas, opciones y dispositivos hardware de una m\u00e1quina virtual est\u00e1n estructuradas con el lenguajes de marcas XML. De la misma forma las caracter\u00edsticas de los distintos recursos con los que podemos trabajar (redes, pools de almacenamiento, vol\u00famenes) tambi\u00e9n est\u00e1n definidos con XML.</p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/04.-Definici%C3%B3n%20XML%20de%20una%20MV/#esquema-xml-de-una-maquina-virtual","title":"Esquema XML de una m\u00e1quina virtual","text":"<p>Para obtener la definici\u00f3n XML de una m\u00e1quina virtual, ejecutamos la siguiente instrucci\u00f3n:</p> <pre><code>virsh -c qemu:///system  dumpxml prueba1\n</code></pre> <p>Veamos algunos elementos de la definici\u00f3n:</p> <ul> <li>El documento XML empieza con la etiqueta <code>&lt;domain&gt;</code> donde se indica el tipo de virtualizaci\u00f3n utilizada para gestionar la m\u00e1quina y su identificador si la m\u00e1quina est\u00e1 ejecut\u00e1ndose..</li> <li>El nombre de la m\u00e1quina se indica con la etiqueta <code>&lt;name&gt;</code>.</li> <li> <p>La etiqueta <code>&lt;currentMemory&gt;</code> nos indica la memoria asignada actualmente a la m\u00e1quina. Podemos modificar esta memoria asignada sin reiniciar la m\u00e1quina hasta el l\u00edmite indicado por la etiqueta <code>&lt;memory&gt;</code>. Por lo tanto, el valor asignado a <code>&lt;memory&gt;</code> no puede ser menor que el valor asociado a <code>&lt;currentMemory&gt;</code>.</p> <p>En este ejemplo, los dos valores son iguales porque al crear la m\u00e1quina con <code>virt-install</code> usamos el par\u00e1metro <code>--memory</code> y se asigna el valor indicado a los dos par\u00e1metros. M\u00e1s adelante estudiaremos como modificar estos par\u00e1metros.</p> </li> <li> <p>La vCPU asignadas la encontramos definida en la etiqueta <code>&lt;vcpu&gt;</code>.</p> </li> <li>Con la etiqueta <code>&lt;os&gt;</code> tenemos informaci\u00f3n de la arquitectura de la m\u00e1quina virtualizada, adem\u00e1s con las etiquetas <code>&lt;boot&gt;</code> indicamos el orden de arranque entre distintos dispositivos.</li> <li>La informaci\u00f3n de la CPU la encontramos en la etiqueta <code>&lt;cpu&gt;</code>.</li> </ul> <p>Veamos un ejemplo hasta aqu\u00ed:</p> <pre><code>domain type='kvm' id='6'&gt;\n  &lt;name&gt;prueba1&lt;/name&gt;\n  &lt;uuid&gt;a88eebdc-8a00-4b9d-bf48-cbed7bb448d3&lt;/uuid&gt;\n  ...\n  &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;\n  &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;\n  &lt;vcpu placement='static'&gt;1&lt;/vcpu&gt;\n  ...\n  &lt;os&gt;\n    &lt;type arch='x86_64' machine='pc-q35-5.2'&gt;hvm&lt;/type&gt;\n    &lt;boot dev='hd'/&gt;\n  &lt;/os&gt;\n  ...\n  &lt;cpu mode='custom' match='exact' check='full'&gt;\n    &lt;model fallback='forbid'&gt;Cooperlake&lt;/model&gt;\n    &lt;vendor&gt;Intel&lt;/vendor&gt;\n    ...\n</code></pre> <p>A continuaci\u00f3n nos encontramos la etiqueta <code>&lt;devices&gt;</code> donde se definen los distintos dispositivos hardware que forman parte de la m\u00e1quina. Veamos algunos ejemplos:</p> <ul> <li>Los discos se definen con la etiqueta <code>&lt;disk&gt;</code>. Encontramos informaci\u00f3n del tipo (en este caso fichero), tipo del fichero (en este caso qcow2), ruta donde se encuentra el fichero,... Es importante se\u00f1alar que, por defecto, se configura el disco con un controlador VirtIO (<code>bus='virtio</code>), es decir, es un dispositivo paravirtualizado que nos ofrece mayor rendimiento. Veamos la definici\u00f3n del disco:</li> </ul> <pre><code>    &lt;disk type='file' device='disk'&gt;\n      &lt;driver name='qemu' type='qcow2'/&gt;\n      &lt;source file='/var/lib/libvirt/images/prueba1.qcow2'/&gt;\n      &lt;target dev='vda' bus='virtio'/&gt;\n      &lt;address type='pci' domain='0x0000' bus='0x04' slot='0x00' function='0x0'/&gt;\n    &lt;/disk&gt;\n</code></pre> <ul> <li>Las interfaces de red se definen con la etiqueta <code>&lt;interface&gt;</code>. Encontramos informaci\u00f3n como la mac, la red a la que est\u00e1 conectada (en este caso la red <code>default</code>),... Tambi\u00e9n observamos que el modelo de la tarjeta es VirtIO (<code>&lt;model type='virtio'/&gt;</code>), de nuevo se configura un dispositivo paravirtualizado de alto rendimiento.</li> </ul> <pre><code>    &lt;interface type='network'&gt;\n      &lt;mac address='52:54:00:8a:50:d1'/&gt;\n      &lt;source network='default'/&gt;\n      &lt;model type='virtio'/&gt;\n      &lt;address type='pci' domain='0x0000' bus='0x01' slot='0x00' function='0x0'/&gt;\n    &lt;/interface&gt;\n</code></pre> <ul> <li>Si nos fijamos en otros dispositivos podremos encontrar la definici\u00f3n del teclado, del rat\u00f3n, el adaptador gr\u00e1fico, controladores PCI, CDROM, ...</li> </ul> <p>Iremos estudiando m\u00e1s elementos de la definici\u00f3n XML de una m\u00e1quina virtual, pero pode\u00eds profundizar en el formato en la documentaci\u00f3n oficial: Domain XML format.</p> <p>\u00cdndice</p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/05.-Modificaci%C3%B3n%20de%20una%20MV/","title":"Modificaci\u00f3n de la definici\u00f3n de una m\u00e1quina virtual","text":"<p>Podemos cambiar la configuraci\u00f3n de una m\u00e1quina virtual modificando su definici\u00f3n XML. Podemos cambiar el nombre, la memoria utilizada, la asignaci\u00f3n de CPU, cambiar la configuraci\u00f3n de cualquier dispositivo, eliminar o a\u00f1adir nuevos dispositivos,...</p> <p>Para realizar la modificaci\u00f3n del fichero XML tenemos dos alternativas:</p> <ol> <li>Realizar los cambios directamente en el documento XML utilizando el comando <code>virsh edit</code>.</li> <li>Utilizando comandos espec\u00edficos de <code>virsh</code> que nos ayudan a realizar el cambio de los distintos par\u00e1metros de la configuraci\u00f3n.</li> </ol> <p>Hay cambios que se pueden realizar con la m\u00e1quina funcionando, otros necesitan que la m\u00e1quina est\u00e9 parada y otros necesitan un reinicio de la m\u00e1quina para que se realicen.</p> <p>Veamos algunos ejemplos:</p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/05.-Modificaci%C3%B3n%20de%20una%20MV/#modificar-el-nombre-de-una-maquina-virtual","title":"Modificar el nombre de una m\u00e1quina virtual","text":"<p>En este caso la modificaci\u00f3n la vamos a realizar con el comando <code>virsh domrename</code>, que modificar\u00e1 internamente la definici\u00f3n XML:</p> <pre><code>virsh -c qemu:///system domrename prueba2 prueba1\nDomain 'prueba2' XML configuration edited.\n</code></pre> <p>Este cambio requiere que la m\u00e1quina est\u00e9 parada.</p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/05.-Modificaci%C3%B3n%20de%20una%20MV/#modificar-la-asignacion-de-vcpu","title":"Modificar la asignaci\u00f3n de vCPU","text":"<p>Suponemos que la m\u00e1quina est\u00e1 parada. Comprobamos el n\u00famero de vCPU asignadas a la m\u00e1quina:</p> <pre><code>virsh -c qemu:///system dominfo prueba1\n...\nCPU(s):         1\n...\n</code></pre> <p>Podemos editar la configuraci\u00f3n XML y cambiar el valor de la etiqueta <code>&lt;vcpu&gt;</code>:</p> <pre><code>virsh -c qemu:///system edit prueba1\n...\n  &lt;vcpu placement='static'&gt;2&lt;/vcpu&gt;\n...\n</code></pre> <p>Y volvemos a comprobar la informaci\u00f3n de la m\u00e1quina:</p> <pre><code>virsh -c qemu:///system dominfo prueba1\n...\nCPU(s):         2\n...\n</code></pre> <p>Tambi\u00e9n podr\u00edamos cambiar la asignaci\u00f3n de vCPU \"en caliente\" con el camando <code>virsh setvcpus</code>, pero no lo vamos a estudiar en este curso. Puedes ver este \u00e1rticulo para m\u00e1s informaci\u00f3n.</p>"},{"location":"00.-KVM/03.-Creaci%C3%B3n%20de%20MV%20desde%20el%20CLI/05.-Modificaci%C3%B3n%20de%20una%20MV/#modificar-la-asignacion-de-memoria-ram","title":"Modificar la asignaci\u00f3n de memoria RAM","text":"<p>Volvemos a suponer que la m\u00e1quina est\u00e1 parada. Podemos editar la configuraci\u00f3n XML y modificar las dos etiquetas relacionadas con la memoria:</p> <ul> <li><code>&lt;memory&gt;</code>: Valor m\u00e1ximo de RAM que podemos asignar a la m\u00e1quina \"en caliente\" (funcionando).</li> <li><code>&lt;currentMemory&gt;</code>: Cantidad de memoria asignada a la m\u00e1quina.</li> </ul> <p>Por ejemplo, dejamos la asignaci\u00f3n de memoria en un 1 Gb, y cambiamos la memoria m\u00e1xima a 3 Gb:</p> <pre><code>virsh -c qemu:///system edit prueba1\n...\n  &lt;memory unit='KiB'&gt;3145728&lt;/memory&gt;\n  &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;\n...\n</code></pre> <p>Podemos comprobar el cambio:</p> <pre><code>virsh -c qemu:///system dominfo prueba1\n...\nMemoria m\u00e1xima: 3145728 KiB\nMemoria utilizada: 1048576 KiB\n...\n</code></pre> <p>Ahora iniciamos la m\u00e1quina y podemos cambiar \"en caliente\" la memoria de la m\u00e1quina hasta un m\u00e1ximo de 3 Gb, para ello vamos a usar el comando <code>virsh setmem</code>.</p> <pre><code>virsh -c qemu:///system start prueba1\n\nvirsh -c qemu:///system setmem prueba1 2048M\n</code></pre> <p>https://www.unixarena.com/2015/12/linux-kvm-how-to-add-remove-memory-to-guest-on-fly.html/</p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/01.-Primeros%20pasos%20con%20virt-manager/","title":"Primeros pasos con virt-manager","text":"<p>virt-manager es una aplicaci\u00f3n gr\u00e1fica de escritorio para gestionar m\u00e1quinas virtuales a trav\u00e9s de libvirt. Presenta una vista resumida de las m\u00e1quinas virtuales en ejecuci\u00f3n, su rendimiento en vivo y las estad\u00edsticas de utilizaci\u00f3n de recursos. Los usuarios pueden crear nuevas m\u00e1quinas virtuales y configurarlas y gestionar sus dispositivos de hardware. Adem\u00e1s, poseer un cliente VNC / SPICE que permite el acceso de forma sencilla a la consola de la m\u00e1quina.</p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/01.-Primeros%20pasos%20con%20virt-manager/#instalacion-de-virt-manager","title":"Instalaci\u00f3n de virt-manager","text":"<p>En sistemas operativos basados en Debian / Ubuntu, simplemente ejecutamos:</p> <pre><code>apt install virt-manager\n</code></pre>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/01.-Primeros%20pasos%20con%20virt-manager/#vista-general-de-virt-manager","title":"Vista general de virt-manager","text":"<p>Pode defecto, podemos ver que virt-manager tiene configurado una conexi\u00f3n local privilegiada que se llama QEMU/KVM. Vemos las m\u00e1quinas virtuales que est\u00e1n creada en esa conexi\u00f3n (en este caso <code>prueba1</code>, que creamos en el m\u00f3dulo anterior).</p> <p>Con la opci\u00f3n Archivo-&gt;Nueva conexi\u00f3n... podemos dar de alta una nueva conexi\u00f3n.</p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/01.-Primeros%20pasos%20con%20virt-manager/#conexion-qemukvm","title":"Conexi\u00f3n QEMU/KVM","text":"<p>Si pulsamos con el bot\u00f3n derecho del rat\u00f3n sobre la conexi\u00f3n QEMU/KVM, adem\u00e1s de distintas opciones, como Nueva, Desconectar,..., encontramos la opci\u00f3n Detalles (esta opci\u00f3n tambi\u00e9n se puede elegir en el men\u00fa Editar -&gt; Detalle de la conexi\u00f3n):</p> <p></p> <p>Al elegir el detalle de la conexi\u00f3n, podemos comprobar que es una conexi\u00f3n local privilegiada. Nos conectamos a la URI <code>qemu:///system</code>. Adem\u00e1s est\u00e1 configurada para que se conecte de forma autom\u00e1tica cada vez que iniciamos la aplicaci\u00f3n:</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/01.-Primeros%20pasos%20con%20virt-manager/#redes-disponibles","title":"Redes disponibles","text":"<p>Tambi\u00e9n podemos gestionar las redes de esta conexi\u00f3n. Podemos ver las redes creadas, crear nuevas redes, eliminarlas, modificarlas, ... Vemos que tenemos creada la red <code>default</code> y ver sus caracter\u00edsticas (tipo NAT, configuraci\u00f3n ofrecida por un servidor  DHCP, Linux Bridge que gestiona,...). Por defecto est\u00e1 inactiva, para activarla, la seleccionamos y pulsamos sobre el bot\u00f3n \u25b6.</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/01.-Primeros%20pasos%20con%20virt-manager/#pools-de-almacenamiento-disponibles","title":"Pools de almacenamiento disponibles","text":"<p>Otro elemento que podemos gestionar son los Pool de almacenamiento que tenemos en la conexi\u00f3n. Recordamos que ten\u00edamos dos creados: el pool <code>default</code>, donde se guardaban las im\u00e1genes de discos, y el pool <code>iso</code>, donde almacenamos los ficheros ISO para las instalaciones de los sistemas operativos. Adem\u00e1s, podemos ver los vol\u00famenes (en este caso, los ficheros) que hay creados en cada pool.</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/01.-Primeros%20pasos%20con%20virt-manager/#conexion-remota-con-virt-manager","title":"Conexi\u00f3n remota con virt-manager","text":"<p>Si quisi\u00e9ramos conectarnos de forma remota a un servidor donde se est\u00e1 ejecutando libvirt, podr\u00edamos crear una nueva conexi\u00f3n: Archivo -&gt; A\u00f1adir conexi\u00f3n..., y crear una conexi\u00f3n y elegir la opci\u00f3n Conectar a anfitri\u00f3n mediante SSH:</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/01.-Primeros%20pasos%20con%20virt-manager/#conclusion","title":"Conclusi\u00f3n","text":"<p><code>virt-manager</code> es otra aplicaci\u00f3n que nos permite hacer conexiones a libvirt, como hacemos con la aplicaci\u00f3n <code>virsh</code> o <code>virt-install</code>. Por lo tanto, los recursos virtualizados que gestionamos con estas aplicaciones cuando nos conectamos a <code>qemu:///system</code> son los mismos. Los cambios que hagamos con una aplicaci\u00f3n se ven reflejados en cualquiera de las otras. <code>virt-manager</code> es m\u00e1s f\u00e1cil de usar, pero nos ofrece menos opciones que la aplicaci\u00f3n <code>virsh</code> o <code>virt-install</code>.</p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/02.-Creaci%C3%B3n%20de%20MV%20linux/","title":"Creaci\u00f3n de m\u00e1quinas virtuales Linux","text":"<p>Vamos a estudiar los pasos fundamentales para la creaci\u00f3n de una m\u00e1quina virtual. en este caso vamos a crear una m\u00e1quina virtual con el sistema operativo GNU/Linux Ubuntu. Observaremos que la informaci\u00f3n que vamos indicando en virt-manager es la misma que utilizamos para la creaci\u00f3n d m\u00e1quinas con la herramienta <code>virt-install</code>.</p> <p>Antes de empezar la creaci\u00f3n de la nueva m\u00e1quina, hemos copiado en el pool de almacenamiento ISO (directorio <code>~/iso</code>) una imagen ISO para la instalaci\u00f3n de Ubuntu:</p> <p></p> <p>Para crear una nueva m\u00e1quina virtual con virt-manager podemos escoger la opci\u00f3n de men\u00fa Archivo -&gt; Nueva m\u00e1quina virtual, o el bot\u00f3n del men\u00fa:</p> <p></p> <p>A continuaci\u00f3n seguimos los pasos del asistente para la creaci\u00f3n de la m\u00e1quina virtual:</p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/02.-Creaci%C3%B3n%20de%20MV%20linux/#elegir-la-fuente-de-instalacion-del-sistema-operativo","title":"Elegir la fuente de instalaci\u00f3n del sistema operativo","text":"<p>Elegimos como fuente de instalaci\u00f3n: instalaci\u00f3n local desde una imagen ISO que se montar\u00e1 en un CDRON. En este apartado tambi\u00e9n podemos escoger la arquitectura de la m\u00e1quina que vamos a utilizar.</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/02.-Creaci%C3%B3n%20de%20MV%20linux/#seleccionar-la-iso-de-instalacion","title":"Seleccionar la ISO de instalaci\u00f3n","text":"<p>Elegimos fichero ISO desde donde vamos a realizar la instalaci\u00f3n. Si no se detecta la variante del sistema operativo, tenemos que a\u00f1adirla manualmente escogiendo la versi\u00f3n m\u00e1s parecida a la que vamos a instalar.</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/02.-Creaci%C3%B3n%20de%20MV%20linux/#configuracion-de-memoria-y-de-vcpu","title":"Configuraci\u00f3n de memoria y de VCPU","text":"<p>A continuaci\u00f3n, asignamos la memoria y el n\u00famero de vCPU a la nueva m\u00e1quina que estamos creando.</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/02.-Creaci%C3%B3n%20de%20MV%20linux/#seleccionar-almacenamiento","title":"Seleccionar almacenamiento","text":"<p>En este paso, habilitamos el almacenamiento para la nueva m\u00e1quina, indicando el tama\u00f1o del disco.</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/02.-Creaci%C3%B3n%20de%20MV%20linux/#resumen-y-seleccion-de-red","title":"Resumen y selecci\u00f3n de red","text":"<p>Por \u00faltimo, aparece un resumen de las caracter\u00edsticas de la m\u00e1quina que vamos a crear. Adem\u00e1s, podemos indicar el nombre y seleccionar la red a la que queremos que se conecte (en nuestro caso, la red de tipo NAT <code>default</code>). Si la red no est\u00e1 activa, nos dar\u00e1 la opci\u00f3n de activarla.</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/02.-Creaci%C3%B3n%20de%20MV%20linux/#comenzamos-la-instalacion","title":"Comenzamos la instalaci\u00f3n","text":"<p>Al pulsar el bot\u00f3n Finalizar, se crea la m\u00e1quina, se inicializa y se abre la consola para que podamos empezar la instalaci\u00f3n.</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/03.-Gesti%C3%B3n%20de%20MV/","title":"Gesti\u00f3n de m\u00e1quinas virtuales","text":"<p>Para elegir las distintas opciones que tenemos para gestionar nuestras m\u00e1quinas, pulsamos sobre el bot\u00f3n derecho en la m\u00e1quina:</p> <p></p> <ul> <li>Ejecutar: Si la m\u00e1quina est\u00e1 parada, la inicia. Tambi\u00e9n podemos usar el bot\u00f3n 1 del men\u00fa.</li> <li>Pausa: Pausa la ejecuci\u00f3n de la m\u00e1quina virtual. Podremos reanudar la ejecuci\u00f3n con la opci\u00f3n Reanudar. Tambi\u00e9n podemos usar el bot\u00f3n 2 del men\u00fa.</li> <li>Apagar: En este men\u00fa tenemos varias opciones (todas estas opciones tambi\u00e9n se pueden elegir en el bot\u00f3n 4 del men\u00fa):<ul> <li>Reiniciar: Reinicia la m\u00e1quina.</li> <li>Apagar: Apaga la m\u00e1quina. Tambi\u00e9n podemos usar el bot\u00f3n 3 del men\u00fa.</li> <li>Forzar Reajuste: Apaga la m\u00e1quina simulando que se pulsa el bot\u00f3n reset.</li> <li>Forzar apagado: Fuerza el apagado de la m\u00e1quina.</li> <li>Guardar: Guarda el estado de la m\u00e1quina en memoria. Para recuperar la m\u00e1quina escogemos la opci\u00f3n Reanudar.</li> </ul> </li> <li>Clonar: Crea una nueva m\u00e1quina a partir de esta.</li> <li>Migrar: Nos permite trasladar la m\u00e1quina a otra m\u00e1quina que este ejecutando QEMU/KVM.</li> <li>Eliminar: Elimina la definici\u00f3n de la m\u00e1quina. Nos da la opci\u00f3n de eliminar el volumen de disco asociado.</li> <li>Abrir: Abre el \"Detalle de la m\u00e1quina\". esta opci\u00f3n tambi\u00e9n se puede escoger desde el bot\u00f3n Abrir, o desde la opci\u00f3n del men\u00fa Editar -&gt; Detalles de la m\u00e1quina virtual. Esta opci\u00f3n la estudiaremos en el siguiente punto.</li> </ul>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/04.-Detalles%20de%20las%20MV/","title":"Detalles de las m\u00e1quinas virtuales","text":"<p>Podemos acceder al detalle de una m\u00e1quina virtual de tres formas distintas: haciendo doble click sobre la m\u00e1quina, escogiendo la m\u00e1quina y pulsando el bot\u00f3n Abrir o escogiendo la opci\u00f3n del men\u00fa Editar -&gt; Detalles de la m\u00e1quina virtual.</p> <p>Vamos a abrir una ventana con las siguientes opciones:</p> <p></p> <ul> <li>Archivo: Opciones generales: ver el gestor, cerrar la ventana,...</li> <li>M\u00e1quina Virtual: Opciones para gestionar la m\u00e1quina.</li> <li>Vista: Nos permite ver las distintas vistas, controlar la ventana de la consola (pantalla completa, escalar, ...). Veamos las vistas:<ul> <li>Consola: Accedemos a una consola donde controlamos la m\u00e1quina virtual. Tambi\u00e9n se accede con el bot\u00f3n 1.</li> <li>Detalles: Obtenemos la configuraci\u00f3n de la m\u00e1quina virtual y los dispositivos hardware. Podemos quitar y a\u00f1adir nuevos dispositivos y hacer las modificaciones necesarias.Tambi\u00e9n se accede con el bot\u00f3n 2.</li> <li>Instant\u00e1neas: Ventana para gestionar las instant\u00e1neas de la m\u00e1quina virtual. Estudiaremos m\u00e1s adelante las instant\u00e1neas. Tambi\u00e9n se accede con el bot\u00f3n 3.</li> </ul> </li> <li>Enviar Tecla: Combinaci\u00f3n de teclas que podemos enviar a la m\u00e1quina virtual.</li> </ul>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/04.-Detalles%20de%20las%20MV/#vista-consola","title":"Vista Consola","text":"<p>Accedemos a una consola desde donde podemos controlar la m\u00e1quina virtual. Desde el men\u00fa vista podemos configurar el tama\u00f1o de la pantalla (pantalla completa, escalar monitor, ...). Puede ser una buena herramienta para realizar peque\u00f1as modificaciones a la m\u00e1quina, pero es recomendable utilizar distintos protocolos para el acceso y gesti\u00f3n de la m\u00e1quina virtual (SSH, VCN, RDP,...)</p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/04.-Detalles%20de%20las%20MV/#vista-detalles","title":"Vista Detalles","text":"<p>En esta vista se nos muestra la definici\u00f3n XML de la m\u00e1quina virtual de forma gr\u00e1fica. Adem\u00e1s, nos posibilita hacer cambios en la configuraci\u00f3n de la misma. Vemos la configuraci\u00f3n general de la m\u00e1quina y las caracter\u00edsticas de los dispositivos hardware que tiene configurada. Podemos quitas dispositivos y a\u00f1adir otros nuevos.</p> <p>Veamos los elementos fundamentales:</p> <ul> <li>Repaso: Nos da la informaci\u00f3n general de la m\u00e1quina virtual. </li> </ul> <p></p> <p>Adem\u00e1s, en todo momento podemos acceder a la definici\u00f3n XML:</p> <p></p> <ul> <li>CPUs: Configuraci\u00f3n de las vCPU asignadas a la m\u00e1quina. Podemos modificar este valor. Si la m\u00e1quina est\u00e1 ejecut\u00e1ndose la modificaci\u00f3n ser\u00e1 efectiva en el siguiente arranque de la m\u00e1quina.</li> </ul> <p></p> <ul> <li>Memoria: Del mismo modo, vemos la configuraci\u00f3n de asignaci\u00f3n de memoria RAM de la m\u00e1quina. Podemos modificar la memoria actual y la memoria m\u00e1xima. Del mismo modo, necesitamos reiniciar la m\u00e1quina para que tenga efecto el cambio.</li> </ul> <p></p> <ul> <li>Opciones de arranque: Podemos ver y configurar el orden de los dispositivos de arranque.</li> </ul> <p>Imagen de opciones de arranque</p> <p>A continuaci\u00f3n se nos muestra los distintos dispositivos hardware que tiene configurado la m\u00e1quina: unidades de disco, interfaces de red, teclado, rat\u00f3n, adaptador de v\u00eddeo, interfaces, ... Pudiendo hacer tambi\u00e9n, modificaciones en los mismos. Veamos algunos de ellos:</p> <ul> <li>Discos: Nos da informaci\u00f3n del disco que tiene configurada la m\u00e1quina. Es importante, como ya hemos indicado anteriormente, que el el driver sea VirtIO para obtener mayor rendimiento. Vemos que podemos a\u00f1adir a las m\u00e1quinas virtuales tantos discos como sean necesarios.</li> </ul> <p></p> <ul> <li>Interfaces de red: Obtenemos la informaci\u00f3n de las distintas interfaces de red de la m\u00e1quina. en este caso tambi\u00e9n usamos VirtIO como modelo de dispositivo. Vemos a que red est\u00e1 conectada. Si la m\u00e1quina se est\u00e1 ejecutando, podemos ver la direcci\u00f3n IP de la interfaz. Del mismo modo, los cambios ser\u00e1n efectivos tras el reinicio de la m\u00e1quina.</li> </ul> <p></p> <p>Por \u00faltimo, tenemos dos operaciones referente a los dispositivos hardware:</p> <ul> <li>Si seleccionamos uno de ellos, y pulsamos el bot\u00f3n derecho del rat\u00f3n nos da la posibilidad de Eliminar Hardware.</li> <li>Con el bot\u00f3n Agregar Hardware, tenemos la posibilidad de a\u00f1adir nuevos componentes a la configuraci\u00f3n de la m\u00e1quina. Hay que indicar que algunos dispositivos se pueden agregar \"en caliente\", con la m\u00e1quina en estado de ejecuci\u00f3n. En los pr\u00f3ximos apartados del curso usaremos est\u00e1 opci\u00f3n para a\u00f1adir nuevos componentes a nuestras m\u00e1quinas virtuales.</li> </ul> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/05.-Creaci%C3%B3n%20de%20MV%20Wndows/","title":"Creaci\u00f3n de m\u00e1quinas virtuales Windows","text":"<p>En un apartado anterior hemos visto los pasos fundamentales para la creaci\u00f3n de una m\u00e1quina virtual Linux. Para crear una m\u00e1quina virtual con un sistema operativo tipo Windows se siguen los mismos pasos, pero tenemos que tener en cuenta que Windows no tiene soporte nativo para dispositivos VirtIO. Por lo tanto, a la hora de crear una m\u00e1quina virtual Windows tendremos que a\u00f1adir los controladores de dispositivos (drivers) necesarios para que Windows identifique los dispositivos VirtIO que definamos en la m\u00e1quina virtual.</p> <p>En este caso, el proyecto Fedora proporciona controladores de dispositivos de software libre para VirtIO en Windows.</p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/05.-Creaci%C3%B3n%20de%20MV%20Wndows/#iso-de-los-controladores-de-dispositivo-virtio-para-windows","title":"ISO de los controladores de dispositivo VirtIO para Windows","text":"<p>Podemos bajar la \u00faltima versi\u00f3n de los drivers VirtIO para Windows en el siguiente enlace y copiar la ISO al pool de almacenamiento ISO, es decir, en el directorio <code>~/iso</code>. Tambi\u00e9n hemos copiado a ese directorio una ISO para la instalaci\u00f3n de Windows 10.</p> <p></p> <p>Creamos la nueva m\u00e1quina virtual Windows</p> <p>Teniendo en cuenta los siguiente:</p> <ul> <li>Elegimos una imagen ISO para instalar una versi\u00f3n de Windows y seleccionamos la variante del sistema operativo que estamos instalando.</li> <li>Configuramos la CPU y la RAM para tener recursos suficientes.</li> <li>Como estamos instalando un sistema operativo Windows, virt-manager va a configurar los dispositivos para que sean compatibles con el sistema operativo. En concreto, el driver del disco y de la tarjeta de red no ser\u00e1n VirtIO, con lo que no conseguiremos el rendimiento adecuado. Por lo tanto, antes de realizar la instalaci\u00f3n vamos a cambiar el tipo de driver de estos dispositivos, escogiendo VirtIO para obtener el m\u00e1ximo de rendimiento. </li> </ul> <p>En la pantalla final del asistente de creaci\u00f3n de la m\u00e1quina virtual, escogeremos la opci\u00f3n Personalizar la configuraci\u00f3n antes de instalar:</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/05.-Creaci%C3%B3n%20de%20MV%20Wndows/#elegimos-dispositivos-virtio","title":"Elegimos dispositivos VirtIO","text":"<p>El primer cambio ser\u00e1 elegir el driver VirtIO para el disco. Como observamos se ha configurado con el driver SATA, que ser\u00e1 compatible con Windows, pero al ser un dispositivo emulado, nos dar\u00e1 menos rendimiento. Escogemos la opci\u00f3n VirtIO, y pulsamos en el bot\u00f3n Aplicar:</p> <p></p> <p>A continuaci\u00f3n, cambiamos el driver de la tarjeta de red. Del mismo modo, observamos que ha escogido un modelo e1000e, compatible con Windows, pero del mismo modo nos ofrece menos rendimiento que la opci\u00f3n VirtIO. cuando hagamos el cambio, volvemos a pulsar sobre el bot\u00f3n Aplicar. Nota: Como hemos comentado Windows no es compatible con este modelo de tarjeta de red, por lo que durante la instalaci\u00f3n no tendremos conexi\u00f3n a internet. Si necesitamos tener conexi\u00f3n, podr\u00edamos dejar el modelo escogido por defecto, y posteriormente modificar la configuraci\u00f3n de la tarjeta.</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/05.-Creaci%C3%B3n%20de%20MV%20Wndows/#anadimos-un-cdrom-con-los-drivers-virtio","title":"A\u00f1adimos un CDROM con los drivers VirtIO","text":"<p>Antes de iniciar la m\u00e1quina, le a\u00f1adimos un CD-ROM con la imagen ISO de los drivers VirtIO. Para ello, pulsamos el bot\u00f3n Agregar Hardware, y a\u00f1adimos un nuevo dispositivo de almacenamiento:</p> <p></p> <p>Adem\u00e1s, nos tenemos que asegurar que en el orden de arranque el CDROM donde hemos montado la ISO de Windows est\u00e9 por delante que el CDROM con los drivers VirtIO, y sea la primera opci\u00f3n. Una vez terminado pulsamos el bot\u00f3n Aplicar y el bot\u00f3n Iniciar la instalaci\u00f3n para comenzar la instalaci\u00f3n.</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/05.-Creaci%C3%B3n%20de%20MV%20Wndows/#comenzamos-la-instalacion","title":"Comenzamos la instalaci\u00f3n","text":"<p>Iniciamos la m\u00e1quina, accedemos a la consola y comenzamos la instalaci\u00f3n, hasta que llegamos a la pantalla donde tenemos que escoger el disco duro donde vamos a realizar la instalaci\u00f3n.</p> <p></p> <p>Como vemos no se puede detectar el disco duro, ya que Windows no puede reconocer inicialmente el controlador VirtIO. Vamos a cargar los controladores de dispositivo VirtIO que necesitamos del CDROM que hemos montado:</p> <p>Elegimos la opci\u00f3n Cargar contr., le damos a Examinar y elegimos del CDROM donde tenemos los drivers VirtIO la carpeta de nuestra arquitectura (amd64) y la versi\u00f3n de Windows.</p> <p></p> <p>Y ya podemos continuar con la instalaci\u00f3n de Windows porque ya detecta el disco duro:</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/05.-Creaci%C3%B3n%20de%20MV%20Wndows/#configuracion-de-la-red","title":"Configuraci\u00f3n de la red","text":"<p>Como indic\u00e1bamos anteriormente, tambi\u00e9n hemos escogido el controlador VirtIO para la tarjeta de red. Una vez realizada la configuraci\u00f3n tendremos que instalar los drivers adecuados para que funcione la tarjeta de red. Para ello, actualizamos el controlador del dispositivo Controladora Ethernet en el Administrador de dispositivos:</p> <p></p> <p>Y escogemos la carpeta del CDROM donde hemos montado los drivers VirtIO: <code>NetKVM\\&lt;carpeta con el nombre de tu versi\u00f3n de windows&gt;\\amd64</code>:</p> <p></p>"},{"location":"00.-KVM/04.-Creaci%C3%B3n%20de%20MV%20con%20virt-manager/05.-Creaci%C3%B3n%20de%20MV%20Wndows/#creacion-de-una-maquina-virtual-windos-con-virt-install","title":"Creaci\u00f3n de una m\u00e1quina virtual Windos con virt-install","text":"<p>Si queremos crear con <code>virt-install</code> una m\u00e1quina virtual para la instalaci\u00f3n de Windows con la misma configuraci\u00f3n que hemos visto anteriormente, podemos ejecutar la siguiente instrucci\u00f3n:</p> <pre><code>virt-install --connect qemu:///system \\\n             --virt-type kvm \\\n             --name prueba4 \\\n             --cdrom ~/iso/Win10_21H2_Spanish_x64.iso \\\n             --os-variant win10 \\\n             --disk size=40,bus=virtio \\\n             --disk ~/iso/virtio-win-0.1.217.iso,device=cdrom \\\n             --network=default,model=virtio \\\n             --memory 2048 \\\n             --vcpus 2\n</code></pre> <p>Tenemos que tener en cuanta algunas cosas nuevas que hemos introducido:</p> <ul> <li><code>--disk size=40,bus=virtio</code>: En la declaraci\u00f3n del disco indicamos el controlador VirtIO.</li> <li><code>--disk ~/iso/virtio-win-0.1.217.iso,device=cdrom</code>: El segundo CDROM se indica con el par\u00e1metro <code>disk</code> indicando <code>device=cdrom</code>.</li> <li><code>--network=default,model=virtio</code>: De la misma manera, indicamos el modelo de tarjeta de red como VirtIO.</li> </ul>"},{"location":"00.-KVM/05.-Almacenamiento/01.-Introducci%C3%B3n%20al%20almacenamiento/","title":"01.-Introducci\u00f3n al almacenamiento","text":"<p>El almacenamiento en disco es una parte esencial en los sistemas inform\u00e1ticos, ya que permite guardar de forma persistente grandes cantidades de informaci\u00f3n.</p> <p>Veamos distintas caracter\u00edsticas del almacenamiento en discos:</p>"},{"location":"00.-KVM/05.-Almacenamiento/01.-Introducci%C3%B3n%20al%20almacenamiento/#sistemas-de-ficheros-vs-dispositivos-de-bloques","title":"Sistemas de Ficheros vs. Dispositivos de Bloques","text":"<ul> <li>Dispositivos de Bloques: <ul> <li>Son unidades (f\u00edsicas o l\u00f3gicas) de almacenamiento que gestionan los datos en bloques de tama\u00f1o fijo. </li> <li>Estos dispositivos permiten el acceso directo a cualquier bloque sin necesidad de leer todos los anteriores, lo que facilita la lectura y escritura aleatoria de datos. </li> <li>Estos dispositivos se pueden particionar, formatear, montar,...</li> <li>Ejemplos: Discos, particiones, vol\u00famenes l\u00f3gicos, ficheros llamados im\u00e1genes de discos (osi, img, raw, qcow2,...),...</li> </ul> </li> <li>Sistemas de ficheros:<ul> <li>El formateo de un dispositivo de bloque nos permite estructurarlo de forma l\u00f3gica (ficheros y directorios). Ejemplos: ext4, xfs, ntfs, btrfs, zfs, ...</li> <li>Proporcionan una interfaz que permite a los usuarios y aplicaciones almacenar, organizar y acceder a los archivos y directorios de manera sencilla.</li> </ul> </li> </ul>"},{"location":"00.-KVM/05.-Almacenamiento/01.-Introducci%C3%B3n%20al%20almacenamiento/#fuente-del-almacenamiento","title":"Fuente del almacenamiento","text":"<ul> <li>Si el disco est\u00e1 conectado directamente en el ordenador se denomina DAS (Direct Attached Storage).</li> <li>En otras ocasiones el almacenamiento se encuentra en un servidor y se comparte a un cliente. En este caso se denomina almacenamiento compartido, y tenemos dos alternativas:<ul> <li> <ul> <li>NAS (Network Attached Storage): Se comparte por red el almacenamiento en forma de sistema de ficheros. Ejemplos: nfs, samba, glusterfs,...</li> </ul> </li> <li>SAN (Storage Area Network): En una red de almacenamiento se comparte dispositivos de bloques. Ejemplo: iSCSI, FiberChanel,...</li> </ul> </li> </ul> <p>Dependiendo de la tecnolog\u00eda usada para realizar el almacenamiento compartido tendremos varias caracter\u00edsticas:</p> <ul> <li>NFS es un sistema de almacenamiento compartido de tipo NAS, que permite a varios clientes leer y escribir en los ficheros de un mismo directorio. Se pueden tener problemas  de corrupci\u00f3n de datos si dos clientes tratan al mismo tiempo de cambiar un mismo fichero.</li> <li>iSCSI es un sistema de almacenamiento compartido de tipo SAN, que nos permite compartir un dispositivo de bloque entre varios clientes. Si es uno s\u00f3lo de los clientes el que escribe y los dem\u00e1s leen, no hay ning\u00fan problema. Pero si queremos que todos los clientes tengan la posibilidad de leer y escribir, podemos tener problemas de corrupci\u00f3n. En estos casos es necesario usar sistemas de archivos de cl\u00fasteres que a\u00f1aden mecanismos de bloqueo para que no se pueda cambiar al mismo tiempo un fichero. Por ejemplo: cfs2, ocfs2, glusterFS, Ceph, ...</li> </ul>"},{"location":"00.-KVM/05.-Almacenamiento/01.-Introducci%C3%B3n%20al%20almacenamiento/#snapshots-instantaneas","title":"Snapshots (Instant\u00e1neas)","text":"<p>Los snapshots son una caracter\u00edstica avanzada de los sistemas de almacenamiento que permiten capturar el estado completo de un sistema de ficheros en un momento dado. Los snapshots son muy \u00fatiles para:</p> <ul> <li>Recuperaci\u00f3n ante fallos: Si se produce un fallo en el sistema, se puede restaurar el sistema de ficheros al estado en que se encontraba en el momento en que se tom\u00f3 la instant\u00e1nea.</li> <li>Pruebas y desarrollo: Los snapshots permiten hacer pruebas sin riesgo de da\u00f1ar los datos originales, ya que se puede volver a un estado anterior de forma r\u00e1pida.</li> </ul>"},{"location":"00.-KVM/05.-Almacenamiento/01.-Introducci%C3%B3n%20al%20almacenamiento/#aprovisionamiento-ligero-thin-provisioning","title":"Aprovisionamiento Ligero (Thin Provisioning)","text":"<p>El aprovisionamiento ligero es una t\u00e9cnica utilizada en sistemas de almacenamiento para optimizar la utilizaci\u00f3n del espacio disponible. En lugar de asignar todo el espacio de almacenamiento a una unidad o volumen desde el principio (lo que se conoce como aprovisionamiento grueso o thick provisioning), el aprovisionamiento ligero asigna espacio seg\u00fan sea necesario.</p> <p>Por ejemplo, podemos tener un dispositivo de almacenamiento de 30 GB (virtuales), pero que solo ocupa en disco (almacenamiento real) los datos que va guardando. Ejemplos: Im\u00e1genes de disco qcow2, thin-LVM,...</p>"},{"location":"00.-KVM/05.-Almacenamiento/02.-Introducci%C3%B3n%20al%20almacenamiento%20en%20QEMU%E2%81%84KVM%20%2B%20libvirt/","title":"02.-Introducci\u00f3n al almacenamiento en QEMU\u2044KVM + libvirt","text":"<p>Libvirt proporciona la gesti\u00f3n del almacenamiento a trav\u00e9s de pools de almacenamiento y vol\u00famenes.</p> <ul> <li>Pools de Almacenamiento: Es una fuente de almacenamiento, una cantidad de almacenamiento que el administrador del host ha configurado para su uso por las m\u00e1quinas virtuales.</li> <li>Vol\u00famenes: Los pools de almacenamiento se dividen en vol\u00famenes. Cada uno de estos vol\u00famenes lo utilizaran las m\u00e1quinas virtuales como discos (dispositivos de bloques).</li> </ul>"},{"location":"00.-KVM/05.-Almacenamiento/02.-Introducci%C3%B3n%20al%20almacenamiento%20en%20QEMU%E2%81%84KVM%20%2B%20libvirt/#tipos-de-pools-de-almacenamiento","title":"Tipos de Pools de Almacenamiento","text":"<p>QEMU/KVM + libvirt puede trabajar con distintas fuentes y tecnolog\u00edas de almacenamiento que nos ofrecer\u00e1n distintas caracter\u00edsticas:</p> <ul> <li> <p>dir: Nos ofrece un directorio del host (por lo tanto, nos ofrece un sistema de archivo). Este tipo no nos ofrece la caracter\u00edstica de almacenamiento compartido. Los discos de las m\u00e1quinas virtuales se guardaran en ficheros de imagen de disco. Tenemos distintos formatos de ficheros de im\u00e1genes:</p> <ul> <li>raw: el formato raw es una imagen binaria sencilla de la imagen del disco. Se ocupa todo el espacio que hayamos indicado al crearla. El acceso es m\u00e1s eficiente. No soporta ni snapshots ni aprovisionamiento ligero.</li> <li>qcow2: formato QEMU copy-on-write. Al crearse s\u00f3lo se ocupa el espacio que se est\u00e1 ocupando con los datos (aprovisionamiento ligero), el fichero ir\u00e1 creciendo cuando escribamos en el \u00e9l. Acepta instant\u00e1neas o snapshots. Es menos eficiente en cuanto al acceso.</li> <li>vdi, vmdk,...: formatos de otros sistemas de virtualizaci\u00f3n.</li> </ul> <p>En un Pool de Almacenamiento de tipo dir, los vol\u00famenes son ficheros de im\u00e1genes de disco. Los Pools de Almacenamiento con lo que hemos trabajado hasta ahora (<code>default</code> y <code>iso</code>) son de este tipo.</p> </li> <li> <p>logical: En este caso, utilizamos LVM (Logical Volume Manager). El Pool de Almacenamiento controlar\u00e1 un Grupo de Vol\u00famenes, y los vol\u00famenes (los discos de las m\u00e1quinas virtuales) ser\u00e1n vol\u00famenes l\u00f3gicos que se crear\u00e1n en el grupo de vol\u00famenes. Este tipo de almacenamiento no ofrece almacenamiento compartido.</p> </li> <li>netfs: Este tipo de Pool de Almacenamiento montar\u00e1 un directorio desde un servidor NAS (nfs, glusterfs, cifs,...). Por lo tanto obtendremos la caracter\u00edstica de compartici\u00f3n y de migraci\u00f3n en vivo. Los vol\u00famenes ser\u00e1n ficheros de im\u00e1genes de disco.</li> <li>iSCSI: Este tipo de Pool de Almacenamiento montar\u00e1 un disco desde un servidor SAN de tipo iSCSI. Obtendremos la caracter\u00edstica de almacenamiento compartido a nivel de disco con las consideraciones que vimos en el punto anterior.</li> <li>Muchos m\u00e1s...</li> </ul>"},{"location":"00.-KVM/05.-Almacenamiento/02.-Introducci%C3%B3n%20al%20almacenamiento%20en%20QEMU%E2%81%84KVM%20%2B%20libvirt/#gestion-de-volumenes-de-almacenamiento","title":"Gesti\u00f3n de vol\u00famenes de almacenamiento","text":"<p>Los vol\u00famenes son los medios de medios de almacenamiento que utilizar\u00e1n las m\u00e1quinas virtuales. Un Pool de Almacenamiento estar\u00e1 formado por vol\u00famenes. Dependiendo del tipo del pool, el volumen corresponder\u00e1 a un medio de almacenamiento determinado. Veamos un ejemplo:</p> <ul> <li>Si el tipo del pool es dir, es decir, un directorio del sistema de fichero del host, el volumen corresponde a un fichero (el fichero que contiene la imagen del disco).</li> <li>Si el tipo del pool es logical, es decir, gestiona un grupo de vol\u00famenes LVM, el volumen corresponder\u00e1 a un volumen l\u00f3gico LVM.</li> </ul> <p>Por lo tanto tenemos dos enfoques para crear los vol\u00famenes:</p> <ul> <li>Usar la API de libvirt, es decir, usar herramientas como <code>virsh</code> o <code>virt-manager</code> para gestionar los vol\u00famenes. En este caso, si creamos un volumen en un pool de tipo dir, estar\u00edamos creando un fichero de imagen de disco. Del mismo modo, si lo creamos en un pool de tipo logical estar\u00edamos creando un volumen l\u00f3gico LVM.</li> <li>Utilizar herramientas espec\u00edficas para crear los medios de almacenamiento y posteriormente refrescar el pool para que a\u00f1ada el nuevo volumen. Ejemplo: podemos usar la herramienta <code>qemu-img</code> para la creaci\u00f3n de un fichero de imagen de disco y posteriormente actualizaremos el pool de tipo dir para a\u00f1adir el nuevo volumen que corresponde al fichero que hemos creado. Otro ejemplo: usar la l\u00ednea de comandos de LVM, creando un volumen l\u00f3gico con el comando <code>lvcreate</code> y posteriormente actualizamos el pool de tipo logical para a\u00f1adir el nuevo volumen.</li> </ul> <p>Si estamos trabajando localmente en un servidor donde tenemos QEMU/KVM + libvirt instalado, no hay muchas diferencias de usar una y otra opci\u00f3n. El uso de la API de libvirt puede ser m\u00e1s interesante si estamos conectados a la API de libvirt de forma remota, ya que al gestionar los vol\u00famenes estar\u00edamos gestionando los recursos de almacenamiento (ficheros, vol\u00famenes l\u00f3gicos,...) sin necesidad de acceder al servidor y crearlos con herramientas espec\u00edficas.</p>"},{"location":"00.-KVM/05.-Almacenamiento/02.-Introducci%C3%B3n%20al%20almacenamiento%20en%20QEMU%E2%81%84KVM%20%2B%20libvirt/#conclusiones","title":"Conclusiones","text":"<p>Tenemos la posibilidad de crear distintos tipos de Pools de Almacenamiento, que nos ofrecen distintas caracter\u00edsticas. Podemos ver los distintos tipos al crear un Pool desde <code>virt-manager</code>:</p> <p></p> <p>En este curso vamos a trabajar con los Pool de Almacenamiento de tipo dir. Si quieres profundizar en las caracter\u00edsticas de los distintos tipos de almacenamiento puedes ver la documentaci\u00f3n oficial: Storage Management.</p>"},{"location":"00.-KVM/05.-Almacenamiento/03.-Gesti%C3%B3n%20de%20Pools%20de%20Almacenamiento/","title":"03.-Gesti\u00f3n de Pools de Almacenamiento","text":""},{"location":"00.-KVM/05.-Almacenamiento/03.-Gesti%C3%B3n%20de%20Pools%20de%20Almacenamiento/#gestion-de-pools-de-almacenamiento-con-virsh","title":"Gesti\u00f3n de Pools de Almacenamiento con virsh","text":"<p>Como hemos visto durante este curso tenemos a nuestra disposici\u00f3n dos Pool de Almacenamiento, para ver los pools con la herramienta <code>virsh</code>, ejecutamos la siguiente instrucci\u00f3n:</p> <pre><code>virsh -c qemu:///system pool-list \n Nombre    Estado   Inicio autom\u00e1tico\n---------------------------------------\n default   activo   si\n iso       activo   si\n</code></pre> <p>Recuerda que el pool por defecto donde se guardan las im\u00e1genes de disco, es <code>default</code>. Podemos obtener informaci\u00f3n de ese pool con la instrucci\u00f3n:</p> <pre><code>virsh -c qemu:///system pool-info default \nNombre:         default\nUUID:           0a03e05b-8844-4029-8216-430fc289fe8f\nEstado:         ejecutando\nPersistente:    si\nAutoinicio:     si\nCapacidad:      87,09 GiB\nUbicaci\u00f3n:     36,61 GiB\nDisponible:     50,48 GiB\n</code></pre> <p>Al igual que las m\u00e1quinas virtuales, los Pools de Almacenamiento se definen por un documento XML. Para ver la definici\u00f3n XML del pool <code>default</code> podemos ejecutar <code>virsh -c qemu:///system pool-dumpxml default</code>. A partir de un fichero XML con la definici\u00f3n de un nuevo pool, podr\u00edamos crearlo con el subcomando <code>virsh pool-define</code>. </p> <p>Nota: Para profundizar en el formato XML que define los Pools de Almacenamiento puedes consultar la documentaci\u00f3n oficial: Storage pool and volume XML format.</p> <p>Sin embargo, vamos a usar otro comando que nos permite indicar la informaci\u00f3n del nuevo pool por medio de par\u00e1metros. Vamos a crear un nuevo pool que vamos a llamar <code>mv-images</code>, de tipo dir y cuyo directorio ser\u00e1 <code>/srv/images</code>. Supongamos que hemos a\u00f1adido m\u00e1s almacenamiento al host y que hemos montado el disco en el directorio <code>/srv/images</code> y queremos guardar las im\u00e1genes de disco en esa nueva localizaci\u00f3n. Para crear el nuevo pool, de forma persistente ejecutamos:</p> <pre><code>virsh -c qemu:///system pool-define-as vm-images dir --target /srv/images\nEl grupo vm-images ha sido definido\n</code></pre> <p>Nota: Si utilizamos <code>pool-create</code> o <code>pool-create-as</code>, el pool se crea temporalmente, no ser\u00e1 persistente y despu\u00e9s de un reinicio del host no existir\u00e1.</p> <p>A continuaci\u00f3n creamos el directorio indicado, con la instrucci\u00f3n:</p> <pre><code>virsh -c qemu:///system pool-build vm-images \nEl pool vm-images ha sido compilado\n</code></pre> <p>Ahora debemos iniciar el pool:</p> <pre><code>virsh -c qemu:///system pool-start vm-images \nSe ha iniciado el grupo vm-images\n</code></pre> <p>Y si lo deseamos lo podemos auto iniciar, para que en el reinicio del host vuelva a estar activo:</p> <pre><code>virsh -c qemu:///system pool-autostart vm-images \nSe ha iniciado el grupo vm-images\n</code></pre> <p>Finalmente vemos la lista de pool y pedimos informaci\u00f3n del nuevo pool:</p> <pre><code>virsh -c qemu:///system pool-list\n Nombre      Estado   Inicio autom\u00e1tico\n-----------------------------------------\n default     activo   si\n iso         activo   si\n vm-images   activo   si\n\nvirsh -c qemu:///system pool-info vm-images \nNombre:         vm-images\nUUID:           a9eb290a-9973-47ea-b616-0907a5df8ea2\nEstado:         ejecutando\nPersistente:    si\nAutoinicio:     si\n...\n</code></pre> <p>Ya podemos usar este pool de almacenamiento para guardar ficheros de im\u00e1genes de disco. Si en alg\u00fan momento queremos eliminarlo, es recomendable pararlo:</p> <pre><code>virsh -c qemu:///system pool-destroy vm-images \nEl grupo vm-images ha sido destruid\n</code></pre> <p>A continuaci\u00f3n, opcionalmente, podemos borrar el directorio creado:</p> <pre><code>virsh -c qemu:///system pool-delete vm-images \nEl grupo vm-images ha sido eliminado\n</code></pre> <p>Y por \u00faltimo lo eliminamos:</p> <pre><code>virsh -c qemu:///system pool-undefine vm-images \nSe ha quitado la definici\u00f3n del grupo vm-images\n</code></pre>"},{"location":"00.-KVM/05.-Almacenamiento/03.-Gesti%C3%B3n%20de%20Pools%20de%20Almacenamiento/#gestion-de-pools-de-almacenamiento-con-virt-manager","title":"Gesti\u00f3n de Pools de Almacenamiento con virt-manager","text":"<p>Desde la pesta\u00f1a Almacenamiento de los Detalles de la conexi\u00f3n podemos ver los pools que tenemos creados y podemos gestionarlos:</p> <p></p> <p>Tenemos las siguientes opciones:</p> <ul> <li>Bot\u00f3n 1: A\u00f1adir un nuevo pool.</li> <li>Bot\u00f3n 2: Iniciar el pool seleccionado.</li> <li>Bot\u00f3n 3: Parar el pool seleccionado.</li> <li>Bot\u00f3n 4: Eliminar el pool seleccionado.</li> </ul> <p>Si creamos un nuevo pool, vemos la siguiente pantalla donde indicamos el nombre, el tipo y en el caso del tipo dir, el directorio:</p> <p></p> <p>Una vez creado, observamos que est\u00e1 iniciado y que tiene marcada como activa la propiedad de autoiniciar:</p> <p></p> <p>Por \u00faltimo, recordar que desde <code>virt-manager</code> podemos ver la definici\u00f3n XML de los recursos con los que trabajamos:</p> <p></p>"},{"location":"00.-KVM/05.-Almacenamiento/04.-Gesti%C3%B3n%20de%20vol%C3%BAmenes%20de%20almacenamiento%20con%20libvirt/","title":"04.-Gesti\u00f3n de vol\u00famenes de almacenamiento con libvirt","text":"<p>En este apartado vamos a estudiar la gesti\u00f3n de vol\u00famenes de almacenamiento usando la API de libvirt, por lo tanto, utilizando herramientas como <code>virsh</code> o <code>virt-manager</code>. </p> <p>Vamos a trabajar con los Pool de Almacenamiento que hemos creado que son de tipo dir, por lo tanto los vol\u00famenes corresponden a ficheros de im\u00e1genes de disco. Para estos ejemplos, utilizaremos el formato de imagen qcow2.</p>"},{"location":"00.-KVM/05.-Almacenamiento/04.-Gesti%C3%B3n%20de%20vol%C3%BAmenes%20de%20almacenamiento%20con%20libvirt/#gestion-de-volumenes-de-almacenamiento-con-virsh","title":"Gesti\u00f3n de vol\u00famenes de almacenamiento con virsh","text":"<p>Para obtener los vol\u00famenes de un determinado pool (por ejemplo el pool <code>default</code>), ejecutamos:</p> <pre><code>virsh -c qemu:///system vol-list default\n Nombre            Ruta\n------------------------------------------------------------\n prueba1.qcow2   /var/lib/libvirt/images/prueba1.qcow2\n prueba2.qcow2   /var/lib/libvirt/images/prueba2.qcow2\n win10.qcow2     /var/lib/libvirt/images/win10.qcow2\n</code></pre> <p>Podemos comprobar que los vol\u00famenes listados se corresponden con ficheros que se encuentran en el directorio del pool <code>default</code> (<code>/var/lib/libvirt/images</code>).</p> <p>Al estar utilizando el formato de imagen <code>qcow2</code>, obtenemos la caracter\u00edstica de aprovisionamiento ligero, el fichero tiene un tama\u00f1o virtual (el que hemos indicado en su creaci\u00f3n y el que ver\u00e1 la m\u00e1quina virtual que lo utilice) y el espacio ocupado en el disco del host (que ir\u00e1 creciendo conforme vayamos guardando informaci\u00f3n en la imagen). Podemos ver esta caracter\u00edstica ejecutando la siguiente instrucci\u00f3n:</p> <pre><code>virsh -c qemu:///system vol-list default --details\n Nombre            Ruta                                      Tipo      Capacidad   Alojamiento\n------------------------------------------------------------------------------------------------\n prueba1.qcow2   /var/lib/libvirt/images/prueba1.qcow2   archivo   10,00 GiB   2,06 GiB\n prueba2.qcow2   /var/lib/libvirt/images/prueba2.qcow2   archivo   20,00 GiB   9,99 GiB\n win10.qcow2     /var/lib/libvirt/images/win10.qcow2     archivo   40,00 GiB   10,06 GiB\n\n</code></pre> <p>Podemos obtener la informaci\u00f3n de un determinado volumen de un pool, ejecutando:</p> <pre><code>virsh -c qemu:///system vol-info prueba1.qcow2 default\nNombre:         prueba1.qcow2\nTipo:           archivo\nCapacidad:      10,00 GiB\nUbicaci\u00f3n:     2,06 GiB\n</code></pre> <p>De la misma forma que los pools, los vol\u00famenes est\u00e1n definidos en libvirt con el formato XML. Para ver la definici\u00f3n XML del volumen <code>vol.qcow2</code> del pool <code>default</code>, podemos ejecutar <code>virsh -c qemu:///system vol-dumpxml vol.qcow2 default</code>. A partir de un fichero XML con la definici\u00f3n de un nuevo volumen, podr\u00edamos crearlo con el comando <code>virsh vol-create</code>. Nota: En este caso no existe el comandos <code>virsh vol-define</code>, ya que los vol\u00famenes no se pueden crear temporalmente.</p> <p>Nota: Para profundizar en el formato XML que define los vol\u00famenes puedes consultar la documentaci\u00f3n oficial: Storage pool and volume XML format.</p> <p>Sin embargo, vamos a usar otro comando que nos permite indicar la informaci\u00f3n del nuevo volumen por medio de par\u00e1metros. Vamos a crear un nuevo volumen en el pool <code>default</code>, cuyo nombre ser\u00e1 <code>vol1.qcow2</code>, formato <code>qcow2</code> y tama\u00f1o de 10GB:</p> <pre><code>virsh -c qemu:///system vol-create-as default vol1.qcow2 --format qcow2 10G \nSe ha creado el volumen vol1.qcow2\n</code></pre> <p>Podemos comprobar que se ha creado un nuevo fichero de imagen:</p> <pre><code>sudo ls -l /var/lib/libvirt/images/\n...\n-rw------- 1 root         root              196768 may 26 09:24 vol1.qcow2\n...\n</code></pre> <p>Tambi\u00e9n podemos volver a ejecutar <code>virsh -c qemu:///system vol-list default</code> para comprobar que se ha creado el volumen.</p> <p>Para borrar un volumen, ejecutamos:</p> <pre><code>virsh -c qemu:///system vol-delete vol1.qcow2 default\nSe ha eliminando el volumen vol1.qcow2\n</code></pre> <p>Tenemos a nuestra disposici\u00f3n m\u00e1s operaciones sobre los vol\u00famenes, estudiaremos algunas de ellas en apartados posteriores: <code>vol-clone</code>: para clonar el volumen, <code>vol-resize</code>: para redimensionar, <code>vol-download</code>: para descargar el volumen en un fichero, <code>vol-upload</code>: para cargar informaci\u00f3n a un volumen desde un fichero,...</p> <p>Nota: Hay que recordar que todas estas operaciones se realizan sobre vol\u00famenes, y por tanto el medio de almacenamiento que gestionan depender\u00e1n del tipo del pool con el que estemos trabajando. De esta forma, un <code>vol-create-as</code> en un pool de tipo logical crear\u00eda un volumen l\u00f3gico LVM.</p>"},{"location":"00.-KVM/05.-Almacenamiento/04.-Gesti%C3%B3n%20de%20vol%C3%BAmenes%20de%20almacenamiento%20con%20libvirt/#gestion-de-volumenes-de-almacenamiento-con-virt-manager","title":"Gesti\u00f3n de vol\u00famenes de almacenamiento con virt-manager","text":"<p>Desde la pesta\u00f1a Almacenamiento de los Detalles de la conexi\u00f3n podemos ver los pools y los vol\u00famenes que tenemos creados y podemos gestionarlos:</p> <p></p> <p>Tenemos las siguientes opciones relacionadas con los vol\u00famenes:</p> <ul> <li>Bot\u00f3n 1: A\u00f1adir un nuevo volumen en el pool seleccionado.</li> <li>Bot\u00f3n 2: Refrescar el pool seleccionado. Actualiza el contenido del pool para incluir los vol\u00famenes que se han creado o modificado con herramientas espec\u00edficas.</li> <li>Bot\u00f3n 3: Eliminar el volumen seleccionado.</li> </ul> <p>Si creamos un nuevo volumen, vemos la siguiente pantalla donde indicamos la siguiente informaci\u00f3n (la informaci\u00f3n solicitada depender\u00e1 del tipo de pool con el que estemos trabajando):</p> <ul> <li>El nombre del volumen.</li> <li>El formato: qcow2 o raw.</li> <li>Backing store: Nos proporciona la caracter\u00edstica de crear vol\u00famenes a partir de un volumen base o imagen base. Lo estudiaremos m\u00e1s adelante en el curso.</li> <li>Capacidad: Indicamos el tama\u00f1o del volumen. Por defecto, si usamos el formato qcow2 obtendremos la caracter\u00edstica de aprovisionamiento ligero, el tama\u00f1o indicado ser\u00e1 el que ve la m\u00e1quina virtual, pero no lo que se ocupa realmente en el disco del host. Si elegimos la opci\u00f3n Allocate entire volume now, se perder\u00e1 esa caracter\u00edstica y se ocupara el disco la capacidad total elegida.</li> </ul> <p></p>"},{"location":"00.-KVM/05.-Almacenamiento/05.-Gesti%C3%B3n%20de%20vol%C3%BAmenes%20de%20almacenamiento%20con%20herramientas%20espec%C3%ADficas/","title":"05.-Gesti\u00f3n de vol\u00famenes de almacenamiento con herramientas espec\u00edficas","text":"<p>En este apartado vamos a gestionar los vol\u00famenes con herramienta especificas. Es decir, si estamos trabajando con un pool de tipo dir y con vol\u00famenes que corresponde a ficheros de im\u00e1genes de disco, vamos a trabajar con la herramienta <code>qemu-img</code>. Esta potente herramienta nos permite la gesti\u00f3n completa de los ficheros de im\u00e1genes de disco.</p>"},{"location":"00.-KVM/05.-Almacenamiento/05.-Gesti%C3%B3n%20de%20vol%C3%BAmenes%20de%20almacenamiento%20con%20herramientas%20espec%C3%ADficas/#gestion-de-imagenes-de-disco-con-qemu-img","title":"Gesti\u00f3n de im\u00e1genes de disco con qemu-img","text":"<p>La herramienta <code>qemu-img</code> es una utilidad para gestionar ficheros de imagen de disco. Puedes profundizar en el uso de esta herramienta consultando la documentaci\u00f3n oficial: QEMU disk image utility.</p> <p>Vamos a crear un nuevo fichero de imagen llamado <code>vol2.qcow2</code>, con el formato <code>qcow2</code>, con un tama\u00f1o de 2GB, en el directorio <code>/srv/images</code>, correspondiente al pool <code>vm-images</code>, que creamos en un apartado anterior (si quisi\u00e9ramos trabajar con el pool <code>default</code> trabajar\u00edamos en el directorio <code>/var/lib/libvirt/images</code>).</p> <pre><code>cd /srv/images/\nqemu-img create -f qcow2 vol2.qcow2 2G\nFormatting 'vol2.qcow2', fmt=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=2147483648 lazy_refcounts=off refcount_bits=16\n\n</code></pre> <p>Podemos obtener informaci\u00f3n de la imagen que hemos creado, ejecutando en el mismo directorio:</p> <pre><code>qemu-img info vol2.qcow2\nimage: vol2.qcow2\nfile format: qcow2\nvirtual size: 2 GiB (2147483648 bytes)\ndisk size: 196 KiB\ncluster_size: 65536\nFormat specific information:\n    compat: 1.1\n    compression type: zlib\n    lazy refcounts: false\n    refcount bits: 16\n    corrupt: false\n    extended l2: false\n</code></pre> <p>La creaci\u00f3n del fichero de imagen, no conlleva de forma autom\u00e1tica la creaci\u00f3n del volumen en el pool de almacenamiento. Si vemos la lista de vol\u00famenes en el pool <code>vm-images</code> comprobamos que no se ha creado:</p> <pre><code>virsh -c qemu:///system vol-list vm-images\n Nombre            Ruta\n------------------------------------------------------------\n</code></pre> <p>Para que se cree un nuevo volumen a partir del fichero que hemos creado, necesitamos refrescar el pool, para ello:</p> <pre><code>virsh -c qemu:///system pool-refresh vm-images\nEl grupo vm-images ha sido actualizado\n</code></pre> <p>Y comprobamos que ya tenemos el volumen creado ejecutando: <code>virsh -c qemu:///system vol-list vm-images</code>.</p> <p>Para refrescar un pool desde <code>virt-manager</code> usamos el siguiente bot\u00f3n:</p> <p></p> <p>La herramienta <code>qemu-img</code> es muy potente y nos permite realizar muchas operaciones: redimensionar el fichero de imagen, convertir entre formatos de im\u00e1genes, crear im\u00e1genes a a partir de im\u00e1genes base, crear instant\u00e1neas de im\u00e1genes, ... Utilizaremos algunas de estas funciones en apartados posteriores del curso.</p> <p>Nota: Si estuvi\u00e9ramos trabajando con otro tipo de Pool de Almacenamiento, tendr\u00e1imos que usar herramientas especificar para gestionar los medios de almacenamientos adecuados. Por ejemplo, si estuvi\u00e9ramos trabajando con un pool de tipo logical, usar\u00edamos las herramientas de comando de LVM para crear y gestionar los vol\u00famenes l\u00f3gicos que se corresponder\u00edan con los vol\u00famenes de este tipo de pool.</p>"},{"location":"00.-KVM/05.-Almacenamiento/06.-Trabajar%20con%20vol%C3%BAmenes%20en%20las%20m%C3%A1quinas%20virtuales/","title":"06.-Trabajar con vol\u00famenes en las m\u00e1quinas virtuales","text":"<p>En la creaci\u00f3n de las m\u00e1quinas virtuales que estudiamos en el m\u00f3dulo anterior, se creaba el volumen que se asociaba a la m\u00e1quina como disco principal.</p> <p>Sin embargo, en este apartado vamos a aprender algunas cosas nuevas: crear nuevas m\u00e1quinas virtuales pero usando vol\u00famenes que hayamos creado anteriormente, a\u00f1adir nuevos discos a las m\u00e1quinas virtuales y redimensioanrlos para aumentar el espacio de almacenamiento.</p>"},{"location":"00.-KVM/05.-Almacenamiento/06.-Trabajar%20con%20vol%C3%BAmenes%20en%20las%20m%C3%A1quinas%20virtuales/#creacion-de-maquinas-virtuales-usando-volumenes-existentes","title":"Creaci\u00f3n de m\u00e1quinas virtuales usando vol\u00famenes existentes","text":"<p>En apartados anterior creamos un volumen de 10 GB llamado <code>vol1.qcow2</code>. Vamos a crear una nueva m\u00e1quina virtual que tenga como disco duro este volumen.</p>"},{"location":"00.-KVM/05.-Almacenamiento/06.-Trabajar%20con%20vol%C3%BAmenes%20en%20las%20m%C3%A1quinas%20virtuales/#con-virt-install","title":"Con <code>virt-install</code>","text":"<p>Si los hacemos con <code>virt-install</code>:</p> <pre><code>virt-install --connect qemu:///system \\\n             --virt-type kvm \\\n             --name prueba4 \\\n             --cdrom ~/iso/debian-11.3.0-amd64-netinst.iso \\\n             --os-variant debian10 \\\n             --disk vol=default/vol1.qcow2 \\\n             --memory 1024 \\\n             --vcpus 1\n\n</code></pre> <p>Hemos utilizado la opci\u00f3n <code>--disk vol=default/vol1.qcow2</code>, indicando el volumen usando el formato <code>pool/volumen</code>. Otras opciones que podr\u00edamos poner ser\u00edan:</p> <ul> <li><code>--disk path=/var/lib/libvirt/images/vol1.qcow2</code>: Donde indicamos directamente la ruta donde se encuentra el fichero de imagen de disco.</li> <li><code>--pool wm-images,size=10</code>: En este caso no se reutiliza el volumen que tenemos creado, sino que se crear\u00eda un nuevo volumen de 10GB en el pool indicado.</li> </ul>"},{"location":"00.-KVM/05.-Almacenamiento/06.-Trabajar%20con%20vol%C3%BAmenes%20en%20las%20m%C3%A1quinas%20virtuales/#con-virt-manager","title":"Con <code>virt-manager</code>","text":"<p>Si utilizamos <code>virt-manager</code>, para crear la nueva m\u00e1quina, durante el asistente de creaci\u00f3n de la m\u00e1quina, elegimos el volumen que tenemos creado:</p> <p></p>"},{"location":"00.-KVM/05.-Almacenamiento/06.-Trabajar%20con%20vol%C3%BAmenes%20en%20las%20m%C3%A1quinas%20virtuales/#anadir-nuevos-discos-a-maquinas-virtuales","title":"A\u00f1adir nuevos discos a m\u00e1quinas virtuales","text":"<p>Para a\u00f1adir un disco a una m\u00e1quina virtual, vamos a modificar su definici\u00f3n XML. Podr\u00edamos usar <code>virsh edit</code> e incluir la definici\u00f3n XML del nuevo disco. Sin embargo, vamos a usar un comando de <code>virsh</code> que nos facilita la operaci\u00f3n de a\u00f1adir un nuevo disco y por tanto, la modificaci\u00f3n de la definici\u00f3n XML de la m\u00e1quina. Hay que indicar que esta modificaci\u00f3n se puede hacer \"en caliente\", con la m\u00e1quina funcionando.</p> <p>Por lo tanto, vamos a\u00f1adir el volumen <code>vol2.qcow2</code> que creamos en el apartado anterior, a la m\u00e1quina que hemos creado en estado de ejecuci\u00f3n, ejecutamos:</p> <pre><code>virsh -c qemu:///system attach-disk prueba4 /srv/images/vol2.qcow2 vdb --driver=qemu --type disk --subdriver qcow2 --persistent\nEl disco ha sido asociado exitosamente\n</code></pre> <p>Indicamos el nombre de la m\u00e1quina, el path del fichero de imagen, el dispositivo de bloque que se va a crear, indicamos el driver, el tipo que ser\u00e1 un disco, y el formato de la imagen que se va a a\u00f1adir. Por \u00faltimo, con la opci\u00f3n <code>--persistent</code> hacemos el cambio de forma persistente, para que en el pr\u00f3ximo reinicio de la m\u00e1quina se vuelva a a\u00f1adir el disco.</p> <p>Tambi\u00e9n lo podemos hacer desde <code>virt-manager</code>. Si a\u00f1adimos nuevo hardware en la vista detalle de la m\u00e1quina, podemos a\u00f1adir nuevo almacenamiento:</p> <p></p> <p>Como hemos comentado la m\u00e1quina <code>prueba4</code> est\u00e1 en ejecuci\u00f3n y podemos comprobar que se ha a\u00f1adido el disco:</p> <p></p> <p>Y podr\u00edamos formatear, montar y usar el nuevo disco:</p> <p></p> <p>Para desconectar un disco de una m\u00e1quina virtual podemos ejecutar:</p> <pre><code>virsh -c qemu:///system detach-disk prueba4 vdb --persistent\nEl disco ha sido desmontado exitosamente\n</code></pre> <p>Indicando la m\u00e1quina virtual, el dispositivo que se hab\u00eda creado y la opci\u00f3n para que sea un cambio persistente.</p> <p>Desde <code>virt-manager</code> simplemente pulsar\u00edamos con el bot\u00f3n derecho sobre el dispositivo de disco en la vista detalle, y pulsar\u00edamos sobre Eliminar Hardware.</p>"},{"location":"00.-KVM/05.-Almacenamiento/06.-Trabajar%20con%20vol%C3%BAmenes%20en%20las%20m%C3%A1quinas%20virtuales/#redimension-de-discos-en-maquinas-virtuales","title":"Redimensi\u00f3n de discos en m\u00e1quinas virtuales","text":"<p>Antes de desconectar el disco de la m\u00e1quina, vamos a realizar una operaci\u00f3n de redimensi\u00f3n. Vamos a aumentar el tama\u00f1o del volumen, por lo que la m\u00e1quina ver\u00e1 un disco m\u00e1s grande, pero hay que recordar que tambi\u00e9n tendremos que redimensionar el sistemas de ficheros.</p> <p>Para realizar la redimensi\u00f3n tenemos dos alternativas: o usar la API de libvirt usando, por ejemplo <code>virsh</code> o usar herramientas especificas, en este caso <code>qemu-img</code>.</p> <p>Para redimensionar el volumen de una m\u00e1quina que este parada, podemos usar <code>virsh</code>:</p> <pre><code>virsh -c qemu:///system vol-resize vol2.qcow2 3G --pool vm-images\nEl tama\u00f1o de volumen 'vol2.qcow2' se ha cambiado correctamente a 3G\n</code></pre> <p>O podemos usar <code>qemu-img</code>, se ejecuta con un usuario con privilegios o con <code>sudo</code>:</p> <pre><code>sudo qemu-img resize /srv/images/vol2.qcow2 3G\nImage resized.\n</code></pre> <p>Para hacer la redimensi\u00f3n \"en caliente\", con la m\u00e1quina encendida, podemos obtener informaci\u00f3n de los discos conectados a una m\u00e1quina:</p> <pre><code>virsh -c qemu:///system domblklist prueba4 \n Destino   Fuente\n-----------------------------------------------\n vda       /var/lib/libvirt/images/vol1.qcow2\n vdb       /srv/images/vol2.qcow2\n</code></pre> <p>Y continuaci\u00f3n redimensionamos el disco deseado:</p> <pre><code>virsh -c qemu:///system blockresize prueba4 /srv/images/vol2.qcow2 3G\nEl dispositivo de bloque '/srv/images/vol2.qcow2' cambi\u00f3 de tama\u00f1o\n</code></pre> <p>Podemos comprobar que se ha producido la redimensi\u00f3n en el disco de la m\u00e1quina:</p> <p></p> <ol> <li>El disco ahora tiene 3GB.</li> <li>Pero el sistema de archivo sigue teneido 2Gb. </li> <li>Desmontamos el disco, y lo redimensionamos con <code>resize2fs</code>.</li> <li>Volvemos a montarlo y comprobamos que ahora ya tiene los 3Gb.</li> </ol>"},{"location":"00.-KVM/05.-Almacenamiento/06.-Trabajar%20con%20vol%C3%BAmenes%20en%20las%20m%C3%A1quinas%20virtuales/#redimension-del-sistema-de-ficheros-de-una-imagen-de-disco","title":"Redimensi\u00f3n del sistema de ficheros de una imagen de disco","text":"<p>Otra alternativa para redimensionar el sistema de fichero de una imagen es usar la herramienta virt-resize. <code>virt-resize</code> no trabaja sobre im\u00e1genes de discos de m\u00e1quinas que se est\u00e9n ejecutando, adem\u00e1s no puede redimensionar sobre el mismo fichero de la imagen, por lo que vamos a hacer una copia del mismo.</p> <p>Si tenemos un fichero qcow2 que se llama <code>vol1.qcow</code>, podemos redimensionar el disco y su sistema de ficheros con al siguientes instrucciones:</p> <pre><code>qemu-img resize vol1.qcow2 10G\ncp vol1.qcow2 newvol1.qcow2\nvirt-resize --expand /dev/sda1 vol1.qcow2 newvol1.qcow2\nmv newvol1.qcow2 vol1.qcow2\n</code></pre> <p>Resimensionamos el disco, como vimos en el apartado anterior. Como hemos indicado <code>virt-resize</code> no trabaja sobre un fichero qcow2 directamente, es por ello que lo hemos copiado a otro fichero y hemos ejecutado el comando. Finalmente el fichero <code>nwevol1.qcow2</code> tendr\u00e1 un sistema de ficheros de 10Gb, por lo que terminamos copi\u00e1ndolo de nuevo (con el <code>mv</code>) sobre el disco original.</p>"},{"location":"00.-KVM/05.-Almacenamiento/07.-Compresi%C3%B3n%20de%20im%C3%A1genes/","title":"07.-Compresi\u00f3n de im\u00e1genes","text":""},{"location":"00.-KVM/05.-Almacenamiento/07.-Compresi%C3%B3n%20de%20im%C3%A1genes/#que-es-virt-sparsify","title":"\u00bfQu\u00e9 es <code>virt-sparsify</code>?","text":"<p><code>virt-sparsify</code> es una herramienta de la suite de virtualizaci\u00f3n <code>libguestfs</code> en Linux que se utiliza para reducir el tama\u00f1o de las im\u00e1genes de disco virtual, como las im\u00e1genes en formato QCOW2 o RAW. Esto se hace eliminando los bloques vac\u00edos o no utilizados en el disco, optimizando as\u00ed el espacio que ocupa la imagen en almacenamiento.</p>"},{"location":"00.-KVM/05.-Almacenamiento/07.-Compresi%C3%B3n%20de%20im%C3%A1genes/#por-que-usar-virt-sparsify","title":"\u00bfPor qu\u00e9 usar <code>virt-sparsify</code>?","text":"<p>En entornos de virtualizaci\u00f3n, las im\u00e1genes de disco pueden contener bloques vac\u00edos debido a archivos eliminados o a la expansi\u00f3n del sistema de archivos. Estos bloques vac\u00edos ocupan espacio en el almacenamiento f\u00edsico. <code>virt-sparsify</code> permite optimizar las im\u00e1genes eliminando estos bloques y creando una imagen \"esparcida\" que ocupa menos espacio en disco.</p>"},{"location":"00.-KVM/05.-Almacenamiento/07.-Compresi%C3%B3n%20de%20im%C3%A1genes/#uso-basico","title":"Uso B\u00e1sico","text":"<p>La sintaxis b\u00e1sica del comando <code>virt-sparsify</code> es:</p> <pre><code>virt-sparsify &lt;imagen-entrada&gt; &lt;imagen-salida&gt;\n</code></pre> <ul> <li><code>&lt;imagen-entrada&gt;</code>: La imagen original del disco virtual.</li> <li><code>&lt;imagen-salida&gt;</code>: La imagen optimizada (se recomienda especificar una nueva imagen para evitar sobrescribir la original).</li> </ul>"},{"location":"00.-KVM/05.-Almacenamiento/07.-Compresi%C3%B3n%20de%20im%C3%A1genes/#ejemplo-basico","title":"Ejemplo B\u00e1sico","text":"<pre><code>virt-sparsify disk.qcow2 disk-sparse.qcow2\n</code></pre> <p>En este ejemplo, <code>virt-sparsify</code> toma <code>disk.qcow2</code> como imagen de entrada y crea una nueva imagen optimizada llamada <code>disk-sparse.qcow2</code> que ocupa menos espacio.</p>"},{"location":"00.-KVM/05.-Almacenamiento/07.-Compresi%C3%B3n%20de%20im%C3%A1genes/#opciones-utiles","title":"Opciones \u00datiles","text":"<ol> <li><code>--compress</code></li> <li>Comprime la imagen de salida. Esto es \u00fatil si deseas reducir a\u00fan m\u00e1s el tama\u00f1o del archivo.</li> </ol> <p><code>bash    virt-sparsify --compress disk.qcow2 disk-sparse.qcow2</code></p> <ol> <li><code>--check-tmpdir</code></li> <li>Permite especificar un directorio temporal (en lugar del predeterminado <code>/tmp</code>). Esto es \u00fatil si no tienes suficiente espacio en <code>/tmp</code>.</li> </ol> <p><code>bash    virt-sparsify --tmp /ruta/a/tmpdir disk.qcow2 disk-sparse.qcow2</code></p> <ol> <li><code>--in-place</code></li> <li>Realiza la optimizaci\u00f3n en la misma imagen sin crear una nueva imagen de salida. Nota: Usar esta opci\u00f3n puede ser riesgoso, ya que modifica la imagen original.</li> </ol> <p><code>bash    virt-sparsify --in-place disk.qcow2</code></p> <ol> <li><code>--format</code></li> <li>Especifica el formato de la imagen de salida, \u00fatil si <code>virt-sparsify</code> no detecta correctamente el formato.</li> </ol> <p><code>bash    virt-sparsify --format qcow2 disk.qcow2 disk-sparse.qcow2</code></p>"},{"location":"00.-KVM/05.-Almacenamiento/07.-Compresi%C3%B3n%20de%20im%C3%A1genes/#consideraciones-importantes","title":"Consideraciones Importantes","text":"<ul> <li> <p>Requisitos de Espacio Temporal: <code>virt-sparsify</code> necesita espacio adicional para procesar el archivo. Si tu sistema carece de suficiente espacio en <code>/tmp</code>, usa la opci\u00f3n <code>--check-tmpdir</code> para especificar otra ubicaci\u00f3n.</p> </li> <li> <p>Soporte de Formato: Este comando funciona con muchos formatos de disco virtual, como QCOW2, RAW, VMDK, entre otros. Sin embargo, revisa la compatibilidad con tu sistema de virtualizaci\u00f3n.</p> </li> <li> <p>Acceso de Root: Para utilizar <code>virt-sparsify</code>, generalmente necesitas permisos de administrador.</p> </li> </ul>"},{"location":"00.-KVM/05.-Almacenamiento/07.-Compresi%C3%B3n%20de%20im%C3%A1genes/#ejemplo-completo-de-uso","title":"Ejemplo Completo de Uso","text":"<p>Imaginemos que tienes una imagen de disco <code>vm-disk.qcow2</code> que quieres optimizar:</p> <pre><code>virt-sparsify --compress --format qcow2 vm-disk.qcow2 vm-disk-sparse.qcow2\n</code></pre> <p>Este comando crear\u00e1 una imagen optimizada y comprimida en formato QCOW2, que deber\u00eda ocupar menos espacio en disco.</p>"},{"location":"00.-KVM/05.-Almacenamiento/07.-Compresi%C3%B3n%20de%20im%C3%A1genes/#resumen","title":"Resumen","text":"<ul> <li>virt-sparsify es ideal para reducir el tama\u00f1o de las im\u00e1genes de disco eliminando bloques vac\u00edos.</li> <li>Se recomienda hacer una copia de la imagen de entrada y usar una imagen de salida separada.</li> <li>Usa opciones como <code>--compress</code> para reducir a\u00fan m\u00e1s el tama\u00f1o o <code>--in-place</code> para realizar cambios directamente en la imagen.</li> </ul> <p>Este comando es \u00fatil para liberar espacio en el almacenamiento sin afectar el contenido o la funcionalidad de la imagen de disco virtual.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/","title":"Index","text":"<p>En KVM/QEMU, la clonaci\u00f3n y los snapshots son herramientas esenciales para la administraci\u00f3n de m\u00e1quinas virtuales.</p> <ul> <li>Clonaci\u00f3n: Consiste en crear una copia exacta de una m\u00e1quina virtual (VM). Esta copia incluye tanto el estado del disco como la configuraci\u00f3n de la VM. Es \u00fatil para crear entornos de prueba, replicar configuraciones en nuevos servidores, o desplegar r\u00e1pidamente varias instancias de una misma VM.</li> <li>Snapshots: Son capturas del estado de una VM en un momento espec\u00edfico. Un snapshot guarda el estado del sistema, la memoria y los discos, permitiendo revertir a ese punto en caso de ser necesario. Esto es ideal para realizar cambios o actualizaciones en una VM sin arriesgarse a perder el estado actual.</li> </ul> <p>Ambas herramientas facilitan la gesti\u00f3n y recuperaci\u00f3n de m\u00e1quinas virtuales en entornos de virtualizaci\u00f3n KVM/QEMU, mejorando la eficiencia y la seguridad en la administraci\u00f3n de sistemas.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/01.-Clonaci%C3%B3n%20de%20m%C3%A1quinas%20virtuales/","title":"01.-Clonaci\u00f3n de m\u00e1quinas virtuales","text":"<p>La clonaci\u00f3n de una m\u00e1quina virtual copia la configuraci\u00f3n XML de la m\u00e1quina de origen y sus im\u00e1genes de disco, y realiza ajustes en las configuraciones para asegurar la unicidad de la nueva m\u00e1quina. Esto incluye cambiar el nombre de la m\u00e1quina y asegurarse de que utiliza los clones de las im\u00e1genes de disco. No obstante, los datos almacenados en los discos virtuales del clon son id\u00e9nticos a los de la m\u00e1quina de origen. </p> <p>La clonaci\u00f3n nos permite crear nuevas m\u00e1quinas de forma muy sencilla, sin necesidad de pasar por el proceso de instalaci\u00f3n desde una imagen ISO.</p> <p>Para realizar la clonaci\u00f3n vamos a partir de una m\u00e1quina virtual que est\u00e9 apagada.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/01.-Clonaci%C3%B3n%20de%20m%C3%A1quinas%20virtuales/#uso-virt-clone-para-realizar-la-clonacion","title":"Uso virt-clone para realizar la clonaci\u00f3n","text":"<p>Vamos a usar la aplicaci\u00f3n <code>virt-clone</code> para realizar la clonaci\u00f3n. Puedes profundizar en el uso de esta herramienta consultando la documentaci\u00f3n oficial: virt-clone. Veamos algunos casos de uso:</p> <pre><code>$ virt-clone --connect=qemu:///system --original prueba4 --auto-clone\nAsignando 'vol1-clone.qcow2'                               |  10 GB  00:15     \n\nEl clon 'prueba4-clone' ha sido creado exitosamente.\n</code></pre> <p>Es la forma m\u00e1s sencilla de crear una nueva m\u00e1quina. El par\u00e1metro <code>--auto-clone</code> asigna autom\u00e1ticamente:</p> <ul> <li>Un nuevo nombre para la m\u00e1quina virtual clonada si no se especifica uno.</li> <li>Nuevas direcciones MAC para las interfaces de red para evitar conflictos en la red.</li> <li>Una nueva ruta del disco para el almacenamiento del clon, evitando sobrescribir el disco existente.</li> </ul> <p>Si queremos indicar el nombre de la nueva m\u00e1quina: usamos el par\u00e1metro <code>--name</code> y si queremos indicar el nombre del nuevo volumen usamos <code>--file</code>:</p> <pre><code>virt-clone --connect=qemu:///system --original prueba4 --name prueba5 --file /var/lib/libvirt/images/vol_prueba5.qcow2 --auto-clone\n</code></pre>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/01.-Clonaci%C3%B3n%20de%20m%C3%A1quinas%20virtuales/#uso-de-virt-manager-para-realizar-la-clonacion","title":"Uso de virt-manager para realizar la clonaci\u00f3n","text":"<p>Si elegimos una m\u00e1quina virtual y pulsamos el bot\u00f3n derecho del rat\u00f3n tenemos a nuestra disposici\u00f3n la opci\u00f3n Clonar:</p> <p></p> <p>Donde podemos indicar el nombre de la nueva m\u00e1quina virtual, y si pulsamos sobre el bot\u00f3n Details... podemos cambiar el nombre del nuevo fichero de imagen donde se realiza la clonaci\u00f3n.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/01.-Clonaci%C3%B3n%20de%20m%C3%A1quinas%20virtuales/#las-maquinas-virtuales-clonadas-son-iguales-a-las-originales","title":"Las m\u00e1quinas virtuales clonadas son iguales a las originales","text":"<p>La m\u00e1quina clon que hemos creado es igual a la original. La nueva m\u00e1quina contiene identificadores que deber\u00edan ser \u00fanicos (como el machine ID, direcciones MAC, claves SSH de host, hostname, ...).</p> <p></p> <p>Podemos acceder a la m\u00e1quina y cambiar el fichero <code>/etc/hostname</code> para cambiar el nombre de la m\u00e1quina, pero todav\u00eda tendr\u00edamos mucha informaci\u00f3n repetida entre las dos m\u00e1quinas. </p> <p>Por lo tanto no vamos a realizar la clonaci\u00f3n de esta manera. En el siguiente apartado vamos a aprender a crear plantillas de m\u00e1quinas virtuales que nos permiten realizar la clonaci\u00f3n de forma adecuada.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/02.-Plantillas%20de%20MV/","title":"02.-Plantillas de MV","text":"<p>Una plantilla de m\u00e1quina virtual, o simplemente plantilla es una imagen preconfigurada de un sistema operativo que puede utilizarse para desplegar r\u00e1pidamente m\u00e1quinas virtuales. El uso de plantillas permite evitar muchas tareas repetitivas de instalaci\u00f3n y configuraci\u00f3n. El resultado es la creaci\u00f3n de m\u00e1quinas virtuales totalmente instaladas y listas para funcionar en menos tiempo de lo que tardar\u00eda una instalaci\u00f3n manual.</p> <p>Con la herramienta <code>virt-clone</code> hemos creado un clon de una m\u00e1quina virtual, es decir, una copia de una m\u00e1quina. Una plantilla es una copia maestra que podemos utilizar para crear muchos clones.</p> <p>Una vez tengamos una plantilla, tendremos dos manera de crear las nuevas m\u00e1quinas:</p> <ul> <li>Clonaci\u00f3n completa (Full): Creamos una copia completa de la m\u00e1quina virtual que es totalmente independiente de la plantilla. Requiere el mismo espacio en disco que el original.</li> <li>Clonaci\u00f3n enlazada (Linked): Utiliza la imagen de la plantilla como imagen base en modo de s\u00f3lo lectura y vincula una imagen adicional de \"copia en escritura\" para almacenar los nuevos datos generados. Requiere menos espacio en disco, pero no puede ejecutarse sin acceso a la imagen de plantilla base.</li> </ul>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/02.-Plantillas%20de%20MV/#creacion-de-plantillas","title":"Creaci\u00f3n de plantillas","text":"<p>Tendr\u00edamos que realizar tres pasos fundamentales:</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/02.-Plantillas%20de%20MV/#1-crear-e-instalar","title":"1. Crear e instalar","text":"<p>Hemos de crear una nueva m\u00e1quina virtual e instalarle todo el software necesario. A partir de esa m\u00e1quina vamos a crear la plantilla.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/02.-Plantillas%20de%20MV/#2generalizar-la-imagen","title":"2.Generalizar la imagen","text":"<p>Vamos a eliminar toda la informaci\u00f3n que deber\u00eda ser \u00fanica en una m\u00e1quina ya que contiene identificadores que deber\u00edan ser \u00fanicos (como el ID de la m\u00e1quina, direcciones MAC, claves SSH de host, hostname, ...). De tal forma, que las m\u00e1quinas clonadas, regenerar\u00e1n esta informaci\u00f3n de forma \u00fanica al iniciarlas.</p> <p>En m\u00e1quinas Linux vamos a usar la utilidad <code>virt-sysprep</code>; para m\u00e1quinas Windows podemos usar los mecanismos propios de generalizaci\u00f3n que posee: sysprep. Para poder utilizar <code>virt-sysprep</code> tenemos que instalar el siguiente paquete:</p> <pre><code>    $ apt-get install libguestfs-tools\n</code></pre> <p>En distribuciones basadas en Arch puede que el paquete se encuentre en <code>guestfs-tools</code>.</p> <pre><code>    $ pacman -S guestfs-tools\n</code></pre> <p><code>virt-sysprep</code> puede trabajar con un fichero de imagen, usando la opci\u00f3n <code>-a</code>, pero en nuestro caso vamos indicarle una m\u00e1quina virtual, usando el par\u00e1metro <code>-d</code>.</p> <p>Vamos a suponer que vamos a convertir en plantilla nuestra m\u00e1quina <code>VM</code> que tiene un sistema GNU/Linux Ubuntu Server instalado. Nuestra m\u00e1quina original tiene que estar parada. Y para generalizarla, ejecutamos como superusuario:</p> <pre><code>\n    $ sudo virt-sysprep -d VM --hostname TplUbuntuServer\n\n    [   0.0] Examining the guest ...\n    ...\n</code></pre> <p>En <code>virt-sysprep</code> tienes muchas opciones de configuraci\u00f3n, hemos usado el par\u00e1metro <code>-hostname</code> para cambiar el nombre de la m\u00e1quina de la plantilla.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/02.-Plantillas%20de%20MV/#3-configurar-maquina-de-solo-lectura","title":"3. Configurar m\u00e1quina de s\u00f3lo lectura","text":"<p>En \u00faltimo lugar, tenemos que evitar ejecutar esta m\u00e1quina de nuevo, ya que la generalizaci\u00f3n que hemos hecho se perder\u00eda. Para conseguirlo vamos a configurar la imagen original de solo lectura, de esta manera al intentar ejecutar la plantilla nos dar\u00e1 un error. Para ello, como superusuario ejecutamos:</p> <pre><code>    /var/lib/libvirt/images# sudo chmod -w VM.qcow2 \n</code></pre> <p>Adem\u00e1s, vamos a cambiar el nombre a la m\u00e1quina para recordar que es un plantilla:</p> <pre><code>$ virsh -c qemu:///system domrename VM TplUbuntuServer\nDomain successfully renamed\n</code></pre> <p>Este cambio tambi\u00e9n se podr\u00eda hacer con <code>virt-manager</code>.</p> <p>Si intentamos ejecutar la plantilla, nos dar\u00e1 un error: </p> <p>En cualquier momento podemos cambiar la configuraci\u00f3n de la plantilla. Todas las nuevas m\u00e1quinas clonadas a partir de ella tendr\u00e1n la misma configuraci\u00f3n.</p> <p>Ya tenemos la plantilla lista para ser clonada. Lo veremos en los siguientes apartados.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/03.-Clonaci%C3%B3n%20completa%20con%20plantillas/","title":"03.-Clonaci\u00f3n completa con plantillas","text":"<p>La clonaci\u00f3n completa a partir de una plantilla es similar a la clonaci\u00f3n de m\u00e1quinas virtuales que vimos en un punto anterior.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/03.-Clonaci%C3%B3n%20completa%20con%20plantillas/#uso-virt-clone-para-realizar-la-clonacion","title":"Uso virt-clone para realizar la clonaci\u00f3n","text":"<p>Podemos usar el siguiente comando para realizar la clonaci\u00f3n:</p> <pre><code>virt-clone --connect=qemu:///system --original TplUbuntuServer --name VM --auto-clone --file VM.qcow2\n</code></pre> <p>Recuerda que puedes usar el par\u00e1metro <code>--file</code> para indicar el nombre de la imagen de la nueva m\u00e1quina que clonamos.</p> <p>El proceso puede ser lento, ya que se hace una copia completa de la imagen original a la de la nueva m\u00e1quina virtual.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/03.-Clonaci%C3%B3n%20completa%20con%20plantillas/#uso-de-virt-manager-para-realizar-la-clonacion","title":"Uso de virt-manager para realizar la clonaci\u00f3n","text":"<p>Si elegimos la plantilla y pulsamos el bot\u00f3n derecho del rat\u00f3n tenemos a nuestra disposici\u00f3n la opci\u00f3n Clonar:</p> <p></p> <p>Donde podemos indicar el nombre de la nueva m\u00e1quina virtual, y si pulsamos sobre el bot\u00f3n Details... podemos cambiar el nombre del nuevo fichero de imagen donde se realiza la clonaci\u00f3n.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/03.-Clonaci%C3%B3n%20completa%20con%20plantillas/#problemas-de-acceso-por-ssh","title":"Problemas de acceso por SSH","text":"<p>Si intentamos acceder por SSH a la nueva m\u00e1quina vamos a comprobar que no nos lo permite. Para realizar la conexi\u00f3n por SSH vamos a averiguar la IP de la m\u00e1quina, para ello podemos ejecutar:</p> <pre><code>virsh -c qemu:///system domifaddr clone1\n Nombre     direcci\u00f3n MAC       Protocol     Address\n-------------------------------------------------------------------------------\n vnet0      52:54:00:6d:b5:da    ipv4         192.168.122.253/24\n</code></pre> <p>O usando <code>virt-manager</code> vemos el detalle de la interfaz de red:</p> <p></p> <p>Si desde el host intentamos acceder por SSH, obtenemos:</p> <pre><code>ssh usuario@192.168.122.253\nssh: connect to host 192.168.122.253 port 22: Connection refuse\n</code></pre> <p>Esto es debido a que cuando ejecutamos el <code>virt-sysprep</code> uno de los datos que se eliminaron fueron las claves SSH de la m\u00e1quina para que no fueran los mismos que los de la m\u00e1quina original. Por lo tanto tenemos que regenerar estas claves en la nueva m\u00e1quina ejecutando el comando <code>ssh-keygen -A</code>, y de paso le vamos a cambiar el <code>hostname</code>:</p> <p></p> <p>Una reiniciada la m\u00e1quina ya podemos acceder por SSH desde el host:</p> <pre><code>ssh usuario@192.168.122.253\n...\n\nusuario@clone1:~$ \n</code></pre>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/04.-Clonaci%C3%B3n%20enlazada%20con%20plantillas/","title":"04.-Clonaci\u00f3n enlazada con plantillas","text":"<p>En este tipo de clonaci\u00f3n la imagen de la m\u00e1quina clonada utiliza la imagen de la plantilla como imagen base (backing store) en modo de s\u00f3lo lectura, en la imagen de la nueva m\u00e1quina s\u00f3lo se guardan los cambios del sistema de archivo. Requiere menos espacio en disco, pero no puede ejecutarse sin acceso a la imagen de plantilla base. </p> <p>El mecanismo es un poco m\u00e1s complejo, tenemos que realziar dos pasos:</p> <ol> <li>Creaci\u00f3n del nuevo volumen a a partir de la imagen base de la plantilla (backing store).</li> <li>Creaci\u00f3n de la nueva m\u00e1quina usando <code>virt-install</code>, <code>virt-manager</code> o <code>virt-clone</code>.</li> </ol>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/04.-Clonaci%C3%B3n%20enlazada%20con%20plantillas/#creacion-de-imagenes-de-disco-con-backing-store","title":"Creaci\u00f3n de im\u00e1genes de disco con backing store","text":"<p>Para no complicar la creaci\u00f3n de vol\u00famenes con backing store vamos a indicar el tama\u00f1o del nuevo volumen igual al de la imagen base. Como la imagen base ya tiene guardado un sistema de archivos con un tama\u00f1o determinado, el hecho de que creemos una nueva imagen con m\u00e1s tama\u00f1o no conlleva el redimensionado del sistema de archivo. Este cambio de tama\u00f1o se podr\u00eda realizar, pero con operaciones un poco m\u00e1s complejas.</p> <p>Para asegurarnos de crear un volumen del mismo tama\u00f1o que la imagen base vamos comprobar su tama\u00f1o:</p> <pre><code>\nvirsh -c qemu:///system domblkinfo plantilla-prueba1 vda --human\nCapacidad:      10,000 GiB\n...\n</code></pre> <p>Tambi\u00e9n lo podemos ver con <code>virt-manager</code>:</p> <p></p> <p>Para crear la nueva imagen basada en la imagen base de la plantilla, podemos crear el volumen con <code>virsh</code>:</p> <pre><code>virsh -c qemu:///system vol-create-as default clone2.qcow2 10G --format qcow2 --backing-vol prueba1.qcow2 --backing-vol-format qcow2\n</code></pre> <p>O podemos usar la aplicaci\u00f3n <code>qemu-img</code> y posterior refrescamos el pool <code>default</code>:</p> <pre><code>cd /var/lib/libvirt/images\nsudo qemu-img create -f qcow2 -b prueba1.qcow2 -F qcow2 clone2.qcow2 10G\nvirsh -c qemu:///system pool-refresh default\n</code></pre> <p>Otra opci\u00f3n es usando <code>virt-manager</code>, creando un nuevo volumen e indicando durante la direcci\u00f3n el volumen base:</p> <p></p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/04.-Clonaci%C3%B3n%20enlazada%20con%20plantillas/#informacion-sobre-imagenes-de-con-disco-con-backing-store","title":"Informaci\u00f3n sobre im\u00e1genes de con disco con backing store","text":"<p>Para comprobar que un volumen est\u00e1 creado con una imagen base podemos usar <code>virsh</code>:</p> <pre><code>virsh -c qemu:///system vol-dumpxml clone2.qcow2 default\n...\n&lt;backingStore&gt;\n    &lt;path&gt;/var/lib/libvirt/images/prueba1.qcow2&lt;/path&gt;\n    &lt;format type='qcow2'/&gt;\n    &lt;permissions&gt;\n    ...\n</code></pre> <p>O usando el comando <code>qemu-img</code>:</p> <pre><code>sudo qemu-img info /var/lib/libvirt/images/clone2.qcow2\n...\nbacking file: prueba1.qcow2\nbacking file format: qcow2\n...\n</code></pre>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/04.-Clonaci%C3%B3n%20enlazada%20con%20plantillas/#creacion-de-la-nueva-maquina-a-partir-de-la-imagen-con-backing-store-con-virt-install","title":"Creaci\u00f3n de la nueva m\u00e1quina a partir de la imagen con backing store con virt-install","text":"<p>En este caso podemos usar la herramienta <code>virt-install</code> pero sin indicar el medio de instalaci\u00f3n.</p> <pre><code>virt-install --connect qemu:///system \\\n             --virt-type kvm \\\n             --name nueva_prueba \\\n             --os-variant debian10 \\\n             --disk path=/var/lib/libvirt/images/prueba6.qcow2 \\\n             --memory 1024 \\\n             --vcpus 1 \\\n             --import\n</code></pre> <p>Usamos la opci\u00f3n <code>--import</code> para que no te pida que indique el medio de instalaci\u00f3n, simplemente va a usar el volumen indicado como disco de la m\u00e1quina virtual.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/04.-Clonaci%C3%B3n%20enlazada%20con%20plantillas/#creacion-de-la-nueva-maquina-a-partir-de-la-imagen-con-backing-store-con-virt-manager","title":"Creaci\u00f3n de la nueva m\u00e1quina a partir de la imagen con backing store con virt-manager","text":"<p>Si utilizamos <code>virt-manager</code>, para crear la nueva m\u00e1quina, durante el asistente de creaci\u00f3n de la m\u00e1quina, elegimos la opci\u00f3n Manual install, ya que no vamos a usar una imagen ISO:</p> <p></p> <p>Y posteriormente, escogemos el volumen que tenemos creado:</p> <p></p> <p>Otra forma, ser\u00eda escogiendo la opci\u00f3n Importar imagen de disco existente en la creaci\u00f3n de la m\u00e1quina:</p> <p></p> <p>Y eligiendo el volumen en siguiente paso:</p> <p></p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/04.-Clonaci%C3%B3n%20enlazada%20con%20plantillas/#creacion-de-la-nueva-maquina-a-partir-de-la-imagen-con-backing-store-con-virt-clone","title":"Creaci\u00f3n de la nueva m\u00e1quina a partir de la imagen con backing store con virt-clone","text":"<p>Una vez que tenemos creado el volumen basada en el imagen base de la plantilla, podemos crear un nuevo clon con <code>virt-clone</code>, para ello ejecutamos:</p> <pre><code>virt-clone --connect=qemu:///system --original plantilla-prueba1 --name clone2 --file /var/lib/libvirt/images/clone2.qcow2 --preserve-data\n</code></pre> <p>Indicamos como fichero el volumen que hemos creado, pero con la opci\u00f3n <code>--preserve-data</code> no se copia el volumen original al nuevo, simplemente se usa. Se puede comprobar que la clonaci\u00f3n no tarda nada de tiempo, no se est\u00e1 copiando un volumen en otro.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/05.-Snapshots%20de%20MV/","title":"05.-Snapshots de MV","text":"<p>Un snapshot (instant\u00e1nea) nos posibilita guardar el estado de una m\u00e1quina virtual en un determinado momento. Se guarda el estado del disco y el estado de la memoria. De esta forma en el futuro puedo volver a un estado anterior de la misma. No todos los formatos y medios de almacenamiento nos posibilitan esta caracter\u00edsticas. Un fichero de imagen de disco con formato <code>qcow2</code> si nos permite la realizaci\u00f3n de instant\u00e1neas.</p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/05.-Snapshots%20de%20MV/#gestion-de-instantaneas-con-virsh","title":"Gesti\u00f3n de instant\u00e1neas con virsh","text":"<p>Vamos a trabajar con la m\u00e1quina <code>prueba2</code> donde tenemos una instalaci\u00f3n de Ubuntu 22.04. </p> <p>Hemos hecho un cambio significativo en nuestra m\u00e1quina (en el ejemplo hemos creado una carpeta). </p> <p></p> <p>Ahora es el momento de crear una instant\u00e1nea, de esta manera podremos volver a este estado en un momento futuro:</p> <pre><code>virsh -c qemu:///system snapshot-create-as prueba2 --name instant\u00e1nea1 --description \"Creada carpeta importante\" --atomic\nHa sido creada la captura instant\u00e1nea instant\u00e1nea1 del dominio\n</code></pre> <p>Se recomienda utilizar la opci\u00f3n <code>--atomic</code> para evitar cualquier corrupci\u00f3n mientras se toma la instant\u00e1nea. Para ver las instant\u00e1neas que tiene creada la m\u00e1quina podemos ejecutar:</p> <pre><code>virsh -c qemu:///system snapshot-list prueba2\n  Nombre         Hora de creaci\u00f3n            Estado\n -----------------------------------------------------\n  instant\u00e1nea1   2022-05-28 18:13:46 +0200   running\n</code></pre> <p>Tambi\u00e9n podemos ver las instant\u00e1neas de un fichero de imagen con la herramienta <code>qemu-img</code> (la m\u00e1quina debe estar parada):</p> <pre><code>sudo qemu-img info /var/lib/libvirt/images/prueba2.qcow2\nimage: /var/lib/libvirt/images/prueba2.qcow2\nfile format: qcow2\nvirtual size: 20 GiB (21474836480 bytes)\ndisk size: 11.9 GiB\ncluster_size: 65536\nSnapshot list:\nID        TAG               VM SIZE                DATE     VM CLOCK     ICOUNT\n1         instant\u00e1nea1     1.79 GiB 2022-05-28 18:13:46 00:16:12.485    \n...\n</code></pre> <p>Los snapshot son otro recurso de libvirt cuya definici\u00f3n se guarda en formato XML. Podr\u00edamos usar el comando <code>snapshot-dumpxml</code> para ver su definici\u00f3n. Tenemos m\u00e1s comandos relacionados con las instant\u00e1neas: para obtener informaci\u00f3n de una instant\u00e1nea usamos <code>snapshot-info</code>, <code>snapshot-delete</code> para borrar una instant\u00e1nea ,... </p> <p>Si hemos tenido un problema en nuestra m\u00e1quina y hemos eliminado nuestra carpeta importante:</p> <p></p> <p>Podemos volver al estado de una determinada instant\u00e1nea ejecutando:</p> <pre><code>virsh -c qemu:///system snapshot-revert prueba2 instant\u00e1nea1\n</code></pre> <p>Y comprobamos que hemos vuelto al estado de la m\u00e1quina donde ten\u00edamos creada la carpeta:</p> <p></p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/05.-Snapshots%20de%20MV/#gestion-de-instantaneas-con-virt-manager","title":"Gesti\u00f3n de instant\u00e1neas con virt-manager","text":"<p>Accediendo a la Vista Instant\u00e1neas obtenemos la ventana para gestionar las instant\u00e1neas:</p> <p></p> <p>Tenemos botones para las opci\u00f3n m\u00e1s comunes:</p> <ul> <li>Bot\u00f3n 1: Crear instant\u00e1nea.</li> <li>Bot\u00f3n 2: Volver al estado de la instant\u00e1nea seleccionada.</li> <li>Bot\u00f3n 3: Refrescar la lista de instant\u00e1neas.</li> <li>Bot\u00f3n 4: Borrar la instant\u00e1nea seleccionada.</li> </ul> <p>Al crear una instant\u00e1nea, podemos indicar el nombre, la descripci\u00f3n y se guarda una captura de pantalla de la m\u00e1quina.</p> <p></p>"},{"location":"00.-KVM/06.-Clonaci%C3%B3n%20y%20Snapshots/05.-Snapshots%20de%20MV/#conclusion","title":"Conclusi\u00f3n","text":"<p>Puede ser muy interesante tomar instant\u00e1neas peri\u00f3dicamente a una m\u00e1quina virtual. Si tenemos cualquier problema con la m\u00e1quina podemos volver a un estado estable anterior. Esta caracter\u00edstica puede ser muy \u00fatil, ya que nos permite experimentar con la m\u00e1quina, y si tenemos alg\u00fan problema, podemos volver al estado original y no tener que eliminar la m\u00e1quina.</p>"},{"location":"00.-KVM/07.-Redes/01.-Introduccion/","title":"01.-Introduccion","text":"<p>libvirt nos proporciona las herramientas necesarias para gestionar las redes virtuales a las que se conectan nuestras m\u00e1quinas virtuales.</p> <p>Tenemos dos grandes grupos de redes que podemos configurar:</p> <ul> <li>Redes Virtuales (Privadas): Son redes privadas que podemos configurar para que tengan distintas caracter\u00edsticas.</li> <li>Redes Puente (P\u00fablicas): Las podemos considerar como redes p\u00fablicas, desde el punto de vista que las m\u00e1quinas virtuales estar\u00e1n conectadas a la misma red a la que est\u00e1 conectada el host.</li> </ul> <p>Recordemos un puente o bridge/switch es un dispositivo de interconexi\u00f3n de redes. La gesti\u00f3n de redes de libvirt se basa en el concepto de switch virtual, para ello utiliza Linux Bridge, que es un software que nos permite crear bridge virtuales con la misma funcionalidad que un bridge f\u00edsico.</p>"},{"location":"00.-KVM/07.-Redes/01.-Introduccion/#tipos-de-redes-virtuales-privadas","title":"Tipos de Redes Virtuales (Privadas)","text":"<p>La clasificaci\u00f3n depender\u00e1 de la configuraci\u00f3n que hagamos a la Red Virtual:</p>"},{"location":"00.-KVM/07.-Redes/01.-Introduccion/#redes-virtuales-de-tipo-nat","title":"Redes Virtuales de tipo NAT","text":"<p>Es un Red Virtual Privada, las m\u00e1quinas virtual tendr\u00e1n un direccionamiento privado y se nos proporciona un mecanismo de router/nat para que tengan conectividad al exterior.</p> <p></p> <p>La red <code>default</code> con la que hemos trabajado es de este tipo. Veamos sus caracter\u00edsticas:</p> <ul> <li>Crea un bridge virtual donde se conectan las m\u00e1quinas virtuales. En el caso de la red <code>default</code> se llama <code>vmbr0</code>. A este bridge tambi\u00e9n est\u00e1 conectado el host.</li> <li>Las m\u00e1quinas virtuales se configuraran de forma din\u00e1mica por medio de un servidor DHCP. En el caso de la red <code>default</code>, el rango de direcciones es <code>192.168.122.2</code> - <code>192.168.122.254</code>. La puerta de enlace de las m\u00e1quinas se configura con la direcci\u00f3n IP <code>192.168.122.1</code> que corresponde al host. El servidor DHCP esta configurado en el host. </li> <li>En el host tambi\u00e9n se configura un servidor DNS que es el que se configura en las m\u00e1quinas virtuales.</li> <li> <p>El host hace la funci\u00f3n de router/nat de tal manera que las m\u00e1quinas virtuales tienen conectividad al exterior, usando la direcci\u00f3n IP de la interfaz de red del host que est\u00e1 conectada al exterior.</p> <p>Existen otros mecanismos para que las m\u00e1quinas virtuales tengan acceso al exterior:</p> <ul> <li>Modo bridge: Donde se usan rutas de encaminamiento en el host. En este modo hay que configurar con rutas est\u00e1ticas los elementos de enrutamiento de la red local para que funcione de manera adecuada.</li> <li>Modo abierto: Similar a la anterior, excepto que no se a\u00f1aden reglas de firewall para asegurar que cualquier tr\u00e1fico pase o no. Se asume que, o bien no son necesarias, o bien se configuran fuera del \u00e1mbito de libvirt.</li> </ul> <p>En este curso vamos a trabajar con Redes Virtuales de tipo NAT.</p> </li> </ul>"},{"location":"00.-KVM/07.-Redes/01.-Introduccion/#redes-virtuales-aisladas-isolated","title":"Redes Virtuales aisladas (Isolated)","text":"<p>Es un Red Virtual Privada, donde las m\u00e1quinas virtuales tomas direccionamiento privado. No tenemos un mecanismo de router/nat, por lo que las m\u00e1quinas virtuales no tienen conectividad con el exterior. </p> <p></p> <p>Por lo tanto tienen las mismas caracter\u00edsticas que una Red Virtual de tipo NAT, pero sin la caracter\u00edstica de router/nat. Se gestiona un bridge virtual donde se conectan las m\u00e1quinas virtuales y el host, seguimos teniendo un servidor DNS y es posible tener un servidor DHCP en el host que asigna din\u00e1micamente un direccionamiento privado a las m\u00e1quinas.</p>"},{"location":"00.-KVM/07.-Redes/01.-Introduccion/#redes-virtuales-muy-aisladas-very-isolated","title":"Redes Virtuales muy aisladas (Very Isolated)","text":"<p>Es un Red Virtual Aislada, en la que el host no est\u00e1 conectado a las m\u00e1quians virtuales. Por lo tanto,no tenemos servidor DNS ni DHCP para ser utilizados por las m\u00e1quinas. Al ser aislada, tampoco tienen salida al exterior.</p> <p></p> <p>En este tipo de red se suele configurar la red de las m\u00e1quinas virtuales de forma est\u00e1tica.</p>"},{"location":"00.-KVM/07.-Redes/01.-Introduccion/#tipos-de-redes-puente-publicas","title":"Tipos de Redes Puente (P\u00fablicas)","text":"<p>La clasificaci\u00f3n depende de la forma utilizada para conectar las m\u00e1quinas virtuales al exterior.</p>"},{"location":"00.-KVM/07.-Redes/01.-Introduccion/#redes-puente-conectadas-a-un-bridge-externo","title":"Redes Puente conectadas a un bridge externo","text":"<p>En este caso necesitamos crear un bridge virtual (normalmente llamado <code>br0</code>) al que conectaremos la m\u00e1quina f\u00edsica y las m\u00e1quinas virtuales. En este caso las m\u00e1quinas virtuales estar\u00e1n en la misma red red que el host y estar\u00e1n conectadas directamente al router de esta red, tomando la configuraci\u00f3n dhcp (si la hubiera) del mismo modo que la toma el host.</p> <p></p>"},{"location":"00.-KVM/07.-Redes/01.-Introduccion/#redes-puente-compartiendo-la-interfaz-fisica-del-host","title":"Redes Puente compartiendo la interfaz f\u00edsica del host","text":"<p>En este caso vamos a usar una conexi\u00f3n macvtap, que nos permite conectarnos a la red f\u00edsica directamente a trav\u00e9s de una interfaz f\u00edsica del host (sin usar un dispositivo bridge). Al igual que con la red anterior, las m\u00e1quinas virtuales estar\u00e1n conectados directamente a la red f\u00edsica, por lo que sus direcciones IP estar\u00e1n todas en la subred de la red f\u00edsica. Existe una una limitaci\u00f3n en la implementaci\u00f3n de macvtap: estas conexiones no permiten la comunicaci\u00f3n directa entre el host y los invitados.</p> <p></p>"},{"location":"00.-KVM/07.-Redes/02.-Definic%C3%B3n%20de%20RV%20%28Privadas%29/","title":"02.-Definic\u00f3n de RV (Privadas)","text":"<p>Las redes que gestiona libvirt se definen con el formato XML. Puedes profundizar en el formato XML con los que se definen las redes consultando el documento Network XML format. </p>"},{"location":"00.-KVM/07.-Redes/02.-Definic%C3%B3n%20de%20RV%20%28Privadas%29/#definicion-de-redes-virtuales-de-tipo-nat","title":"Definici\u00f3n de Redes Virtuales de tipo NAT","text":"<p>La red <code>default</code> con la que hemos trabajado es de este tipo. La configuraci\u00f3n de la red <code>default</code> la podemos encontrar en el fichero <code>/usr/share/libvirt/networks/default.xml</code>:</p> <pre><code>&lt;network&gt;\n  &lt;name&gt;default&lt;/name&gt;\n  &lt;bridge name='virbr0'/&gt;\n  &lt;forward/&gt;\n  &lt;ip address='192.168.122.1' netmask='255.255.255.0'&gt;\n    &lt;dhcp&gt;\n      &lt;range start='192.168.122.2' end='192.168.122.254'/&gt;\n    &lt;/dhcp&gt;\n  &lt;/ip&gt;\n&lt;/network&gt;\n</code></pre> <p>Veamos las etiquetas:</p> <ul> <li><code>&lt;name&gt;</code>: Nombre de la red.</li> <li><code>&lt;bridge&gt;</code>: Indicamos el nombre del bridge virtual que se va a utilizar.</li> <li><code>&lt;forward&gt;</code>: Indica que las m\u00e1quinas virtuales van a tener conectividad con el exterior. Por defecto, si no se indicada nada, el tipo es nat: <code>&lt;forward mode=\"nat\"/&gt;</code>. El modo tambi\u00e9n puede ser:<ul> <li><code>router</code>: Las redes tipo router tambi\u00e9n dan acceso a las m\u00e1quinas virtuales al exterior, pero en ese caso no se utiliza el mecanismo de NAT, sino que se usan rutas de encaminamiento en el host.</li> <li><code>open</code>: Similar a la anterior, excepto que no se a\u00f1aden reglas de firewall para asegurar que cualquier tr\u00e1fico pase o no. </li> </ul> </li> <li><code>&lt;ip&gt;</code>: Donde se indica la direcci\u00f3n IP y la mascara de red de la direcci\u00f3n del host en la red. Es decir, el host est\u00e1 conectado al bridge virtual con esa direcci\u00f3n.<ul> <li><code>&lt;dhcp&gt;</code>: Este elemento es optativo. Si queremos tener un servidor DHCP configurado en el host lo configuramos en esta etiqueta, por ejemplo poniendo el rango en la etiqueta <code>&lt;range&gt;</code>. </li> </ul> </li> </ul>"},{"location":"00.-KVM/07.-Redes/02.-Definic%C3%B3n%20de%20RV%20%28Privadas%29/#definicion-de-redes-virtuales-aisladas","title":"Definici\u00f3n de Redes Virtuales Aisladas","text":"<p>La definici\u00f3n de una Red Virtual Aislada es igual a la de tipo NAT, pero quitando la etiqueta <code>&lt;forward&gt;</code> para deshabilitar la caracter\u00edstica de que el host haga router/nat. La definici\u00f3n podr\u00eda quedar de este modo:</p> <pre><code>&lt;network&gt;\n  &lt;name&gt;red_aislada&lt;/name&gt;\n  &lt;bridge name='virbr1'/&gt;\n  &lt;ip address='192.168.123.1' netmask='255.255.255.0'&gt;\n    &lt;dhcp&gt;\n      &lt;range start='192.168.123.2' end='192.168.123.254'/&gt;\n    &lt;/dhcp&gt;\n  &lt;/ip&gt;\n&lt;/network&gt;\n</code></pre>"},{"location":"00.-KVM/07.-Redes/02.-Definic%C3%B3n%20de%20RV%20%28Privadas%29/#definicion-de-redes-virtuales-muy-aisladas","title":"Definici\u00f3n de Redes Virtuales muy Aisladas","text":"<p>Son similares a la anterior, pero el host no se conecta a la red. Por lo tanto no tenemos ni servidor DNS, ni DHCP. Al crear este tipo de red, simplemente se creara un bridge virtual donde se conectar\u00e1n las m\u00e1quinas virtuales, que se configurar\u00e1n de forma est\u00e1tica su direccionamiento. Por lo tanto la definici\u00f3n ser\u00e1:</p> <pre><code>&lt;network&gt;\n  &lt;name&gt;red_muy_aislada&lt;/name&gt;\n  &lt;bridge name='virbr2'/&gt;\n&lt;/network&gt;\n</code></pre>"},{"location":"00.-KVM/07.-Redes/03.-Gesti%C3%B3n%20de%20RV/","title":"03.-Gesti\u00f3n de RV","text":"<p>En este apartado vamos  a estudiar como trabajar con las redes virtuales con <code>virsh</code> y <code>virt-manager</code>.</p>"},{"location":"00.-KVM/07.-Redes/03.-Gesti%C3%B3n%20de%20RV/#gestion-de-redes-virtuales-con-virsh","title":"Gesti\u00f3n de Redes Virtuales con virsh","text":"<p>Podemos ver las redes que tenemos definidas ejecutando:</p> <pre><code>virsh -c qemu:///system net-list --all\n Nombre    Estado   Inicio autom\u00e1tico   Persistente\n-----------------------------------------------------\n default   activo   si                  si\n</code></pre> <p>Utilizamos la opci\u00f3n <code>--all</code> para listar las redes iniciadas y paradas.</p> <p>Las redes se crean a partir de su definici\u00f3n XML que tenemos guardado en un fichero. En este caso tenemos el fichero <code>red-nat.xml</code>, donde tenemos la definici\u00f3n de una red virtual de tipo NAT, con el siguiente contenido:</p> <pre><code>&lt;network&gt;\n  &lt;name&gt;red_nat&lt;/name&gt;\n  &lt;bridge name='virbr1'/&gt;\n  &lt;forward/&gt;\n  &lt;ip address='192.168.123.1' netmask='255.255.255.0'&gt;\n    &lt;dhcp&gt;\n      &lt;range start='192.168.123.2' end='192.168.123.254'/&gt;\n    &lt;/dhcp&gt;\n  &lt;/ip&gt;\n&lt;/network&gt;\n</code></pre> <p>Para crear la nueva red, ejecutamos:</p> <pre><code>virsh -c qemu:///system net-define red-nat.xml\nLa red red_nat se encuentra definida desde red-nat.xml\n</code></pre> <p>Si utilizamos el comando <code>virsh create</code> estar\u00edamos creando la red de forma temporal, no persistente.</p> <p>La red no se puede utilizar hasta que no se inicie, para ello:</p> <pre><code>virsh -c qemu:///system net-start red_nat\nLa red red_nat se ha iniciado\n</code></pre> <p>Si vamos a usar esta red con mucha frecuencia es recomendable activar la propiedad de autoiniciar para que se inicie de forma autom\u00e1tica al iniciar el host. Para ello:</p> <pre><code>virsh -c qemu:///system net-autostart red_nat\nLa red red_nat ha sido marcada para iniciarse autom\u00e1ticamente\n</code></pre> <p>Podemos obtener informaci\u00f3n de la red ejecutando:</p> <pre><code>virsh -c qemu:///system net-info red_nat\nNombre:         red_nat\nUUID:           af756f61-9ffd-44d0-850f-90a75db773c1\nActivar:        si\nPersistente:    si\nAutoinicio:     si\nPuente:         virbr1\n</code></pre> <p>Al iniciar podemos comprobar que se ha creado el bridge virtual y una nueva interfaz de red en el host.</p> <pre><code>sudo brctl show\nbridge name bridge id       STP enabled interfaces\nvirbr0      8000.525400aea33d   yes     \nvirbr1      8000.5254002daec2   yes \n</code></pre> <p>En el host, el bridge virtual aparece como una interfaz de red:</p> <pre><code>ip a\n...\n4: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000\n    link/ether 52:54:00:ae:a3:3d brd ff:ff:ff:ff:ff:ff\n    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0\n       valid_lft forever preferred_lft forever\n5: virbr1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000\n    link/ether 52:54:00:2d:ae:c2 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.123.1/24 brd 192.168.123.255 scope global virbr1\n       valid_lft forever preferred_lft forever\n</code></pre> <p>Podemos considerar que la interfaz de red del bridge virtual corresponde a la conexi\u00f3n del host con el bridge.</p> <p>Para ver la definici\u00f3n XML de la red que hemos creado, ejecutamos:</p> <pre><code>virsh -c qemu:///system net-dumpxml red_nat\n</code></pre> <p>Podemos crear tambi\u00e9n una red muy aislada de la que tenemos guardada la definici\u00f3n XML en el fichero <code>red-muy-aislada.xml</code>, con el contenido:</p> <pre><code>&lt;network&gt;\n  &lt;name&gt;red_muy_aislada&lt;/name&gt;\n  &lt;bridge name='virbr2'/&gt;\n&lt;/network&gt;\n</code></pre> <p>Y si la creamos y la iniciamos:</p> <pre><code>virsh -c qemu:///system net-define red-muy-aislada.xml\nLa red red_muy_aislada se encuentra definida desde red-muy-aislada.xml\n\nvirsh -c qemu:///system net-start red_muy_aislada\nLa red red_muy_aislada se ha iniciado\n</code></pre> <p>Comprobamos que se ha creado el bridge virtual. </p> <pre><code>sudo brctl show\nbridge name bridge id       STP enabled interfaces\nvirbr0      8000.525400aea33d   yes     \nvirbr1      8000.5254002daec2   yes     \nvirbr2      8000.525400d51f31   yes\n</code></pre> <p>Pero al ser una red muy aislada, el host no est\u00e1 conectado al bridge, y por lo tanto no tiene direcci\u00f3n IP asignada:</p> <pre><code>ip a\n...\n6: virbr2: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000\n    link/ether 52:54:00:d5:1f:31 brd ff:ff:ff:ff:ff:\n</code></pre> <p>Finalmente indicar que para parar una red utilizamos el comando <code>virsh net-stop</code> y para eliminarla el comando <code>virsh undefined</code>.</p>"},{"location":"00.-KVM/07.-Redes/03.-Gesti%C3%B3n%20de%20RV/#gestion-de-redes-virtuales-con-virt-manager","title":"Gesti\u00f3n de Redes Virtuales con virt-manager","text":"<p>Desde la pesta\u00f1a Redes virtuales de los Detalles de la conexi\u00f3n podemos ver las redes que tenemos creadas y podemos gestionarlas:</p> <p></p> <p>Tenemos las siguientes opciones:</p> <ul> <li>Bot\u00f3n 1: A\u00f1adir una nueva red.</li> <li>Bot\u00f3n 2: Iniciar la red seleccionada.</li> <li>Bot\u00f3n 3: Parar la red seleccionada.</li> <li>Bot\u00f3n 4: Eliminar la red seleccionada.</li> </ul> <p>Si creamos una red, indicamos un nombre, el tipo y la configuraci\u00f3n. Por ejemplo, vamos a crear una red de tipo aislada con servidor DHCP:</p> <p></p> <p>Una vez creado, observamos que est\u00e1 iniciado y que tiene marcada como activa la propiedad de autoiniciar. Adem\u00e1s observamos que el nombre del bridge lo ah asignado de forma autom\u00e1tica:</p> <p></p> <p>Por \u00faltimo, recordar que desde <code>virt-manager</code> podemos ver la definici\u00f3n XML de los recursos con los que trabajamos:</p> <p></p>"},{"location":"00.-KVM/07.-Redes/04.-Creaci%C3%B3n%20de%20un%20Puerte%20Externo%20con%20Linux%20Bridge/","title":"04.-Creaci\u00f3n de un Puerte Externo con Linux Bridge","text":"<p>Un bridge externo es un bridge virtual que estar\u00e1 conectado al router de la red local. El bridge se crear\u00e1 en el servidor donde estamos virtualizando (host). El host estar\u00e1 conectado a este bridge para tener conectividad al exterior. Veamos un esquema:</p> <p></p> <ul> <li>El bridge que vamos a crear lo vamos a llamar <code>br0</code>.</li> <li>En el host aparecer\u00e1 una interfaz de red con el mismo nombre que representa la conexi\u00f3n al bridge. Est\u00e1 interfaz de red se configurar\u00e1 de forma est\u00e1tica o din\u00e1mica (si la red local tiene un servidor DHCP).</li> <li>En el ejemplo vemos que la interfaz f\u00edsica de red es <code>eth0</code> que estar\u00e1 conectada a <code>br0</code> para que el host tenga conectividad al exterior. Esa interfaz de red no tendr\u00e1 asignada direcci\u00f3n IP.</li> <li>Posteriormente veremos como podemos conectar las m\u00e1quinas virtuales a este bridge de tal manera que tomaran direcciones IP en el mismo direccionamiento que el host.</li> </ul> <p>Nota: Si conectamos al bridge una interfaz de tipo wifi podemos tener problemas de conectividad. No todas las tarjetas inal\u00e1mbricas permiten la conexi\u00f3n a puentes virtuales.</p> <p>Nos aseguremos que tenemos instalado el siguiente paquete que nos permite trabajar con Linux Bridge:</p> <pre><code>apt install bridge-utils\n</code></pre>"},{"location":"00.-KVM/07.-Redes/04.-Creaci%C3%B3n%20de%20un%20Puerte%20Externo%20con%20Linux%20Bridge/#creacion-de-un-bridge-externo-con-networkmanager","title":"Creaci\u00f3n de un bridge externo con NetworkManager","text":"<p>NetworkManager es una utilidad de gr\u00e1fica para simplificar el uso de redes en sistemas Linux. Normalmente la tenemos instaladas con sistemas Linux con entornos gr\u00e1ficos como Gnome. Junto a esa utilidad tenemos otra que se puede ejecutar con el comando <code>nm-connection-editor</code>, y que se llama Configuraci\u00f3n avanzada de redes:</p> <p></p> <p>Si lo ejecutamos accedemos a la siguiente pantalla:</p> <p></p> <p>Donde vemos la conexi\u00f3n de red cableada (o de wifi) que tenemos y los bridge virtuales que se han creado cuando hemos estado trabajando con las redes en libvirt. Pulsando el bot\u00f3n +, podemos de alta nueva conexi\u00f3n. A\u00f1adiremos una conexi\u00f3n de tipo Puente:</p> <p></p> <p>Y podemos indicar el nombre de la conexi\u00f3n, el nombre del puente que estamos creando, y a continuaci\u00f3n vamos a a\u00f1adirle una conexi\u00f3n al bridge que ser\u00e1 la interfaz de red f\u00edsica del host que est\u00e1 actualmente conectada al exterior.</p> <p></p> <p>A\u00f1adimos un conexi\u00f3n Cableada que ser\u00e1 la interfaz f\u00edsica del host (en mi caso <code>enp1s0</code>):</p> <p></p> <p></p> <p>Finalmente borramos la conexi\u00f3n cableada que tenemos actualmente:</p> <p></p> <p>Y en unos segundos, se conectar\u00e1 de forma autom\u00e1tica a la conexi\u00f3n Puente Externo:</p> <p> </p> <p>Comprobamos la configuraci\u00f3n de red del host:</p> <pre><code>$ ip a\n2: enp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast master br0 state UP group default qlen 1000\n    link/ether 52:54:00:22:d7:3f brd ff:ff:ff:ff:ff:ff\n...\n7: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether 92:d8:69:79:60:69 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.121.168/24 brd 192.168.121.255 scope global dynamic noprefixroute br0\n       valid_lft 3459sec preferred_lft 3459sec\n...\n</code></pre> <p>Comprobamos que la interfaz f\u00edsica <code>enp1s0</code> no tiene direcci\u00f3n IP, ya que est\u00e1 conectada al bridge. La interfaz de red <code>br0</code> representa la conexi\u00f3n del bridge que ha tomado una ip del servidor DHCP de la red local (esta direcci\u00f3n IP ser\u00e1 diferente a la que ten\u00eda anteriormente la interfaz f\u00edsica).</p> <p>Si tenemos instalado el paquete <code>bridge-utils</code> podremos ver los puentes virtuales y las interfaces que tienen conectadas, ejecutando como superusuario:</p> <pre><code>brctl show\nbridge name bridge id       STP enabled interfaces\nbr0     8000.92d869796069   yes     enp1s0\nvirbr0      8000.525400aea33d   yes     \nvirbr1      8000.5254002daec2   yes     \nvirbr3      8000.52540052838e   yes\n</code></pre>"},{"location":"00.-KVM/07.-Redes/04.-Creaci%C3%B3n%20de%20un%20Puerte%20Externo%20con%20Linux%20Bridge/#creacion-de-un-bridge-externo-en-debian","title":"Creaci\u00f3n de un bridge externo en Debian","text":"<p>Si estamos trabajando en un servidor con Linux Debian instalado y no tenemos instalado NetworkManager, la configuraci\u00f3n se har\u00e1 directamente en el fichero de configuraci\u00f3n de red <code>/etc/network/intefaces</code>:</p> <pre><code>auto lo\niface lo inet loopback\n\nauto enp1s0\niface enp1s0 inet manual\n\nauto br0\niface br0 inet dhcp\n        bridge-ports enp1s0\n</code></pre> <p>Donde vemos como hemos configurado la interfaz f\u00edsica <code>enp1s0</code> de tipo <code>manual</code> para que no tome direccionamiento. Adem\u00e1s hemos declarado nuestro puente <code>br0</code> para que tome direccionamiento de forma din\u00e1mica y hemos indicado que tendr\u00e1 una interfaz conectada (<code>bridge-ports</code>) que ser\u00e1 la f\u00edsica (<code>enp1s0</code>).</p> <p>Finalmente, reiniciamos la red como superusuario:</p> <pre><code>ifdown enp1s0\nsystemctl restart networking.service\n</code></pre> <p>Y comprobamos:</p> <pre><code>ip a\n...\n2: enp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast master br0 state UP group default qlen 1000\n    link/ether 52:54:00:22:d7:3f brd ff:ff:ff:ff:ff:ff\n3: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether 92:d8:69:79:60:69 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.121.169/24 brd 192.168.121.255 scope global dynamic br0\n       valid_lft 3595sec preferred_lft 3595sec\n</code></pre> <p>Podemos comprobar los puentes que tenemos creados y las interfaces que est\u00e1n conectados a \u00e9l, ejecutando la siguiente instrucci\u00f3n:</p> <pre><code>brctl show\nbridge name bridge id       STP enabled interfaces\nbr0     8000.7eb448933f70   no      enp1s0\n</code></pre>"},{"location":"00.-KVM/07.-Redes/04.-Creaci%C3%B3n%20de%20un%20Puerte%20Externo%20con%20Linux%20Bridge/#creacion-de-un-bridge-externo-en-ubuntu","title":"Creaci\u00f3n de un bridge externo en Ubuntu","text":"<p>En Ubuntu vamos a configurar el fichero <code>/etc/netplan/01-network-manager-all.yaml</code> de la siguiente forma:</p> <pre><code># Let NetworkManager manage all devices on this system\nnetwork:\n  version: 2\n  renderer: networkd\n  ethernets:\n    enp1s0:\n      dhcp4: no\n  bridges:\n    br0:\n      dhcp4: yes\n      interfaces:\n             - enp1s0\n</code></pre> <p>Y reiniciamos la red ejecutando:</p> <pre><code>sudo netplan apply\n</code></pre>"},{"location":"00.-KVM/07.-Redes/05.-Gesti%C3%B3n%20de%20Redes%20Puentes%20%28P%C3%BAblicas%29/","title":"05.-Gesti\u00f3n de Redes Puentes (P\u00fablicas)","text":"<p>En este apartado vamos  a estudiar como trabajar con las redes puentes.</p>"},{"location":"00.-KVM/07.-Redes/05.-Gesti%C3%B3n%20de%20Redes%20Puentes%20%28P%C3%BAblicas%29/#gestion-de-redes-puentes-conectadas-a-un-bridge-externo-con-virsh","title":"Gesti\u00f3n de Redes Puentes conectadas a un bridge externo con virsh","text":"<p>Partimos de que en el host tenemos creado un bridge virtual (que se suele llamar <code>br0</code>) al que est\u00e1 conectado el host. Las m\u00e1quinas virtuales se conectar\u00e1n en ese bridge y tomar\u00e1n configuraci\u00f3n de red de la misma red a la que est\u00e1 conectada el host. La definici\u00f3n quedar\u00eda de la siguiente manera.</p> <p>La configuraci\u00f3n la tenemos en el fichero <code>red-bridge.xml</code>, con el contenido:</p> <pre><code>&lt;network&gt;\n  &lt;name&gt;red_bridge&lt;/name&gt;\n  &lt;forward mode=\"bridge\"/&gt;\n  &lt;bridge name=\"br0\"/&gt;\n&lt;/network&gt;\n</code></pre> <ul> <li>El modo de forward se indica como <code>bridge</code>.</li> <li>Y en la etiqueta <code>bridge</code> se pone el nombre del bridge virtual que estamos usando.</li> </ul> <p>Para crear esta nueva red, ejecutamos:</p> <pre><code>virsh -c qemu:///system net-define red-bridge.xml \nLa red red_bridge se encuentra definida desde red-bridge.xml\n</code></pre> <p>La iniciamos:</p> <pre><code>virsh -c qemu:///system net-start red_bridge\nLa red red_bridge se ha iniciado\n</code></pre> <p>Y podemos ver que se ha creado:</p> <pre><code>virsh -c qemu:///system net-list --all\n Nombre            Estado     Inicio autom\u00e1tico   Persistente\n---------------------------------------------------------------\n default           activo     si                  si\n red_aislada       activo     si                  si\n red_bridge        inactivo   no                  si\n red_muy_aislada   inactivo   no                  si\n red_nat           activo     si                  si\n</code></pre> <p>Desde <code>virt-manager</code> no podemos crear una red de este tipo. De todas formas veremos que podemos conectar una m\u00e1quina virtual directamente al bridge <code>br0</code> con lo que ser\u00e1 lo mismo que usar la red.</p>"},{"location":"00.-KVM/07.-Redes/05.-Gesti%C3%B3n%20de%20Redes%20Puentes%20%28P%C3%BAblicas%29/#redes-puente-compartiendo-la-interfaz-fisica-del-host","title":"Redes Puente compartiendo la interfaz f\u00edsica del host","text":"<p>En este caso vamos a usar una conexi\u00f3n macvtap, que nos permite conectarnos a la red f\u00edsica directamente a trav\u00e9s de una interfaz f\u00edsica del host (sin usar un dispositivo bridge). Al igual que con la red anterior, las m\u00e1quinas virtuales estar\u00e1n conectados directamente a la red f\u00edsica, por lo que sus direcciones IP estar\u00e1n todas en la subred de la red f\u00edsica.  La definici\u00f3n de este tipo de red le hemos guardado en el fichero <code>red-interface.xml</code> y ser\u00eda la siguiente:</p> <pre><code>&lt;network&gt;\n  &lt;name&gt;red_interface&lt;/name&gt;\n  &lt;forward mode=\"bridge\"&gt;\n    &lt;interface dev=\"enp1s0\"/&gt;\n  &lt;/forward&gt;\n&lt;/network&gt;\n</code></pre> <p>Es similar a la anterior, pero se utiliza la etiqueta <code>&lt;interface&gt;</code> para indicar el nombre de la interfaz de red f\u00edsica que vamos a utilizar.</p> <p>Para utilizar este tipo de red, la interfaz que utilicemos no puede estar conectado a un puente virtual.</p>"},{"location":"00.-KVM/07.-Redes/06.-Configuraci%C3%B3n%20de%20red%20en%20MV/","title":"06.-Configuraci\u00f3n de red en MV","text":"<p>Todas las m\u00e1quinas que hemos creado durante el curso se han conectado de forma predeterminada a la red <code>default</code>. </p> <p>Sin embargo, en este apartado vamos a aprender algunas cosas nuevas: a crear m\u00e1quinas virtuales conectadas a otras redes definidas por el usuario y a a\u00f1adir interfaces de red a m\u00e1quinas virtuales ya existentes.</p>"},{"location":"00.-KVM/07.-Redes/06.-Configuraci%C3%B3n%20de%20red%20en%20MV/#crear-maquinas-virtuales-conectada-a-una-red-existente","title":"Crear m\u00e1quinas virtuales conectada a una red existente","text":"<p>Para crear una m\u00e1quina virtual conectada, por ejemplo, a la red <code>red_nat</code>, podemos usar <code>virt-install</code>:</p> <pre><code>virt-install --connect qemu:///system \\\n             --virt-type kvm \\\n             --name prueba5 \\\n             --cdrom ~/iso/debian-11.3.0-amd64-netinst.iso \\\n             --os-variant debian10 \\\n             --network network=red_nat \\\n             --disk size=10 \\\n             --memory 1024 \\\n             --vcpus 1\n</code></pre> <ul> <li>Con la opci\u00f3n <code>--network network=red_nat</code> indicamos que la m\u00e1quina tendr\u00e1 una interfaz de red conectada a la red cuyo nombre es <code>red_nat</code>.</li> <li>Para conectar una m\u00e1quina a una red tambi\u00e9n podemos indicar el bridge virtual al que queremos conectarla. en este caso utilizar\u00edamos la opci\u00f3n <code>--network bridge=virbr1</code>. <code>vribr1</code> es el bridge virtual que gestiona la red <code>red_nat</code>.</li> <li>Si indicamos varios par\u00e1metros <code>--network</code>, estar\u00edamos a\u00f1adiendo a la nueva m\u00e1quina varias interfaces de red.</li> </ul> <p>Si utilizamos <code>virt-manager</code>, para crear la nueva m\u00e1quina, durante el asistente de creaci\u00f3n de la m\u00e1quina, el el \u00faltimo paso, podemos escoger la red a la que nos vamos a conectar:</p> <p></p> <p>Tambi\u00e9n podemos escoger el puente virtual al que nos queremos conectar:</p> <p></p>"},{"location":"00.-KVM/07.-Redes/06.-Configuraci%C3%B3n%20de%20red%20en%20MV/#anadir-nuevas-interfaces-de-red-a-maquinas-virtuales","title":"A\u00f1adir nuevas interfaces de red a m\u00e1quinas virtuales","text":"<p>Para a\u00f1adir una nueva interfaz de red a una m\u00e1quina virtual, vamos a modificar su definici\u00f3n XML. Podr\u00edamos usar <code>virsh edit</code> e incluir la definici\u00f3n XML de la nueva interfaz. Sin embargo, vamos a usar un comando de <code>virsh</code> que nos facilita la operaci\u00f3n de a\u00f1adir una nueva interfaz de red y por tanto, la modificaci\u00f3n de la definici\u00f3n XML de la m\u00e1quina. Es recomendable hacer esta operaci\u00f3n con la m\u00e1quina parada.</p> <p>Por lo tanto, vamos a a\u00f1adir a la m\u00e1quina <code>prueba4</code> una interfaz de red conectada a la red <code>red_nat</code>. Para ello, ejecutamos:</p> <pre><code>virsh -c qemu:///system attach-interface prueba4 network red_nat --model virtio --persistent\nLa interfaz ha sido asociada exitosamente\n</code></pre> <p>Si la m\u00e1quina virtual no tiene entorno gr\u00e1fico y por tanto no tiene instalado el programa <code>NetworkManager</code> habr\u00e1 que acceder a ella y configurar la nueva interfaz de red.</p> <p>En nuestro caso es una m\u00e1quina virtual con Debian 11, donde se ha creado un  interfaz con el nombre <code>enp10s0</code>. Para configurarla modificamos el fichero <code>/etc/network/interfaces</code>:</p> <p></p> <p>Levantamos la interfaz y comprobamos que la nueva interfaz de red ha tomado configuraci\u00f3n de red en el direccionamiento que hab\u00edamos configura en la red <code>red_nat</code>:</p> <p></p> <p>Adem\u00e1s, podr\u00edamos ver la configuraci\u00f3n de las interfaces de red con el comando <code>virsh</code>:</p> <pre><code>virsh -c qemu:///system domifaddr prueba4\n Nombre     direcci\u00f3n MAC       Protocol     Address\n-------------------------------------------------------------------------------\n vnet7      52:54:00:d6:0a:19    ipv4         192.168.122.201/24\n vnet8      52:54:00:2a:37:fc    ipv4         192.168.123.225/24\n</code></pre> <p>Podr\u00edamos a\u00f1adir una nueva interfaz de red indicando el puente virtual al que queremos realizar la conexi\u00f3n. En este caso tendr\u00edamos que ejecutar la misma instrucci\u00f3n pero el tipo de la conexi\u00f3n ser\u00e1 <code>bridge</code>:</p> <pre><code>virsh -c qemu:///system attach-interface prueba4 bridge virbr1 --model virtio --persistent\nLa interfaz ha sido asociada exitosamente\n</code></pre> <p>Y comprobamos que tenemos una tercera interfaz:</p> <pre><code>virsh -c qemu:///system domiflist prueba4\n Interfaz   Tipo      Fuente    Modelo   MAC\n------------------------------------------------------------\n -          network   default   virtio   52:54:00:d6:0a:19\n -          network   red_nat   virtio   52:54:00:2a:37:fc\n -          bridge    virbr1    virtio   52:54:00:0c:06:2a\n</code></pre> <p>Por \u00faltimo indicar que si queremos desconectar una interfaz de red tenemos que indicar el tipo (<code>network</code> o <code>bridge</code>) y la direcci\u00f3n MAC:</p> <pre><code>virsh -c qemu:///system detach-interface prueba4 bridge --mac 52:54:00:0c:06:2a --persistent \nLa interfaz ha sido desmontada exitosamente\n</code></pre> <p>Tambi\u00e9n lo podemos hacer desde <code>virt-manager</code>. Si a\u00f1adimos nuevo hardware en la vista detalle de la m\u00e1quina, podemos a\u00f1adir una nueva conexi\u00f3n indicando la red:</p> <p></p> <p>O indicando el puente virtual donde nos vamos a conectar:</p> <p></p> <p>Tambi\u00e9n podemos modificar en cualquier momento a la red o al puente al que estamos conectado, modificando la interfaz de red desde la vista detalles:</p> <p></p> <p>Para eliminar la interfaz de red desde <code>virt-manager</code> simplemente pulsar\u00edamos con el bot\u00f3n derecho sobre el dispositivo de red en la vista detalle, y pulsar\u00edamos sobre Eliminar Hardware.</p>"},{"location":"00.-KVM/07.-Redes/06.-Configuraci%C3%B3n%20de%20red%20en%20MV/#consideraciones-finales","title":"Consideraciones finales","text":"<ul> <li>Si conectamos una m\u00e1quina virtual a una Red de tipo Aislada, tendremos que configurar de forma est\u00e1tica la interfaz y poner el mismo direccionamiento que hemos configurado para el host. Por ejemplo, para la red <code>red_aislada</code> usamos el direccionamiento <code>192.168.123.0/224</code> y la direcci\u00f3n que le asignamos al host fue <code>192.168.123.1</code>. Otras m\u00e1quinas conectadas a esta red tendr\u00e1n que estar configurada con el mismo direccionamiento.</li> <li>Si conectamos una m\u00e1quina virtual a una Red de tipo Muy Aislada, tendremos que configurar de forma est\u00e1tica la interfaz y poner el direccionamiento que nos interese. Normalmente todas las m\u00e1quinas conectada a esta red tendr\u00e1n el mismo direccionamiento para que tengan conectividad entre ellas.</li> <li> <p>Si conectamos a una Red de tipo Bridge conectada a un bridge externo, la m\u00e1quina virtual se configurar\u00e1 con el mismo direccionamiento que el host. En mis caso, trabajo con la red local <code>172.22.0.0/16</code>, si conecto la m\u00e1quina <code>prueba2</code> (tiene instalada un Ubuntu con NetworkManager) al bridge externo <code>br0</code>, tomar\u00e1 la siguiente configuraci\u00f3n:</p> <p><code>virsh -c qemu:///system attach-interface prueba2 bridge br0 --model virtio --persistent La interfaz ha sido asociada exitosamente</code></p> <p>Iniciamos la m\u00e1quina y comprobamos como la interfaz que acabamos de a\u00f1adir se configura con el direccionamiento de la red local. Esta en la misma red que el host:</p> <p></p> </li> <li> <p>Finalmente, si conectamos a una Red de tipo Bridge compartiendo la interfaz f\u00edsica del host tambi\u00e9n se debe configurar en la misma red local del host. Para realizar la conexi\u00f3n podr\u00edamos conectarnos a la red <code>red_interface</code> como hemos anteriormente. Desde <code>virt-manager</code> tambi\u00e9n podemos hacer la conexi\u00f3n indicando el dispositivo f\u00edsico que vamos a usar:</p> <p></p> <p>Iniciamos la m\u00e1quina y comprobamos:</p> <p></p> </li> </ul>"},{"location":"00.-KVM/08.-LXC/01.-Introduccion%20a%20LXC/","title":"01.-Introduccion a LXC","text":"<p>LinuX Containers, tambi\u00e9n conocido por el acr\u00f3nimo LXC, es una tecnolog\u00eda de virtualizaci\u00f3n ligera o por contenedores, que es un m\u00e9todo de virtualizaci\u00f3n en el que, sobre el n\u00facleo del sistema operativo se ejecuta una capa de virtualizaci\u00f3n que permite que existan m\u00faltiples instancias aisladas de espacios de usuario, en lugar de solo uno. A estas instancias la llamamos contenedores.</p> <p>LXC pertenece a los denominados contenedores de sistemas, su gesti\u00f3n y ciclo de vida es similar al de una m\u00e1quina virtual tradicional. Est\u00e1 mantenido por Canonical y la p\u00e1gina oficial es linuxcontainers.org.</p>"},{"location":"00.-KVM/08.-LXC/01.-Introduccion%20a%20LXC/#instalacion-de-lxc","title":"Instalaci\u00f3n de LXC","text":"<p>Vamos a trabajar sobre una distribuci\u00f3n GNU/Linux Debian 11. Para la instalaci\u00f3n de LXC ejecutamos:</p> <pre><code>apt install lxc\n</code></pre> <p>Podemos crear contenedores LXC privilegiados (ejecutados como root) y no privilegiados (ejecutados por un usuario normal). En este curso vamos a trabajar con contenedores privilegiados.</p>"},{"location":"00.-KVM/08.-LXC/02.-Creaci%C3%B3n%20y%20gesti%C3%B3n%20de%20contenedores/","title":"02.-Creaci\u00f3n y gesti\u00f3n de contenedores","text":"<p>Al crear un contenedor se bajar\u00e1 el sistema de archivos que formar\u00e1 parte de \u00e9l. La primera vez que bajamos con <code>debootstrap</code> una versi\u00f3n de un sistema operativo se descargar\u00e1 un sistema de archivo m\u00ednimo del sistema (que llamamos plantilla) que servir\u00e1 para crear todos los contenedores que creemos de la misma versi\u00f3n del sistema.</p> <p>La creaci\u00f3n de un contenedor con la \u00faltima versi\u00f3n de debian, se realiza con la instrucci\u00f3n (ejecutada como <code>root</code>):</p> <pre><code>$ lxc-create -n contenedor1 -t debian -- -r bullseye\n</code></pre> <ul> <li><code>-n</code>: Nombre del contenedor.</li> <li><code>-t</code>: Nombre de la plantilla.</li> <li><code>-r</code>: Es una opci\u00f3n de la plantilla. Es el nombre de la versi\u00f3n del sistema operativo. Para ver m\u00e1s opciones de una plantilla ejecutamos: <code>lxc-create -t debian -h</code>.</li> </ul> <p>Podemos comprobar que se ha creado un contenedor, ejecutando:</p> <pre><code>$ lxc-ls\ncontenedor1 \n</code></pre> <p>La plantilla que hemos descargado se guarda en <code>/var/cache/lxc/debian/rootfs-bullseye-amd64/</code>. Esta copia del sistema de archivo se utilizar\u00e1 cuando creemos otro contenedor con el mismo sistema operativo. El sistema de archivo del <code>contenedor1</code> se guarda en <code>/var/lib/lxc/contenedor1/rootfs/</code>.</p> <p>Ahora podemos iniciar la ejecuci\u00f3n del contenedor, comprobar que est\u00e1 funcionando y acceder a \u00e9l:</p> <pre><code>$ lxc-start contenedor1\n$ lxc-ls -f\nNAME        STATE   AUTOSTART GROUPS IPV4       IPV6 UNPRIVILEGED \ncontenedor1 RUNNING 0         -      10.0.3.180 -    false        \n$ lxc-attach contenedor1\nroot@contenedor1:~# \n</code></pre> <p>Iniciamos el contenedor con <code>lxc-start</code>, comprobamos los contenedores que tenemos creados con <code>lxc-ls</code> con la opci\u00f3n <code>-f</code> nos da m\u00e1s informaci\u00f3n (vemos que est\u00e1 ejecut\u00e1ndose, que no se ejecuta al inicio, que ha tomado una direcci\u00f3n ip y que es privilegiado). Por \u00faltimo nos hemos conectado al contenedor con <code>lxc-attach</code>.</p> <p>Podemos parar el contenedor con <code>lxc-stop</code> y eliminar el contenedor con <code>lxc-destroy</code>.</p> <p>Para visualizar todas las plantillas que podemos descargar, ejecutamos:</p> <pre><code>$ ls /usr/share/lxc/templates/\nlxc-alpine    lxc-archlinux  lxc-centos  lxc-debian    lxc-fedora     lxc-gentoo  lxc-oci       lxc-opensuse  lxc-plamo  lxc-sabayon    lxc-sparclinux  lxc-ubuntu    lxc-voidlinux\nlxc-altlinux  lxc-busybox    lxc-cirros  lxc-download  lxc-fedora-legacy  lxc-local   lxc-openmandriva  lxc-oracle    lxc-pld    lxc-slackware  lxc-sshd    lxc-ubuntu-cloud\n</code></pre> <p>Tambi\u00e9n puedes obtener la lista de plantillas en la p\u00e1gina Image server for LXC and LXD.</p>"},{"location":"00.-KVM/08.-LXC/02.-Creaci%C3%B3n%20y%20gesti%C3%B3n%20de%20contenedores/#ejecucion-de-comandos-en-un-contenedor","title":"Ejecuci\u00f3n de comandos en un contenedor","text":"<p>Podemos ejecutar un comando en un contenedor que se est\u00e9 ejecutando de la siguiente manera:</p> <pre><code>$ lxc-attach contenedor1 -- ls -al\n</code></pre> <p>si el contenedor est\u00e1 apagado, lo har\u00edamos de la siguiente forma:</p> <pre><code>$ lxc-stop contenedor1\n$ lxc-execute contenedor1 -- ls -al\n</code></pre>"},{"location":"00.-KVM/08.-LXC/02.-Creaci%C3%B3n%20y%20gesti%C3%B3n%20de%20contenedores/#eliminar-un-contenedor","title":"Eliminar un contenedor","text":"<p>Para eliminar un contenedor podemos ejecutar la siguiente instrucci\u00f3n con el contenedor parado:</p> <pre><code>$ lxc-destroy contendor1\n</code></pre> <p>Si el contenedor est\u00e1 inicado podemos usar el par\u00e1metro <code>-f</code> de la instracci\u00f3n <code>lxc-destroy</code> para eliminarlo.</p>"},{"location":"00.-KVM/08.-LXC/03.-Configuraci%C3%B3n%20de%20contenedores%20LXC/","title":"03.-Configuraci\u00f3n de contenedores LXC","text":"<p>El fichero <code>/etc/lxc/default.conf</code> contiene la configuraci\u00f3n general que van a tener los contenedores que creemos. Su contenido es el siguiente:</p> <pre><code>lxc.net.0.type = veth\nlxc.net.0.link = lxcbr0\nlxc.net.0.flags = up\n\nlxc.apparmor.profile = generated\nlxc.apparmor.allow_nesting = 1\n</code></pre> <p>Como vemos se indica a qu\u00e9 red se va a conectar (<code>lxc.net.</code>). Una vez creado un contenedor, el contenido de este fichero se copia a su fichero de configuraci\u00f3n (al que se a\u00f1aden otras configuraciones por defecto). Por ejemplo el fichero de configuraci\u00f3n del contenedor <code>contenedor1</code> lo encontramos en el fichero <code>/var/lib/lxc/contenedor1/config</code>. en este caso, su contenido es:</p> <pre><code>lxc.net.0.type = veth\nlxc.net.0.hwaddr = 00:16:3e:cf:8f:c3\nlxc.net.0.link = lxcbr0\nlxc.net.0.flags = up\nlxc.apparmor.profile = generated\nlxc.apparmor.allow_nesting = 1\nlxc.rootfs.path = dir:/var/lib/lxc/contenedor1/rootfs\n\n# Common configuration\nlxc.include = /usr/share/lxc/config/debian.common.conf\n\n# Container specific configuration\nlxc.tty.max = 4\nlxc.uts.name = contenedor1\nlxc.arch = amd64\nlxc.pty.max = 1024\n</code></pre> <p>Vemos que se han copiado los par\u00e1metros de la configuraci\u00f3n general (<code>/etc/lxc/default.conf</code>) y se han a\u00f1adido nuevos par\u00e1metros: n\u00famero m\u00e1ximo de terminales (<code>lxc.tty.max</code>,<code>lxc.pty.max</code>), nombre del contenedor (<code>lxc.uts.name</code>), arquitectura (<code>lxc.arch</code>), ubicaci\u00f3n del sistema de fichero (<code>lxc.rootfs.path</code>), ...</p> <p>Puedes ver los distintos par\u00e1metros que podemos incluir en la documentaci\u00f3n oficial. Por ejemplo si queremos que los contenedores se inicien autom\u00e1ticamente al iniciar el host podr\u00edamos:</p> <pre><code>lxc.start.auto = 1\n</code></pre> <p>Recuerda que tenemos dos opciones:</p> <ol> <li>Si escribimos el par\u00e1metro en la configuraci\u00f3n general, en el fichero <code>/etc/lxc/default.conf</code>, afectar\u00e1 a los contenedores que se creen nuevos.</li> <li>Si queremos modificar la configuraci\u00f3n de un contenedor ya creado, tenemos que incluir el par\u00e1metro en su fichero de configuraci\u00f3n, por ejemplo para el <code>contenedor1</code> en <code>/var/lib/lxc/contenedor1/config</code>.</li> </ol>"},{"location":"00.-KVM/08.-LXC/03.-Configuraci%C3%B3n%20de%20contenedores%20LXC/#obteniendo-informacion-de-un-contenedor","title":"Obteniendo informaci\u00f3n de un contenedor","text":"<p>Para obtener informaci\u00f3n de un contenedor podemos ejecutar:</p> <pre><code>$ lxc-info contenedor1\nName:           contenedor1\nState:          RUNNING\nPID:            12587\nIP:             10.0.3.180\nLink:           vethuLaHzY\n TX bytes:      1.70 KiB\n RX bytes:      3.80 KiB\n Total bytes:   5.50 KiB\n</code></pre> <p>Con la opci\u00f3n <code>-i</code> s\u00f3lo nos da  la direcci\u00f3n ip, con la opci\u00f3n <code>-S</code> nos da la estad\u00edstica de informaci\u00f3n enviada y recibida por la interfaz de red y con la opci\u00f3n <code>-s</code> nos da informaci\u00f3n del estado.</p>"},{"location":"00.-KVM/08.-LXC/03.-Configuraci%C3%B3n%20de%20contenedores%20LXC/#limitando-los-recursos-para-los-contenedores-lxc","title":"Limitando los recursos para los contenedores LXC","text":"<p>Por defectos los contenedores LXC pueden usar todos los recursos de CPU, RAM, disco del host. Podemos limitar estos recursos. El componente del n\u00facleo que posibilita limitar los recursos para cada contenedor son los Grupos de control cgroups, en concreto en Debian 11 y Debian 12 se utiliza cgroupsv2.</p> <p>Lo primero es que tenemos que habilitar la modificaci\u00f3n de la memoria en los Grupos de control (cgroups). Para ello tenemos que a\u00f1adir al fichero <code>/etc/default/grub</code> la siguiente informaci\u00f3n: a\u00f1adimos al par\u00e1metro <code>GRUB_CMDLINE_LINUX_DEFAULT</code> el valor <code>cgroup_enable=memory</code>. Para que tenga este cambio efecto, reiniciamos la m\u00e1quina.</p> <p>Vamos a limitar el uso de memoria RAM (512Mb) y de n\u00famero de procesadores (1 CPU: la CPU 0) (en la m\u00e1quina donde estoy corriendo los contenedores tenemos 2Gb de RAM y 2 CPUs), para ello en el fichero de configuraci\u00f3n del <code>contenedor1</code> indicamos los siguientes par\u00e1metros:</p> <pre><code>lxc.cgroup2.memory.max = 512M\nlxc.cgroup2.cpuset.cpus = 0\n</code></pre> <p>Reiniciamos el contenedor y comprobamos que se ha llevado a efecto el cambio:</p> <pre><code>$ lxc-stop contenedor1\n$ lxc-start contenedor1\n\n$ lxc-attach contenedor1 -- free -h\n               total        used        free      shared  buff/cache   available\nMem:           512Mi       6.0Mi       505Mi       0.0Ki       0.0Ki       505Mi\n\n$ lxc-attach contenedor1 -- cat /proc/cpuinfo \nprocessor   : 0\n...\n</code></pre> <p>Aparece un s\u00f3lo procesador.</p>"},{"location":"00.-KVM/08.-LXC/04.-Redes%20en%20LXC/","title":"04.-Redes en LXC","text":"<p>LXC nos ofrece distintos mecanismos para conectar nuestros contenedores a una red. En este curso nos vamos a centrar en las conexiones de tipo bridge. Tenemos dos posibilidades:</p> <ul> <li>Podemos crear manualmente el bridge o usar libvirt para su creaci\u00f3n (podemos crear distintos tipos de redes con libvirt).</li> <li>Podemos usar <code>lxc-net</code>, servicio ofrecido por LXC, que nos facilita la creaci\u00f3n de un bridge, que por defecto se llama <code>lxcbr0</code>, y que nos ofrece una red de tipo NAT con los servicios de DHCP y DNS.</li> </ul>"},{"location":"00.-KVM/08.-LXC/04.-Redes%20en%20LXC/#redes-con-lxc-net","title":"Redes con lxc-net","text":"<p>Veamos en primer lugar la segunda opci\u00f3n. El servicio <code>lxc-net</code>  crea un bridge llamado <code>lxcbr0</code> que nos ofrece una red de tipo NAT con los servicios DHCP y DNS. Por defecto nos ofrece una red con direccionamiento <code>10.0.3.0/24</code>.</p>"},{"location":"00.-KVM/08.-LXC/04.-Redes%20en%20LXC/#conexion-de-los-contenedores-a-lxcbr0","title":"Conexi\u00f3n de los contenedores a <code>lxcbr0</code>","text":"<p>La configuraci\u00f3n por defecto posibilita que los contenedores que creemos se conecten a esta red. Lo podemos ver en la configuraci\u00f3n general, en el fichero <code>/etc/lxc/default.conf</code>:</p> <pre><code>lxc.net.0.type = veth\nlxc.net.0.link = lxcbr0\nlxc.net.0.flags = up\n...\n</code></pre> <p>Si hemos creado un contenedor llamado <code>contenedor1</code> recibir\u00e1 esta configuraci\u00f3n que podremos encontrar en su fichero de configuraci\u00f3n <code>/var/lib/lxc/contenedor1/config</code>:</p> <pre><code>lxc.net.0.type = veth\nlxc.net.0.hwaddr = 00:16:3e:cf:8f:c3\nlxc.net.0.link = lxcbr0\nlxc.net.0.flags = up\n...\n</code></pre> <p>Por lo tanto podemos comprobar que el <code>contenedor1</code> est\u00e1 conectado a esa red. Por ejemplo, si mostramos los contenedores que hemos creado, vemos que ha recibido una ip en ese rango:</p> <pre><code>$ lxc-ls -f\nNAME        STATE   AUTOSTART GROUPS IPV4       IPV6 UNPRIVILEGED \ncontenedor1 RUNNING 1         -      10.0.3.180 -    false        \n</code></pre> <p>Si accedemos al contenedor podemos hacer varias comprobaciones:</p> <pre><code>$ lxc-attach contenedor1\nroot@contenedor1:~# ip a\n...\n2: eth0@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    inet 10.0.3.180/24 brd 10.0.3.255 scope global dynamic eth0\n...\n\nroot@contenedor1:~# ip r\ndefault via 10.0.3.1 dev eth0 \n10.0.3.0/24 dev eth0 proto kernel scope link src 10.0.3.180 \n\nroot@contenedor1:~# cat /etc/resolv.conf \nnameserver 10.0.3.1\n\nroot@contenedor1:~# apt install iputils-ping\n...\nroot@contenedor1:~# ping www.josedomingo.org\nPING endor.josedomingo.org (37.187.119.60) 56(84) bytes of data.\n64 bytes from ns330309.ip-37-187-119.eu (37.187.119.60): icmp_seq=1 ttl=49 time=28.7 ms\n...\n</code></pre> <ol> <li>Comprobamos que se ha configurado con la ip <code>10.0.3.180</code>.</li> <li>Vemos que la puerta de enlace es la <code>10.0.3.1</code> que corresponde a nuestra m\u00e1quina f\u00edsica.</li> <li>Del mismo modo la m\u00e1quina f\u00edsica es el servidor DNS.</li> <li>Hemos instalado la herramienta <code>ping</code> y comprobamos que tenemos resoluci\u00f3n y acceso al exterior.</li> </ol>"},{"location":"00.-KVM/08.-LXC/04.-Redes%20en%20LXC/#conexion-de-los-contenedores-a-un-bridge-existente","title":"Conexi\u00f3n de los contenedores a un bridge existente","text":"<p>Imaginemos que tenemos en nuestro host instalado libvirt para manejar los recursos de KVM/QEMU y hemos creado una red con <code>virsh</code> de tipo NAT, que ha creado un bridge llamado <code>virbr0</code>, con las siguientes caracter\u00edsticas:</p> <pre><code>$ virsh net-dumpxml default\n&lt;network&gt;\n  &lt;name&gt;default&lt;/name&gt;\n  &lt;uuid&gt;c411a5a1-f998-42a9-bc8a-9a9052fc36f6&lt;/uuid&gt;\n  &lt;forward mode='nat'&gt;\n    &lt;nat&gt;\n      &lt;port start='1024' end='65535'/&gt;\n    &lt;/nat&gt;\n  &lt;/forward&gt;\n  &lt;bridge name='virbr0' stp='on' delay='0'/&gt;\n  &lt;mac address='52:54:00:fc:32:a2'/&gt;\n  &lt;ip address='192.168.122.1' netmask='255.255.255.0'&gt;\n    &lt;dhcp&gt;\n      &lt;range start='192.168.122.2' end='192.168.122.254'/&gt;\n    &lt;/dhcp&gt;\n  &lt;/ip&gt;\n&lt;/network&gt;\n</code></pre> <p>Podemos modificar el fichero de configuraci\u00f3n por defecto <code>/etc/lxc/default.conf</code>, indicando el bridge <code>virbr0</code>:</p> <pre><code>lxc.net.0.type = veth\nlxc.net.0.link = virbr0\nlxc.net.0.flags = up\n...\n</code></pre> <p>Todos los nuevos contenedores que creemos se conectar\u00e1n a la red <code>default</code>:</p> <pre><code>$ lxc-create -n contenedor2 -t debian -- -r bullseye\n$ lxc-start contenedor2\n$ lxc-ls -f\nNAME        STATE   AUTOSTART GROUPS IPV4            IPV6 UNPRIVILEGED \ncontenedor1 RUNNING 1         -      10.0.3.10       -    false        \ncontenedor2 RUNNING 1         -      192.168.122.228 -    false        \n</code></pre> <p>Vemos como el <code>contenedor2</code> ha tomado en una ip de la red <code>default</code>.</p> <p>Si quisi\u00e9ramos cambiar la conexi\u00f3n del un contenedor ya existente deber\u00edamos hacer la modificaci\u00f3n en su fichero de configuraci\u00f3n: <code>/var/lib/lxc/&lt;NOMBRE_CONTENEDOR&gt;/config</code> y reiniciar el contenedor.</p> <p>Tambi\u00e9n podr\u00edamos conectar el <code>contenedor1</code> a la red <code>default</code>, para ello vamos a a\u00f1adir la informaci\u00f3n de la conexi\u00f3n en su fichero de configuraci\u00f3n <code>/var/lib/lxc/contenedor1/config</code>:</p> <pre><code>lxc.net.0.type = veth\nlxc.net.0.hwaddr = 00:16:3e:cf:8f:c3\nlxc.net.0.link = lxcbr0\nlxc.net.0.flags = up\n\nlxc.net.1.type = veth\nlxc.net.1.hwaddr = 00:16:3e:cf:8f:d3\nlxc.net.1.link = virbr0\nlxc.net.1.flags = up\n...\n</code></pre> <p>Indicamos la segunda conexi\u00f3n utilizando el nombre de los par\u00e1metros como <code>lxc.net.1.*</code>. Adem\u00e1s hemos cambiado la mac de la segunda tarjeta de red. Ahora reiniciamos y accedemos al contenedor:</p> <pre><code>$ lxc-stop -r contenedor1\n$ lxc-attach contenedor1\nroot@contenedor1:~# apt install nano\nroot@contenedor1:~# nano /etc/network/interfaces\n</code></pre> <p>Configuramos la segunda interfaz de red:</p> <pre><code>auto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n\nauto eth1\niface eth1 inet dhcp\n</code></pre> <p>Y obtenemos una nueva direcci\u00f3n ip en la nueva red:</p> <pre><code>root@contenedor1:~# ifup eth1\nroot@contenedor1:~# ip a\n...\n2: eth0@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n...\n    inet 10.0.3.10/24 brd 10.0.3.255 scope global dynamic eth0\n...\n3: eth1@if14: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n...\n    inet 192.168.122.196/24 brd 192.168.122.255 scope global dynamic eth1\n...\n</code></pre> <p>Si listamos los contenedores que tenemos, podemos ver las dos direcciones ip:</p> <pre><code>$ lxc-ls -f\nNAME        STATE   AUTOSTART GROUPS IPV4                        IPV6 UNPRIVILEGED \ncontenedor1 RUNNING 1         -      10.0.3.10, 192.168.122.196  -    false        \ncontenedor2 RUNNING 1         -      192.168.122.228             -    false    \n</code></pre>"},{"location":"00.-KVM/08.-LXC/05.-Almacenamiento%20en%20LXC/","title":"05.-Almacenamiento en LXC","text":"<p>Veamos c\u00f3mo montar un directorio del host en un contenedor. Imaginemos que tenemos el directorio <code>/opt/contenedor1</code> con un fichero <code>index.html</code> y lo queremos montar en el <code>contenedor1</code> en el directorio <code>/srv/www</code>. Tenemos que tener en cuenta los siguiente:</p> <p>El directorio de montaje debe existir en el contenedor:</p> <pre><code>$ lxc-attach contenedor1\nroot@contenedor1:~# cd /srv\nroot@contenedor1:/srv# mkdir www\n</code></pre> <p>En el fichero de configuraci\u00f3n del contenedor (<code>/var/lib/lxc/contenedor1/config</code>) a\u00f1adimos la siguiente l\u00ednea:</p> <pre><code>lxc.mount.entry=/opt/contenedor1 srv/www none bind 0 0\n</code></pre> <p>Hay que tener en cuenta que al indicar el directorio de montaje hay que usar una ruta relativa (es relativa al directorio donde se encuentra el sistema de fichero del contenedor, en este caso <code>/var/lib/lxc/contenedor1/rootfs/</code>).</p> <p>Reiniciamos el contenedor y comprobamos que se ha montado el directorio de forma correcta:</p> <pre><code>$ lxc-stop contenedor1\n$ lxc-start contenedor1\n$ lxc-attach contenedor1\nroot@contenedor1:~# cd /srv/www\nroot@contenedor1:/srv/www# ls\nindex.html\n</code></pre>"},{"location":"00.-KVM/08.-LXC/06.-Introducci%C3%B3n%20a%20LXD/","title":"06.-Introducci\u00f3n a LXD","text":"<p>LXD, Linux Container Daemon, es una herramienta de gesti\u00f3n de los contenedores y m\u00e1quinas virtuales del sistema operativo Linux, desarrollada por Canonical.</p> <p>Internamente usa LXC para la gesti\u00f3n de contenedores, pero facilita el uso de los contenedores a\u00f1adiendo nuevas funcionalidades.</p> <ul> <li>LXD no trabaja con plantillas, trabaja con im\u00e1genes de sistemas operativos para crear los contenedores. Lista de im\u00e1genes.</li> <li>No ofrece soporte para diferentes backends de almacenamiento y tipos de red. Facilitando la gesti\u00f3n de red y almacenamiento.</li> <li>LXD ofrece una REST API que podemos usar con una simple herramienta de l\u00ednea de comandos o con herramientas de terceros.</li> <li>LXD gestiona instancias, que pueden ser de tipos: contenedores, usando LXC internamente, y m\u00e1quinas virtuales usando QEMU internamente.</li> </ul>"},{"location":"00.-KVM/08.-LXC/06.-Introducci%C3%B3n%20a%20LXD/#instalacion-de-lxd","title":"Instalaci\u00f3n de LXD","text":"<p>Vamos a usar el gestor de paquetes snap (si est\u00e1s trabajando con la distribuci\u00f3n Debian 11 debes instalar el paquete <code>snapd</code>).</p> <pre><code>sudo snap install lxd\n</code></pre> <p>En la versi\u00f3n Debian 12 lo podemos instalar con <code>apt</code>:</p> <pre><code>apt install lxd\n</code></pre> <p>Antes de ejecutar una instancia (contenedor o m\u00e1quina virtual) tenemos que hacer una configuraci\u00f3n inicial de LXD, para ello ejecutamos como root:</p> <pre><code>lxd init\n</code></pre> <p>Interactivamente nos va preguntando distintos par\u00e1metros que nos permitir\u00e1n realizar la configuraci\u00f3n inicial:</p> <pre><code>Would you like to use LXD clustering? (yes/no) [default=no]: \nDo you want to configure a new storage pool? (yes/no) [default=yes]: \nName of the new storage pool [default=default]: \nName of the storage backend to use (cephobject, dir, lvm, btrfs, ceph) [default=btrfs]: dir\nWould you like to connect to a MAAS server? (yes/no) [default=no]: \nWould you like to create a new local network bridge? (yes/no) [default=yes]: \nWhat should the new bridge be called? [default=lxdbr0]: \nWhat IPv4 address should be used? (CIDR subnet notation, \u201cauto\u201d or \u201cnone\u201d) [default=auto]: \nWhat IPv6 address should be used? (CIDR subnet notation, \u201cauto\u201d or \u201cnone\u201d) [default=auto]: \nWould you like the LXD server to be available over the network? (yes/no) [default=no]: \nWould you like stale cached images to be updated automatically? (yes/no) [default=yes]: \nWould you like a YAML \"lxd init\" preseed to be printed? (yes/no) [default=no]: \n</code></pre> <p>Hemos dejado todos los valores por defecto, a excepci\u00f3n del tipo de pool de almacenamiento que he indicado que sea un directorio (dir). Tambi\u00e9n ha creado una red puente para conectar los contenedores.</p>"},{"location":"00.-KVM/08.-LXC/06.-Introducci%C3%B3n%20a%20LXD/#creacion-de-un-contenedor","title":"Creaci\u00f3n de un contenedor","text":"<p>Para crear un contenedor, ejecutamos:</p> <pre><code>lxc launch &lt;image_server&gt;:&lt;image_name&gt; &lt;instance_name&gt;\n</code></pre> <p>Por ejemplo:</p> <pre><code>lxc launch images:ubuntu/20.04 ubuntu-container\n</code></pre>"},{"location":"00.-KVM/08.-LXC/06.-Introducci%C3%B3n%20a%20LXD/#creacion-de-maquinas-virtuales","title":"Creaci\u00f3n de m\u00e1quinas virtuales","text":"<p>Para crear una m\u00e1quina virtual, ejecutamos:</p> <pre><code>lxc launch &lt;image_server&gt;:&lt;image_name&gt; &lt;instance_name&gt; --vm\n</code></pre> <p>Por ejemplo:</p> <pre><code>lxc launch images:ubuntu/20.04 ubuntu-vm --vm\n</code></pre> <p>Y comprobamos que hemos creado un contenedor y una m\u00e1quina virtual:</p> <pre><code>lxc list\n+------------------+---------+-------------------------+-------------------------------------------------+-----------------+-----------+\n|       NAME       |  STATE  |          IPV4           |                      IPV6                       |      TYPE       | SNAPSHOTS |\n+------------------+---------+-------------------------+-------------------------------------------------+-----------------+-----------+\n| ubuntu-container | RUNNING | 10.242.154.69 (eth0)    | fd42:40c4:7788:440e:216:3eff:fe61:66b0 (eth0)   | CONTAINER       | 0         |\n+------------------+---------+-------------------------+-------------------------------------------------+-----------------+-----------+\n| ubuntu-vm        | RUNNING | 10.242.154.119 (enp5s0) | fd42:40c4:7788:440e:216:3eff:fea3:8748 (enp5s0) | VIRTUAL-MACHINE | 0         |\n+------------------+---------+-------------------------+-------------------------------------------------+-----------------+-----------+\n</code></pre>"},{"location":"00.-KVM/08.-LXC/06.-Introducci%C3%B3n%20a%20LXD/#gestion-de-imagenes","title":"Gesti\u00f3n de im\u00e1genes","text":"<p>En la creaci\u00f3n de las dos instancias hemos descargado dos im\u00e1genes que podemos gestionar con el subcomando <code>lxc image</code>, por ejemplo para ver las im\u00e1genes que hemos descargado:</p> <pre><code>lxc image  list\n+-------+--------------+--------+-------------------------------------+--------------+-----------------+----------+------------------------------+\n| ALIAS | FINGERPRINT  | PUBLIC |             DESCRIPTION             | ARCHITECTURE |      TYPE       |   SIZE   |         UPLOAD DATE          |\n+-------+--------------+--------+-------------------------------------+--------------+-----------------+----------+------------------------------+\n|       | 3aa3fa64e5d0 | no     | Ubuntu focal amd64 (20220911_07:42) | x86_64       | VIRTUAL-MACHINE | 230.98MB | Sep 12, 2022 at 7:28am (UTC) |\n+-------+--------------+--------+-------------------------------------+--------------+-----------------+----------+------------------------------+\n|       | 7628425e768e | no     | Ubuntu focal amd64 (20220911_07:42) | x86_64       | CONTAINER       | 110.65MB | Sep 12, 2022 at 7:22am (UTC) |\n+-------+--------------+--------+-------------------------------------+--------------+-----------------+----------+------------------------------+\n</code></pre> <p>Para m\u00e1s informaci\u00f3n ejecuta <code>lxc image --help</code>.</p>"},{"location":"00.-KVM/08.-LXC/06.-Introducci%C3%B3n%20a%20LXD/#gestion-de-instancia","title":"Gesti\u00f3n de instancia","text":"<p>Vamos a usar la utilidad de l\u00ednea de comandos <code>lxc</code>, para ver todas las funcionalidades puedes ejecutar <code>lxc --help</code>. Veamos algunas de ella:</p> <ul> <li><code>lxc list</code>: Listar instancias. Podemos filtrar la lista, por ejemplo <code>lxc list type=container</code> o <code>lxc list ubuntu.*</code>.</li> <li><code>lxc info</code>: Nos da informaci\u00f3n de una instancia. Con la opci\u00f3n <code>--show-log</code> nos muestra los logs de la instancia.</li> <li><code>lxc start</code>: Inicia una instancia.</li> <li><code>lxc stop</code>: Detiene una instancia.</li> <li><code>lxc delete</code>: Borra una instancia.</li> </ul> <p>Si queremos ejecutar un comando en una instancia, ejecutamos:</p> <pre><code>lxc exec &lt;instance_name&gt; -- &lt;command&gt;\n</code></pre> <p>Por ejemplo:</p> <pre><code>lxc exec ubuntu-container -- apt update\n</code></pre> <p>Si queremos acceder a una shell de la instancia:</p> <pre><code>lxc exec ubuntu-container -- /bin/bash\n</code></pre> <p>Si queremos conectarnos a una instancia por una consola, ejecutamos:</p> <pre><code>lxc console &lt;instance_name&gt;\n</code></pre> <p>Nota: Deber\u00edamos configurar una contrase\u00f1a para un usuario anteriormente accediendo al bash de la instancia.</p>"},{"location":"00.-KVM/08.-LXC/06.-Introducci%C3%B3n%20a%20LXD/#configuracion-de-las-instancias","title":"Configuraci\u00f3n de las instancias","text":"<p>Tenemos muchos par\u00e1metros de configuraci\u00f3n de las instancias, que podemos devivir en tres bloques: propiedades de las instancias, openciones de las instancias y dispositivos de las instancias.</p> <p>Al crear una instancia podemos indicar los par\u00e1metros de configuraci\u00f3n deseados, por ejemplo, si queremos limitar el n\u00famero de CPU y la memoria de un contenedor, podemos ejecutar:</p> <pre><code>lxc launch images:ubuntu/20.04 ubuntu-limited -c limits.cpu=1 -c limits.memory=192MiB\n</code></pre> <p>Con el subcomando <code>lxc config</code> podemos gestionar la configuraci\u00f3n de las instancias, por ejemplo para mostrar la configuraci\u00f3n de una instancia, ejecutamos:</p> <pre><code>lxc config show ubuntu-container\n</code></pre> <p>Por ejemplo, para cambiar un par\u00e1metro:</p> <pre><code>lxc config set ubuntu-container limits.memory=128MiB\n</code></pre>"},{"location":"00.-KVM/08.-LXC/06.-Introducci%C3%B3n%20a%20LXD/#para-seguir-profundizando","title":"Para seguir profundizando","text":"<ul> <li>M\u00e1s informaci\u00f3n sobre la configuraci\u00f3n de instancias.</li> <li>M\u00e1s informaci\u00f3n sobre la gesti\u00f3n de im\u00e1genes.</li> <li>Con el subcomando <code>lxc network</code> gestionamos las redes. M\u00e1s informaci\u00f3n.</li> <li>Con el subcomando <code>lxc storage</code> gestionamos los pools de almacenamiento. M\u00e1s informaci\u00f3n.</li> </ul>"},{"location":"00.-KVM/09.-Anexos/01.-Uso%20de%20los%20puertos%20USB%20en%20KVM/","title":"01.-Uso de los puertos USB en KVM","text":""},{"location":"00.-KVM/09.-Anexos/01.-Uso%20de%20los%20puertos%20USB%20en%20KVM/#tutorial-uso-de-un-puerto-usb-en-una-maquina-virtual-kvmqemu","title":"Tutorial: Uso de un puerto USB en una m\u00e1quina virtual KVM/QEMU","text":""},{"location":"00.-KVM/09.-Anexos/01.-Uso%20de%20los%20puertos%20USB%20en%20KVM/#requisitos-previos","title":"Requisitos previos","text":"<ul> <li>Tienes instalado y configurado KVM y QEMU en tu m\u00e1quina host.</li> <li>Tienes una m\u00e1quina virtual (MV) ya creada y en funcionamiento en tu sistema de virtualizaci\u00f3n KVM/QEMU.</li> <li>El puerto USB y los dispositivos que quieres conectar deben estar f\u00edsicamente accesibles en tu host.</li> </ul>"},{"location":"00.-KVM/09.-Anexos/01.-Uso%20de%20los%20puertos%20USB%20en%20KVM/#pasos-para-usar-un-puerto-usb-en-una-mv-kvmqemu","title":"Pasos para usar un puerto USB en una MV KVM/QEMU","text":""},{"location":"00.-KVM/09.-Anexos/01.-Uso%20de%20los%20puertos%20USB%20en%20KVM/#1-verificar-dispositivos-usb-en-el-host","title":"1. Verificar dispositivos USB en el host","text":"<p>Primero, debemos identificar los dispositivos USB conectados en el host que queremos pasar a la m\u00e1quina virtual.</p> <ol> <li>Abre una terminal en el host.</li> <li>Ejecuta el comando:    <code>bash    lsusb</code>    Esto listar\u00e1 todos los dispositivos USB conectados. El formato de salida se ver\u00e1 algo como esto:    <code>Bus 001 Device 003: ID 0951:16a4 Kingston Technology    Bus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub</code></li> </ol> <p>Toma nota del Bus y Device ID del dispositivo USB que deseas conectar a tu m\u00e1quina virtual (en este caso, <code>Bus 001 Device 003</code>).</p>"},{"location":"00.-KVM/09.-Anexos/01.-Uso%20de%20los%20puertos%20USB%20en%20KVM/#2-anadir-el-dispositivo-usb-a-la-mv-con-virt-manager","title":"2. A\u00f1adir el dispositivo USB a la MV con virt-manager","text":"<p>Si prefieres una interfaz gr\u00e1fica, puedes usar virt-manager para a\u00f1adir el dispositivo USB a tu MV.</p> <ol> <li>Abre virt-manager:    <code>bash    virt-manager</code></li> <li>Selecciona la m\u00e1quina virtual a la que deseas conectar el USB.</li> <li>Haz clic en el bot\u00f3n de Detalles de la MV (icono de herramientas).</li> <li>Navega a la pesta\u00f1a Add Hardware (Agregar Hardware).</li> <li>Selecciona USB Host Device en la lista y elige el dispositivo USB que aparece en la lista (ej. \"Kingston Technology\").</li> <li>Haz clic en Finish o Apply para a\u00f1adir el dispositivo USB a la m\u00e1quina virtual.</li> </ol>"},{"location":"00.-KVM/09.-Anexos/01.-Uso%20de%20los%20puertos%20USB%20en%20KVM/#3-anadir-el-dispositivo-usb-a-la-mv-desde-la-linea-de-comandos-virsh","title":"3. A\u00f1adir el dispositivo USB a la MV desde la l\u00ednea de comandos (virsh)","text":"<p>Si prefieres trabajar con la terminal, puedes a\u00f1adir el dispositivo USB usando el comando <code>virsh</code>.</p> <ol> <li> <p>Aseg\u00farate de que tu MV est\u00e9 detenida antes de agregar el dispositivo USB:    <code>bash    virsh shutdown &lt;nombreMV&gt;</code></p> </li> <li> <p>Agrega el dispositivo USB usando el comando <code>virsh attach-device</code>:    <code>bash    virsh attach-device &lt;nombreMV&gt; --file &lt;path_al_xml_del_dispositivo&gt;</code></p> </li> </ol> <p>El archivo XML debe tener la siguiente estructura:    <code>xml    &lt;hostdev mode='subsystem' type='usb'&gt;      &lt;source&gt;        &lt;vendor id='0x0951'/&gt;        &lt;product id='0x16a4'/&gt;      &lt;/source&gt;    &lt;/hostdev&gt;</code></p> <p>Donde <code>vendor id</code> y <code>product id</code> son los valores que obtuviste con <code>lsusb</code>. En este caso, <code>0951</code> es el vendor id de Kingston, y <code>16a4</code> es el product id.</p> <ol> <li>Inicia la m\u00e1quina virtual de nuevo:    <code>bash    virsh start &lt;nombreMV&gt;</code></li> </ol>"},{"location":"00.-KVM/09.-Anexos/01.-Uso%20de%20los%20puertos%20USB%20en%20KVM/#4-verificar-el-dispositivo-usb-en-la-mv","title":"4. Verificar el dispositivo USB en la MV","text":"<p>Una vez que hayas agregado el dispositivo USB, inicia sesi\u00f3n en tu m\u00e1quina virtual (por ejemplo, mediante <code>virt-manager</code> o SSH). Luego:</p> <ol> <li>Abre una terminal en la MV.</li> <li>Ejecuta el comando:    <code>bash    lsusb</code>    El dispositivo USB deber\u00eda aparecer en la lista dentro de la MV.</li> </ol>"},{"location":"00.-KVM/09.-Anexos/01.-Uso%20de%20los%20puertos%20USB%20en%20KVM/#notas-adicionales","title":"Notas adicionales:","text":"<ul> <li> <p>Desconectar el dispositivo USB: Para desconectar el dispositivo USB de la MV mientras est\u00e1 en funcionamiento, puedes usar el siguiente comando:   <code>bash   virsh detach-device &lt;nombreMV&gt; &lt;path_al_xml_del_dispositivo&gt;</code></p> </li> <li> <p>Acceso exclusivo: Cuando conectas un dispositivo USB a una MV, este dispositivo ya no estar\u00e1 accesible desde el host hasta que se desasocie de la MV.</p> </li> <li> <p>Compatibilidad: Aseg\u00farate de que los drivers necesarios para el dispositivo USB est\u00e1n instalados tanto en el host como en la m\u00e1quina virtual para evitar problemas de compatibilidad.</p> </li> </ul>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/","title":"Tutorial: Configurar KVM para permitir copiar y pegar entre m\u00e1quinas virtuales","text":""},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#configuracion-para-los-modos-graficos","title":"Configuraci\u00f3n para los modos gr\u00e1ficos","text":""},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#requisitos-previos","title":"Requisitos previos","text":"<ul> <li>Tienes KVM y QEMU instalados y funcionando correctamente en tu m\u00e1quina host.</li> <li>Tienes una m\u00e1quina virtual (MV) creada y en funcionamiento.</li> </ul>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#pasos-para-habilitar-la-funcionalidad-de-copiar-y-pegar-portapapeles-compartido","title":"Pasos para habilitar la funcionalidad de copiar y pegar (Portapapeles compartido)","text":"<p>Para poder copiar y pegar texto entre el host y las m\u00e1quinas virtuales, debes instalar y configurar un conjunto de herramientas llamado Spice. Spice es un protocolo que, entre otras cosas, permite habilitar la compartici\u00f3n del portapapeles.</p>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#paso-1-instalar-spice-en-el-host","title":"Paso 1: Instalar Spice en el host","text":"<ol> <li>Abre una terminal en tu host.</li> <li>Aseg\u00farate de que tienes instalado el paquete <code>spice-vdagent</code> en el host. Ejecuta:  <code>bash  sudo apt update  sudo apt install spice-vdagent</code></li> </ol> <p>En otras distribuciones, puedes utilizar el gestor de paquetes de tu sistema (por ejemplo, <code>dnf</code> en Fedora).</p>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#paso-2-configurar-la-maquina-virtual-en-virt-manager","title":"Paso 2: Configurar la m\u00e1quina virtual en <code>virt-manager</code>","text":"<ol> <li>Abre virt-manager en tu host:  <code>bash  virt-manager</code></li> <li>Selecciona la m\u00e1quina virtual a la que deseas agregar la funcionalidad de copiar y pegar.</li> <li>Haz clic en el bot\u00f3n de Detalles de la MV (icono de herramientas).</li> <li>En el men\u00fa de la izquierda, selecciona la opci\u00f3n Display Spice (o Display en algunas versiones).</li> <li>Aseg\u00farate de que el servidor de Spice est\u00e9 seleccionado para la visualizaci\u00f3n y no VNC.</li> <li>Navega a la pesta\u00f1a de Video dentro de la configuraci\u00f3n de la m\u00e1quina virtual y selecciona el controlador QXL como el dispositivo de video.</li> <li>Guarda los cambios y arranca la m\u00e1quina virtual.</li> </ol>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#paso-3-instalar-spice-y-spice-vdagent-en-la-maquina-virtual","title":"Paso 3: Instalar Spice y <code>spice-vdagent</code> en la m\u00e1quina virtual","text":"<p>Dependiendo del sistema operativo que est\u00e9s utilizando en la m\u00e1quina virtual, necesitar\u00e1s instalar el spice-vdagent para habilitar la funcionalidad de portapapeles compartido.</p>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#en-linux-debianubuntu","title":"En Linux (Debian/Ubuntu)","text":"<ol> <li>Abre una terminal dentro de la m\u00e1quina virtual.</li> <li>Instala el paquete <code>spice-vdagent</code> ejecutando:  <code>bash  sudo apt update  sudo apt install spice-vdagent</code></li> <li>Reinicia la m\u00e1quina virtual para que los cambios surtan efecto.</li> </ol>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#en-windows","title":"En Windows","text":"<ol> <li>Descarga e instala los Spice Guest Tools desde este enlace.</li> <li>Sigue el asistente de instalaci\u00f3n para agregar los controladores de Spice a tu sistema Windows.</li> <li>Reinicia la m\u00e1quina virtual.</li> </ol>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#paso-4-probar-copiar-y-pegar","title":"Paso 4: Probar copiar y pegar","text":"<ol> <li>Una vez reiniciada la m\u00e1quina virtual, intenta copiar texto desde el host (por ejemplo, selecciona texto y presiona <code>Ctrl+C</code>).</li> <li>Luego, ve a la m\u00e1quina virtual, selecciona un \u00e1rea de texto y presiona <code>Ctrl+V</code> para pegar.</li> <li>Verifica que el texto copiado se haya transferido correctamente.</li> </ol>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#notas-adicionales","title":"Notas adicionales:","text":"<ul> <li> <p>Spice-vdagent es el agente responsable de la compartici\u00f3n del portapapeles, entre otras funciones (como la redirecci\u00f3n de dispositivos USB).</p> </li> <li> <p>Adem\u00e1s de copiar y pegar texto, tambi\u00e9n puedes redimensionar autom\u00e1ticamente la ventana de la m\u00e1quina virtual si usas el controlador de video QXL.</p> </li> <li> <p>En virt-manager, aseg\u00farate siempre de que est\u00e1s utilizando Spice en lugar de VNC para habilitar estas funciones avanzadas.</p> </li> </ul>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#opciones-para-copiar-y-pegar-en-modo-texto","title":"Opciones para copiar y pegar en modo texto","text":"<p>Si est\u00e1s utilizando dos m\u00e1quinas virtuales con Ubuntu Server o cualquier sistema operativo sin entorno gr\u00e1fico, las funciones de Spice relacionadas con el portapapeles compartido (copiar y pegar) no estar\u00e1n disponibles. Esto es porque Spice est\u00e1 dise\u00f1ado para trabajar con entornos gr\u00e1ficos, y depende del agente Spice (<code>spice-vdagent</code>), que requiere una interfaz gr\u00e1fica para habilitar la funcionalidad de copiar y pegar, junto con otras caracter\u00edsticas como la redimensi\u00f3n de pantalla.</p> <p>Dado que en servidores o sistemas en modo texto (sin GUI) no hay un entorno gr\u00e1fico, el agente Spice y los controladores de video como QXL no se pueden usar.</p>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#alternativas-para-copiar-y-pegar-entre-maquinas-virtuales-sin-entorno-grafico","title":"Alternativas para copiar y pegar entre m\u00e1quinas virtuales sin entorno gr\u00e1fico:","text":"<p>Aunque Spice no funcionar\u00e1 en este caso, hay varias maneras de transferir texto y archivos entre m\u00e1quinas virtuales en modo texto:</p>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#ssh-con-acceso-directo-o-redireccionamiento-de-comandos","title":"SSH con acceso directo o redireccionamiento de comandos:","text":"<p>Puedes conectarte entre las m\u00e1quinas virtuales o entre la m\u00e1quina host y las m\u00e1quinas virtuales usando SSH. Esto te permite copiar texto o archivos sin necesidad de un portapapeles compartido.</p> <p>Para copiar un archivo desde el host a la m\u00e1quina virtual:</p> <pre><code>scp archivo.txt usuario@direccion_ip_maquina_virtual:/ruta/destino/\n</code></pre> <p>Para copiar directamente un texto como un comando:</p> <pre><code>ssh usuario@direccion_ip_maquina_virtual 'echo \"Texto a copiar\" &gt; archivo.txt'\n</code></pre> <p>Esto es particularmente \u00fatil para transferir grandes bloques de texto o scripts entre m\u00e1quinas.</p>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#directorio-compartido-con-nfs-o-samba","title":"Directorio compartido con NFS o Samba:","text":"<p>Puedes configurar un sistema de archivos compartido entre las m\u00e1quinas virtuales utilizando NFS o Samba. Esto te permite copiar archivos o contenido en un directorio com\u00fan al que ambas m\u00e1quinas virtuales puedan acceder.</p> <p>Configura un directorio compartido en una m\u00e1quina y monta ese directorio en la otra. Todo lo que copies o crees en ese directorio ser\u00e1 accesible en ambas m\u00e1quinas. Esto es \u00fatil para transferir archivos grandes o colaborar en proyectos entre m\u00e1quinas.</p>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#uso-de-herramientas-como-tmux-o-screen","title":"Uso de herramientas como tmux o screen:","text":"<p>Si necesitas trabajar simult\u00e1neamente en ambas m\u00e1quinas virtuales desde la terminal, puedes usar herramientas como <code>tmux</code> o <code>screen</code>, que permiten compartir sesiones de terminal entre m\u00e1quinas o usuarios.</p> <p>Una sesi\u00f3n compartida de <code>tmux</code> te permite acceder a una misma terminal desde dos ubicaciones diferentes (como desde las dos m\u00e1quinas virtuales). Esto puede simular un flujo de trabajo de copiar y pegar, aunque no es exactamente lo mismo que un portapapeles compartido.</p>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#redireccionamiento-de-puertos-o-utilizacion-de-herramientas-como-rsync","title":"Redireccionamiento de Puertos o Utilizaci\u00f3n de Herramientas como rsync","text":"<p>Si la sincronizaci\u00f3n de archivos o carpetas es un tema recurrente, puedes usar herramientas como rsync para sincronizar directorios y archivos entre las m\u00e1quinas virtuales. Esto tambi\u00e9n es \u00fatil para mantener el contenido actualizado en tiempo real entre ambas m\u00e1quinas.</p> <p>Ejemplo con rsync:</p> <pre><code>rsync -avz /ruta/origen usuario@direccion_ip_maquina_virtual:/ruta/destino\n</code></pre>"},{"location":"00.-KVM/09.-Anexos/02.-Copiar%20y%20Pegar/#conclusion","title":"Conclusi\u00f3n","text":"<p>Para servidores sin entorno gr\u00e1fico (como Ubuntu Server), la funcionalidad de Spice para copiar y pegar no es aplicable. En su lugar, puedes usar herramientas como SSH, scp, rsync, directorio compartido o <code>tmux</code> para transferir texto, archivos y comandos entre m\u00e1quinas virtuales. Estas alternativas son ideales para entornos sin GUI.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/","title":"Ejercicios KVM","text":""},{"location":"00.-KVM/10.-Pr%C3%A1cticas/#ejercicio-1-verificacion-del-soporte-de-virtualizacion-en-el-host","title":"Ejercicio 1: Verificaci\u00f3n del Soporte de Virtualizaci\u00f3n en el Host","text":"<p>Tarea: Ejecuta el comando <code>egrep -E -c '(vmx|svm)' /proc/cpuinfo</code> en tu m\u00e1quina host para verificar si el procesador soporta virtualizaci\u00f3n por hardware (Intel VT o AMD-V).</p> <p>Instrucciones:</p> <ul> <li>Abre una terminal en tu sistema Linux.</li> <li>Ejecuta el comando indicado.</li> <li>Si el resultado es mayor que 0, la virtualizaci\u00f3n est\u00e1 habilitada.  Objetivo: Verificar que el hardware soporta la creaci\u00f3n de m\u00e1quinas virtuales con KVM.</li> </ul>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/#ejercicio-2-instalacion-de-kvm-y-herramientas-de-virtualizacion","title":"Ejercicio 2: Instalaci\u00f3n de KVM y Herramientas de Virtualizaci\u00f3n","text":"<p>Tarea: Instala el paquete qemu-kvm, libvirt-bin, y virt-manager en una distribuci\u00f3n Linux (por ejemplo, Ubuntu) y habilita el servicio de libvirtd.</p> <p>Instrucciones:</p> <ul> <li> <p>Ejecuta <code>apt install qemu-system libvirt-clients libvirt-daemon-system</code>.</p> </li> <li> <p>Habilita el servicio con <code>sudo systemctl enable libvirtd</code> y luego in\u00edcialo con sudo <code>systemctl start libvirtd</code>.</p> </li> <li> <p>Verifica la correcta instalaci\u00f3n ejecutando <code>virsh list --all</code>.</p> </li> </ul> <p>Objetivo: Preparar el sistema para crear y administrar m\u00e1quinas virtuales.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/#ejercicio-3-creacion-de-una-maquina-virtual-desde-la-cli","title":"Ejercicio 3: Creaci\u00f3n de una M\u00e1quina Virtual desde la CLI","text":"<p>Tarea: Utiliza el comando <code>virt-install</code> para crear una m\u00e1quina virtual Ubuntu desde la l\u00ednea de comandos con un disco de 10GB y 2GB de RAM.</p> <p>Instrucciones:</p> <ul> <li>Descarga una imagen de Ubuntu Server (ISO).</li> <li>Ejecuta el siguiente comando:</li> </ul> <pre><code>sudo virt-install --name UbuntuVM \\\n  --ram 2048 \\\n  --vcpus 2 \\\n  --disk path=/var/lib/libvirt/images/ubuntu.qcow2,size=10 \\\n  --location ~/&lt;nombre_distribuci\u00f3n&gt;,kernel=casper/vmlinuz,initrd=casper/initrd \\\n  --os-variant ubuntu24.04 \\\n  --network bridge=virbr0 \\\n  --graphics none \\\n  --console pty,target_type=serial \\\n  --extra-args 'console=ttyS0,115200n8 serial'\n</code></pre> <p>Sigue el proceso de instalaci\u00f3n a trav\u00e9s de la consola.</p> <p>Objetivo: Crear y administrar una m\u00e1quina virtual usando solo la CLI.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/#ejercicio-4-creacion-de-un-disco-virtual-adicional-para-una-mv-existente","title":"Ejercicio 4: Creaci\u00f3n de un Disco Virtual Adicional para una MV Existente","text":"<p>Tarea: A\u00f1adir un segundo disco virtual de 5GB a una m\u00e1quina virtual existente. Instrucciones:</p> <ul> <li> <p>Det\u00e9n la m\u00e1quina virtual con <code>virsh shutdown &lt;nombreMV&gt;</code>.</p> </li> <li> <p>Usa el comando <code>virsh edit &lt;nombreMV&gt;</code> para editar la configuraci\u00f3n XML de la m\u00e1quina.</p> </li> <li> <p>A\u00f1ade la siguiente secci\u00f3n en el archivo XML:</p> </li> </ul> <pre><code>&lt;disk type='file' device='disk'&gt;\n   &lt;driver name='qemu' type='qcow2'/&gt;\n   &lt;source file='/var/lib/libvirt/images/disk2.qcow2'/&gt;\n   &lt;target dev='vdb' bus='virtio'/&gt;\n&lt;/disk&gt;\n</code></pre> <ul> <li>Guarda el archivo y arranca la MV de nuevo.</li> </ul> <p>Objetivo: Familiarizarse con la administraci\u00f3n de almacenamiento adicional en una MV. \u00a1 OJO !:: Debes crear el disco virtual previamente. </p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/#ejercicio-5-migracion-en-vivo-de-una-mv-a-otro-host","title":"Ejercicio 5: Migraci\u00f3n en Vivo de una MV a Otro Host","text":"<p>Tarea: Realizar una migraci\u00f3n en vivo de una m\u00e1quina virtual desde un host KVM a otro sin detenerla. Instrucciones: - Aseg\u00farate de que ambos hosts est\u00e1n configurados correctamente para permitir la migraci\u00f3n. - Ejecuta el siguiente comando desde el host origen:</p> <pre><code>$ virsh migrate --live &lt;nombreMV&gt; qemu+ssh://user@destination/system\n</code></pre> <ul> <li>Verifica que la MV sigue ejecut\u00e1ndose en el host destino con virsh list.</li> </ul> <p>Objetivo: Ejecutar una migraci\u00f3n en vivo para mejorar la disponibilidad y el mantenimiento de sistemas.</p> <p>\u00a1 OJO !: Antes de realizar la migraci\u00f3n en vivo, aseg\u00farate de que los siguientes aspectos est\u00e1n configurados correctamente en ambos hosts (origen y destino):</p> <ul> <li>Ambos hosts deben usar KVM/QEMU con libvirt.</li> <li>SSH sin contrase\u00f1a: Configura la autenticaci\u00f3n sin contrase\u00f1a entre el host origen y destino mediante claves SSH.</li> <li>Almacenamiento compartido o accesible: Aseg\u00farate de que el almacenamiento de la m\u00e1quina virtual (im\u00e1genes de disco) est\u00e1 accesible desde ambos hosts (por ejemplo, a trav\u00e9s de NFS, iSCSI, etc.). La migraci\u00f3n en vivo requiere que los archivos de disco de la VM sean accesibles desde el host de destino.</li> <li>Ambos hosts deben tener las mismas versiones de QEMU/KVM y libvirt para asegurar la compatibilidad.</li> </ul>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/#ejercicio-6-uso-de-snapshots-en-mvs","title":"Ejercicio 6: Uso de Snapshots en MVs","text":"<p>Tarea: Crear un snapshot de una m\u00e1quina virtual en funcionamiento y restaurarla a ese punto despu\u00e9s de realizar cambios en el sistema operativo. Instrucciones:</p> <ul> <li>Para crear un snapshot:</li> </ul> <pre><code>$virsh snapshot-create-as --domain &lt;nombreMV&gt; --name \"snapshot1\" --description \"Estado limpio antes de actualizaciones\"\n</code></pre> <p>Realiza algunos cambios en la MV, como instalar software o modificar configuraciones. Restaura el estado anterior usando:</p> <pre><code>virsh snapshot-revert &lt;nombreMV&gt; snapshot1\n</code></pre> <p>Objetivo: Aprender a utilizar snapshots para la recuperaci\u00f3n r\u00e1pida de MVs.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/#ejercicio-7-configuracion-de-nat-en-la-red-virtual","title":"Ejercicio 7: Configuraci\u00f3n de NAT en la Red Virtual","text":"<p>Tarea: Configurar NAT para las m\u00e1quinas virtuales, permitiendo que accedan a Internet a trav\u00e9s del host.</p> <p>Instrucciones:</p> <ul> <li>Edita el archivo de red default con el siguiente comando:</li> </ul> <pre><code>virsh net-edit default\n</code></pre> <ul> <li>Configura el modo de red en NAT, verificando la conectividad de la MV hacia el exterior.</li> </ul> <p>Usa <code>ping</code> desde la MV para verificar que puede acceder a Internet.</p> <p>Objetivo: Configurar redes virtuales para conectar MVs con redes externas.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/#ejercicio-8-creacion-de-una-maquina-virtual-con-virt-manager","title":"Ejercicio 8: Creaci\u00f3n de una M\u00e1quina Virtual con Virt-Manager","text":"<p>Tarea: Utiliza la interfaz gr\u00e1fica virt-manager para crear una m\u00e1quina virtual Windows 10 con 4GB de RAM y un disco de 20GB. Instrucciones:</p> <ul> <li>Abre virt-manager y selecciona la opci\u00f3n para crear una nueva m\u00e1quina.</li> <li>Sigue las instrucciones para elegir la imagen de instalaci\u00f3n y configurar los recursos de la m\u00e1quina.</li> <li>Inicia la instalaci\u00f3n de Windows desde la interfaz gr\u00e1fica.</li> </ul> <p>Objetivo: Familiarizarse con la administraci\u00f3n de MVs desde la interfaz gr\u00e1fica.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/#ejercicio-9-clonacion-de-una-maquina-virtual","title":"Ejercicio 9: Clonaci\u00f3n de una M\u00e1quina Virtual","text":"<p>Tarea: Clona una m\u00e1quina virtual existente y c\u00e1mbiale el nombre y la direcci\u00f3n MAC de la interfaz de red. Instrucciones:</p> <ul> <li>Ejecuta el comando:</li> </ul> <pre><code>$ virt-clone --original &lt;nombreMV&gt; --name &lt;nombreClon&gt; --file /var/lib/libvirt/images/&lt;nombreClon&gt;.qcow2\n</code></pre> <p>Edita la direcci\u00f3n MAC para evitar conflictos de red:</p> <pre><code>$ virsh edit &lt;nombreClon&gt;\n</code></pre> <ul> <li>Busca la secci\u00f3n de la interfaz de red y cambia el valor de la direcci\u00f3n MAC.</li> </ul> <p>Objetivo: Dominar la clonaci\u00f3n y personalizaci\u00f3n de m\u00e1quinas virtuales.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/#ejercicio-10-implementacion-de-contenedores-lxc","title":"Ejercicio 10: Implementaci\u00f3n de Contenedores LXC","text":"<p>Tarea: Crear un contenedor LXC en el entorno KVM, configurando las capacidades de red compartida con el host. Instrucciones: - Instala LXC con sudo apt install lxc. - Crea un contenedor b\u00e1sico:</p> <pre><code>lxc-create -n mycontainer -t ubuntu\n</code></pre> <ul> <li>Configura el acceso a la red compartida entre el contenedor y el host.</li> <li>Inicia el contenedor con lxc-start.</li> </ul> <p>Objetivo: Integrar la tecnolog\u00eda de contenedores dentro del entorno de virtualizaci\u00f3n KVM.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/01.-Instrucciones%20para%20la%20captura/","title":"01.-Instrucciones para la captura","text":""},{"location":"00.-KVM/10.-Pr%C3%A1cticas/01.-Instrucciones%20para%20la%20captura/#ejercicio-1-verificacion-del-soporte-de-virtualizacion-en-el-host","title":"Ejercicio 1: Verificaci\u00f3n del soporte de virtualizaci\u00f3n en el host","text":"<p>Instrucciones para la captura:</p> <ol> <li> <p>Abre una terminal en tu sistema Linux.</p> </li> <li> <p>Ejecuta el comando: <code>bash    egrep -c '(vmx|svm)' /proc/cpuinfo</code></p> </li> <li> <p>Aseg\u00farate de que el resultado del comando sea visible en la terminal.</p> </li> <li> <p>Haz una captura de pantalla mostrando claramente la terminal con el comando ejecutado y el resultado visible.</p> </li> </ol>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/01.-Instrucciones%20para%20la%20captura/#ejercicio-2-instalacion-de-kvm-y-herramientas-de-virtualizacion","title":"Ejercicio 2: Instalaci\u00f3n de KVM y herramientas de virtualizaci\u00f3n","text":"<p>Instrucciones para la captura:</p> <ol> <li> <p>Abre una terminal.</p> </li> <li> <p>Ejecuta el siguiente comando para mostrar que los paquetes necesarios est\u00e1n instalados:     <code>bash    dpkg -l | grep -E 'qemu-kvm|libvirt-bin|virt-manager'</code></p> </li> <li> <p>Aseg\u00farate de que la salida de los paquetes instalados se vea completa en la terminal.</p> </li> <li> <p>Haz una captura de pantalla mostrando el resultado en la terminal con el comando ejecutado.</p> </li> </ol>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/01.-Instrucciones%20para%20la%20captura/#ejercicio-3-creacion-de-una-maquina-virtual-desde-la-cli","title":"Ejercicio 3: Creaci\u00f3n de una m\u00e1quina virtual desde la CLI","text":"<p>Instrucciones para la captura:</p> <ol> <li> <p>Tras haber creado la m\u00e1quina virtual usando el comando <code>virt-install</code>, abre una terminal.</p> </li> <li> <p>Ejecuta el comando para listar las m\u00e1quinas virtuales:    <code>bash    virsh list --all</code></p> </li> <li> <p>Aseg\u00farate de que el nombre de la MV que has creado est\u00e9 en la lista.</p> </li> <li> <p>Haz una captura de pantalla de la terminal mostrando el comando y la salida con la MV visible.</p> </li> </ol>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/01.-Instrucciones%20para%20la%20captura/#ejercicio-4-creacion-de-un-disco-virtual-adicional-para-una-mv-existente","title":"Ejercicio 4: Creaci\u00f3n de un disco virtual adicional para una MV existente","text":"<p>Instrucciones para la captura:</p> <ol> <li> <p>Abre una terminal y ejecuta el siguiente comando para verificar que el segundo disco ha sido a\u00f1adido correctamente:    <code>bash    virsh domblklist &lt;nombreMV&gt;</code></p> </li> <li> <p>Aseg\u00farate de que la salida muestre tanto el disco principal como el disco adicional (<code>vdb</code>).</p> </li> <li> <p>Haz una captura de pantalla de la terminal con el comando ejecutado y los discos listados.</p> </li> </ol>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/01.-Instrucciones%20para%20la%20captura/#ejercicio-5-migracion-en-vivo-de-una-mv-a-otro-host-opcional","title":"Ejercicio 5: Migraci\u00f3n en vivo de una MV a otro host (Opcional)","text":"<p>Instrucciones para la captura:</p> <ol> <li> <p>Realiza la migraci\u00f3n en vivo de la MV a otro host.</p> </li> <li> <p>En el host de origen, ejecuta el comando:    <code>bash    virsh list --all</code></p> </li> <li> <p>Aseg\u00farate de que la MV ya no est\u00e9 en la lista del host de origen.</p> </li> <li> <p>En el host de destino, ejecuta el mismo comando <code>virsh list --all</code> y aseg\u00farate de que la MV aparece en la lista.</p> </li> <li> <p>Haz una captura de pantalla de ambas terminales (host origen y host destino) mostrando la migraci\u00f3n completada.</p> </li> </ol>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/01.-Instrucciones%20para%20la%20captura/#ejercicio-6-uso-de-snapshots-en-mvs","title":"Ejercicio 6: Uso de Snapshots en MVs","text":"<p>Instrucciones para la captura:</p> <ol> <li> <p>Tras crear el snapshot, ejecuta el siguiente comando para listar los snapshots de la m\u00e1quina virtual:    <code>bash    virsh snapshot-list &lt;nombreMV&gt;</code></p> </li> <li> <p>Aseg\u00farate de que el snapshot creado est\u00e9 en la lista.</p> </li> <li> <p>Haz una captura de pantalla de la terminal con el comando ejecutado y el snapshot visible.</p> </li> </ol>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/01.-Instrucciones%20para%20la%20captura/#ejercicio-7-configuracion-de-nat-en-la-red-virtual","title":"Ejercicio 7: Configuraci\u00f3n de NAT en la Red Virtual","text":"<p>Instrucciones para la captura:</p> <ol> <li> <p>Abre una terminal y edita la red predeterminada con el comando:    <code>bash    virsh net-edit default</code></p> </li> <li> <p>Captura la ventana mostrando la configuraci\u00f3n de la red en modo de edici\u00f3n.</p> </li> <li> <p>Luego, ejecuta el comando:    <code>bash    virsh net-list</code></p> </li> <li> <p>Aseg\u00farate de que la red NAT est\u00e9 activa.</p> </li> <li> <p>Haz una captura de pantalla mostrando la configuraci\u00f3n y el estado de la red.</p> </li> </ol>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/01.-Instrucciones%20para%20la%20captura/#ejercicio-8-creacion-de-una-mv-con-virt-manager","title":"Ejercicio 8: Creaci\u00f3n de una MV con Virt-Manager","text":"<p>Instrucciones para la captura:</p> <ol> <li> <p>Abre <code>virt-manager</code> y navega hasta la m\u00e1quina virtual que creaste con esta herramienta.</p> </li> <li> <p>Muestra la ventana de la MV donde se vea su nombre, los recursos asignados (RAM, disco, etc.), y que est\u00e1 en ejecuci\u00f3n.</p> </li> <li> <p>Haz una captura de pantalla de la interfaz de <code>virt-manager</code> con estos detalles visibles.</p> </li> </ol>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/01.-Instrucciones%20para%20la%20captura/#ejercicio-9-clonacion-de-una-maquina-virtual","title":"Ejercicio 9: Clonaci\u00f3n de una M\u00e1quina Virtual","text":"<p>Instrucciones para la captura:</p> <ol> <li> <p>Despu\u00e9s de haber clonado la MV, ejecuta en una terminal:    <code>bash    virsh list --all</code></p> </li> <li> <p>Aseg\u00farate de que tanto la m\u00e1quina original como el clon est\u00e1n en la lista, mostrando claramente los dos nombres.</p> </li> <li> <p>Haz una captura de pantalla de la terminal con ambos nombres de m\u00e1quinas visibles.</p> </li> </ol>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/01.-Instrucciones%20para%20la%20captura/#ejercicio-10-implementacion-de-contenedores-lxc","title":"Ejercicio 10: Implementaci\u00f3n de Contenedores LXC","text":"<p>Instrucciones para la captura:</p> <ol> <li> <p>Despu\u00e9s de crear el contenedor LXC, ejecuta el siguiente comando para verificar que el contenedor est\u00e1 en funcionamiento:    <code>bash    lxc-ls --fancy</code></p> </li> <li> <p>Aseg\u00farate de que el contenedor que has creado est\u00e9 listado con su nombre y estado.</p> </li> <li> <p>Haz una captura de pantalla mostrando el comando y la lista de contenedores.</p> </li> </ol>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/","title":"02.-Solucionario","text":""},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#ejercicio-1-verificacion-del-soporte-de-virtualizacion-en-el-host","title":"Ejercicio 1: Verificaci\u00f3n del soporte de virtualizaci\u00f3n en el host","text":"<ul> <li> <p>Abro una terminal en el host.</p> </li> <li> <p>Ejecuto el comando:</p> </li> </ul> <pre><code>egrep -c '(vmx|svm)' /proc/cpuinfo\n</code></pre> <p>Resultado:  </p> <pre><code>2\n</code></pre> <p>Esto indica que la CPU del host soporta virtualizaci\u00f3n por hardware.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#ejercicio-2-instalacion-de-kvm-y-herramientas-de-virtualizacion","title":"Ejercicio 2: Instalaci\u00f3n de KVM y herramientas de virtualizaci\u00f3n","text":"<ul> <li>Abro una terminal en el host.</li> <li>Ejecuto los siguientes comandos para instalar KVM y las herramientas necesarias:</li> </ul> <pre><code>sudo apt update\nsudo apt upgrade\nsudo apt install qemu-system libvirt-clients libvirt-daemon-system\n\n</code></pre> <p>Resultado:  </p> <p>KVM y <code>virt-manager</code> est\u00e1n instalados exitosamente.</p> <ul> <li>Verifico que el servicio de <code>libvirtd</code> est\u00e1 activo:</li> </ul> <pre><code>sudo systemctl status libvirtd\n</code></pre> <p>Resultado: El servicio de <code>libvirtd</code> est\u00e1 corriendo y habilitado.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#ejercicio-3-creacion-de-una-maquina-virtual-desde-la-cli","title":"Ejercicio 3: Creaci\u00f3n de una m\u00e1quina virtual desde la CLI","text":"<ul> <li>Descargo una imagen ISO de Ubuntu Server.</li> <li>Creo una m\u00e1quina virtual desde la CLI usando el siguiente comando:</li> </ul> <pre><code>sudo virt-install \\\n  --name UbuntuVM \\\n  --ram 2048 \\\n  --vcpus 2 \\\n  --disk path=/var/lib/libvirt/images/ubuntu.qcow2,size=10 \\\n  --cdrom /home/tu_usuario/Descargas/ubuntu-20.04.iso \\\n  --os-variant ubuntu20.04 \\\n  --network bridge=virbr0 \\\n  --graphics none \\\n  --console pty,target_type=serial \\\n  --extra-args 'console=ttyS0,115200n8 serial'\n</code></pre> <ul> <li>Verifico que la MV est\u00e1 creada:</li> </ul> <pre><code>$ virsh list --all\n</code></pre> <p>Resultado: La m\u00e1quina virtual <code>UbuntuVM</code> aparece en la lista con el estado apagada o running si se ha iniciado correctamente.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#ejercicio-4-creacion-de-un-disco-virtual-adicional-para-una-mv-existente","title":"Ejercicio 4: Creaci\u00f3n de un disco virtual adicional para una MV existente","text":"<ul> <li>Detengo la m\u00e1quina virtual:</li> </ul> <pre><code>virsh shutdown UbuntuVM\n</code></pre> <ul> <li>Crear un Disco Virtual con <code>qemu-img</code> y A\u00f1adirlo con <code>virsh</code></li> </ul> <pre><code>qemu-img create -f qcow2 /var/lib/libvirt/images/disk1.qcow2 5G\n</code></pre> <ul> <li>Edici\u00f3n del archivo XML de la MV para agregar un segundo disco:</li> </ul> <pre><code>virsh edit UbuntuVM\n</code></pre> <ul> <li>Agrego el siguiente bloque XML para el disco adicional:</li> </ul> <pre><code>&lt;disk type='file' device='disk'&gt;\n  &lt;driver name='qemu' type='qcow2'/&gt;\n  &lt;source file='/var/lib/libvirt/images/disk1.qcow2'/&gt;\n  &lt;target dev='vdb' bus='virtio'/&gt;\n&lt;/disk&gt;\n</code></pre> <ul> <li>Tambi\u00e9n se puede hacer la asociaci\u00f3n usando el comando <code>virsh-attach-disk</code>del siguiente modo:</li> </ul> <pre><code>virsh attach-disk &lt;nombre-de-la-vm&gt; /var/lib/libvirt/images/disk1.qcow2 vdb --targetbus virtio --persistent\n</code></pre> <ul> <li>Inicio la MV de nuevo:</li> </ul> <pre><code>virsh start UbuntuVM\n</code></pre> <ul> <li>Verifico los discos conectados:</li> </ul> <pre><code>virsh domblklist UbuntuVM\n</code></pre> <p>Resultado: La MV muestra los discos conectados, incluyendo <code>vda</code> (disco original) y <code>vdb</code> (nuevo disco).</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#nota-aclaratoria","title":"Nota Aclaratoria:","text":"<ul> <li>\u00bfPor qu\u00e9 <code>virsh edit</code> abre un archivo ubicado en el directorio <code>/tmp</code>?</li> </ul> <p>Cuando ejecutas el comando:</p> <pre><code>virsh edit ubuntu_server\n</code></pre> <p>virsh realiza lo siguiente:</p> <ul> <li>Generaci\u00f3n del Archivo Temporal: Crea una copia de la configuraci\u00f3n XML actual de la m\u00e1quina virtual ubuntu_server en un archivo temporal dentro de /tmp. Esto permite que realices modificaciones sin afectar directamente el archivo de configuraci\u00f3n original.</li> <li>Edici\u00f3n de la Configuraci\u00f3n: Abre el archivo temporal en tu editor de texto predeterminado (como vi, nano, etc.). Aqu\u00ed puedes realizar los cambios que consideres necesarios.</li> <li>Validaci\u00f3n y Aplicaci\u00f3n de Cambios: Al guardar y cerrar el editor, virsh valida la sintaxis del XML modificado. Si la validaci\u00f3n es exitosa, libvirt aplica los cambios a la configuraci\u00f3n persistente de la m\u00e1quina virtual. El archivo temporal en /tmp se descarta autom\u00e1ticamente.</li> </ul>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#ejercicio-5-migracion-en-vivo-de-una-mv-a-otro-host","title":"Ejercicio 5: Migraci\u00f3n en vivo de una MV a otro host","text":""},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#configurar-la-autenticacion-ssh-sin-contrasena","title":"Configurar la Autenticaci\u00f3n SSH sin Contrase\u00f1a","text":"<ul> <li> <p>Primero, aseg\u00farate de que puedes acceder al host de destino desde el host de origen mediante SSH sin contrase\u00f1a.</p> </li> <li> <p>Genera una clave SSH en el host de origen (si no la tienes):</p> </li> </ul> <pre><code>ssh-keygen\n</code></pre> <ul> <li>Copia la clave p\u00fablica al host de destino:</li> </ul> <pre><code>ssh-copy-id user@destination_host\n</code></pre> <ul> <li>Ahora deber\u00edas poder conectarte al host de destino desde el host de origen sin que se te solicite una contrase\u00f1a.</li> </ul>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#verificar-que-el-almacenamiento-es-compartido-o-accesible","title":"Verificar que el Almacenamiento es Compartido o Accesible","text":"<ul> <li>Aseg\u00farate de que el almacenamiento de la m\u00e1quina virtual, como los discos virtuales (im\u00e1genes .qcow2, .img, etc.), es accesible por ambos hosts. Para ello, utiliza un sistema de archivos compartido como NFS o iSCSI.</li> </ul>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#verificar-que-los-hosts-estan-preparados-para-la-migracion","title":"Verificar que los Hosts est\u00e1n Preparados para la Migraci\u00f3n","text":"<ul> <li>En ambos hosts, verifica que el servicio libvirtd est\u00e9 ejecut\u00e1ndose:</li> </ul> <pre><code>sudo systemctl status libvirtd\n</code></pre> <ul> <li> <p>Tambi\u00e9n aseg\u00farate de que las m\u00e1quinas virtuales est\u00e1n accesibles mediante virsh list.</p> </li> <li> <p>En el host de origen, ejecuto:</p> </li> </ul> <pre><code>virsh migrate --live UbuntuVM qemu+ssh://user@destination/system\n</code></pre>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#verificar-que-la-mv-ha-sido-migrada-correctamente","title":"Verificar que la MV ha sido migrada correctamente","text":"<ul> <li>En el host de origen:   <code>bash   virsh list --all</code> Resultado:   La MV no aparece en el host de origen.</li> <li>En el host de destino:   <code>bash   virsh list --all</code> Resultado:   La MV <code>UbuntuVM</code> aparece en el host de destino y est\u00e1 corriendo.</li> </ul>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#ejercicio-6-uso-de-snapshots-en-mvs","title":"Ejercicio 6: Uso de Snapshots en MVs","text":"<ul> <li>Creo un snapshot de la m\u00e1quina virtual:</li> </ul> <pre><code>virsh snapshot-create-as --domain UbuntuVM --name \"snapshot1\" --description \"Estado limpio antes de actualizaciones\"\n</code></pre> <ul> <li>Listo los snapshots creados:</li> </ul> <pre><code>virsh snapshot-list UbuntuVM\n</code></pre> <p>Resultado: El snapshot <code>snapshot1</code> aparece en la lista. - Realizo algunos cambios en el sistema. - Restaura el snapshot:</p> <pre><code>virsh snapshot-revert UbuntuVM snapshot1\n</code></pre> <p>Resultado: La MV se ha revertido al estado del snapshot.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#ejercicio-7-configuracion-de-nat-en-la-red-virtual","title":"Ejercicio 7: Configuraci\u00f3n de NAT en la Red Virtual","text":"<ul> <li>Edito la configuraci\u00f3n de la red predeterminada:</li> </ul> <pre><code>virsh net-edit default\n</code></pre> <ul> <li>Verifico que la red est\u00e1 configurada en modo NAT.</li> <li>Verifico que la red est\u00e1 activa:</li> </ul> <pre><code>virsh net-list\n</code></pre> <p>Resultado: La red <code>default</code> est\u00e1 activa y las m\u00e1quinas virtuales pueden acceder a Internet a trav\u00e9s de NAT.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#ejercicio-8-creacion-de-una-mv-con-virt-manager","title":"Ejercicio 8: Creaci\u00f3n de una MV con Virt-Manager","text":"<ul> <li>Abro <code>virt-manager</code>.</li> <li>Creo una nueva m\u00e1quina virtual seleccionando la imagen ISO de Windows 10, asignando 4GB de RAM y un disco de 20GB.</li> <li>Inicio la instalaci\u00f3n y sigo las instrucciones.</li> <li>Verifico que la MV est\u00e1 creada y en ejecuci\u00f3n en <code>virt-manager</code>.</li> </ul>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#ejercicio-9-clonacion-de-una-maquina-virtual","title":"Ejercicio 9: Clonaci\u00f3n de una M\u00e1quina Virtual","text":"<ul> <li>Clono la MV <code>UbuntuVM</code>:</li> </ul> <pre><code>virt-clone --original UbuntuVM --name UbuntuClone --file /var/lib/libvirt/images/UbuntuClone.qcow2\n</code></pre> <ul> <li>Verifico que tanto la m\u00e1quina original como el clon est\u00e1n presentes:</li> </ul> <pre><code>virsh list --all\n</code></pre> <p>Resultado: Ambas m\u00e1quinas (<code>UbuntuVM</code> y <code>UbuntuClone</code>) aparecen en la lista.</p>"},{"location":"00.-KVM/10.-Pr%C3%A1cticas/02.-Solucionario/#ejercicio-10-implementacion-de-contenedores-lxc","title":"Ejercicio 10: Implementaci\u00f3n de Contenedores LXC","text":"<ul> <li>Creo un contenedor LXC en el entorno KVM:</li> </ul> <pre><code>lxc-create -n mycontainer -t ubuntu\n</code></pre> <ul> <li>Inicio el contenedor:</li> </ul> <pre><code>lxc-start -n mycontainer\n</code></pre> <ul> <li>Verifico que el contenedor est\u00e1 en ejecuci\u00f3n:</li> </ul> <pre><code>lxc-ls --fancy\n</code></pre> <p>Resultado: El contenedor <code>mycontainer</code> aparece en la lista y est\u00e1 corriendo.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/","title":"Index","text":"<p>Esta unidad introductoria ofrece los fundamentos clave de la seguridad inform\u00e1tica y la ciberseguridad, incluyendo la terminolog\u00eda b\u00e1sica y los conceptos esenciales del hacking \u00e9tico. Se exploran los diferentes tipos de auditor\u00edas de seguridad y las amenazas que pueden comprometer un sistema inform\u00e1tico. Los objetivos de la unidad son reconocer la importancia de la seguridad inform\u00e1tica, familiarizarse con las auditor\u00edas, comprender las fases y metodolog\u00edas de un test de intrusi\u00f3n (Pentest), y utilizar retos CTF como herramienta de autoaprendizaje. El contenido cubre la historia de la seguridad inform\u00e1tica, los conceptos b\u00e1sicos de ciberseguridad, las amenazas, las pruebas de intrusi\u00f3n, una gu\u00eda para convertirse en hacker \u00e9tico y un laboratorio de pr\u00e1cticas para aplicar los conocimientos adquiridos.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/01.-Historia%20del%20hacking/","title":"01.-Historia del hacking","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/01.-Historia%20del%20hacking/#historia-del-hacking","title":"Historia del hacking","text":"<p>El t\u00e9rmino hack en ingl\u00e9s se refiere a una soluci\u00f3n r\u00e1pida e ingeniosa para resolver un problema, y de esta noci\u00f3n nacen los primeros hackers. Estos pioneros de la inform\u00e1tica eran principalmente estudiantes e ingenieros que, en los inicios de la computaci\u00f3n, se esforzaban por mejorar y optimizar las tecnolog\u00edas existentes, siempre buscando maneras creativas de enfrentar los desaf\u00edos t\u00e9cnicos que surg\u00edan. A medida que la tecnolog\u00eda evolucionaba, tambi\u00e9n lo hac\u00eda la curiosidad de estos individuos, quienes se dedicaban no solo a resolver problemas, sino a profundizar en los sistemas inform\u00e1ticos para entender su funcionamiento, desarmarlos y buscar sus limitaciones. En esta \u00e9poca, se pod\u00eda acceder a Internet a trav\u00e9s de costosas y lentas l\u00edneas telef\u00f3nicas, mientras que las universidades ya dispon\u00edan de redes m\u00e1s avanzadas y potentes, lo que foment\u00f3 un entorno en el que estos primeros hackers pod\u00edan experimentar con tecnolog\u00edas de vanguardia.</p> <p>A finales de los a\u00f1os 60 y principios de los 70 surge el phreaking, una pr\u00e1ctica que consist\u00eda en piratear las redes telef\u00f3nicas para realizar llamadas gratuitas o conectarse a Internet sin restricciones. Estos primeros hackers no solo buscaban conocimiento por curiosidad, sino que se involucraban en pr\u00e1cticas que, si bien no buscaban hacer da\u00f1o, s\u00ed eran consideradas ilegales por las grandes compa\u00f1\u00edas de telecomunicaciones, lo que los llev\u00f3 a moverse en entornos ocultos, foros privados y chats clandestinos. Esto marc\u00f3 el nacimiento de una subcultura underground en la que los j\u00f3venes se ocultaban tras pseud\u00f3nimos o nicknames. En muchos casos, los hackers fueron detenidos y encarcelados, pero algunos de ellos, tras cumplir sus penas, terminaron trabajando para grandes corporaciones o fundando sus propias empresas tecnol\u00f3gicas.</p> <p>Un caso emblem\u00e1tico es el de Loyd Blankenship, conocido como The Mentor, quien fue miembro de la segunda generaci\u00f3n del grupo Legion of Doom. Tras ser detenido en 1986, escribi\u00f3 un art\u00edculo titulado The Conscience of a Hacker, m\u00e1s conocido como el Manifiesto Hacker, en la revista online Phrack. En este manifiesto, Blankenship expone las motivaciones \u00e9ticas detr\u00e1s del hacking y argumenta que las acciones de los hackers no deb\u00edan considerarse ilegales, sino como un ejercicio de curiosidad intelectual. El manifiesto concluye que, aunque la sociedad vea a los hackers como delincuentes, su verdadera motivaci\u00f3n es la b\u00fasqueda de conocimiento.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/01.-Historia%20del%20hacking/#historia-del-hacking-en-espana","title":"Historia del hacking en Espa\u00f1a","text":"<p>La historia del hacking en Espa\u00f1a sigue una evoluci\u00f3n similar a la global, con la formaci\u00f3n de grupos de hackers que investigaban y compart\u00edan sus conocimientos sobre ingenier\u00eda social, virus y t\u00e9cnicas de hacking. Esta historia ha sido documentada en el libro de Merc\u00e8 Molist Historia del hacking en Espa\u00f1a, donde se narran las actividades de los primeros grupos de hackers en la pen\u00ednsula y sus acciones m\u00e1s relevantes. El libro tambi\u00e9n aborda las rivalidades y tensiones internas que llevaron a la divisi\u00f3n o disoluci\u00f3n de algunos de estos grupos, as\u00ed como a enfrentamientos que terminaron con ataques entre ellos o denuncias que derivaron en encarcelamientos. Es una lectura esencial para aquellos interesados en conocer los or\u00edgenes del hacking en Espa\u00f1a y su influencia en la ciberseguridad actual. El libro est\u00e1 disponible de forma gratuita en la web Hackstory.es.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/01.-Historia%20del%20hacking/#hackers-famosos","title":"Hackers famosos","text":"<p>A lo largo de la historia, varios hackers han ganado notoriedad por sus acciones. A continuaci\u00f3n, se mencionan algunos de los m\u00e1s influyentes:</p> <ul> <li>John T. Draper (Captain Crunch): Se hizo famoso en la d\u00e9cada de 1970 por utilizar un silbato que se regalaba en las cajas de cereales Cap\u2019n Crunch para realizar llamadas telef\u00f3nicas gratuitas. Draper descubri\u00f3 que las l\u00edneas telef\u00f3nicas de AT&amp;T utilizaban una se\u00f1al de 2600 Hz para liberar la l\u00ednea, y que el silbato emit\u00eda esa misma frecuencia. Aprovech\u00f3 esta vulnerabilidad para manipular el sistema y hacer llamadas sin coste. Posteriormente, trabaj\u00f3 para Apple desarrollando un dispositivo para conectar el Apple II a las l\u00edneas telef\u00f3nicas.</li> <li>Vladimir Levin: Un hacker ruso famoso por llevar a cabo uno de los primeros robos de banco a trav\u00e9s de Internet. En 1995, accedi\u00f3 a los sistemas de Citibank y realiz\u00f3 transferencias fraudulentas por valor de 10 millones de d\u00f3lares. Fue arrestado por la Interpol en el aeropuerto de Heathrow y condenado por sus cr\u00edmenes.</li> <li>Kevin Poulsen (Dark Dante): Conocido por sus habilidades en phreaking, Poulsen manipul\u00f3 las llamadas telef\u00f3nicas de concursos para asegurarse de ganar los premios. Fue detenido por el FBI y, tras cumplir su condena, se dedic\u00f3 al periodismo especializado en ciberseguridad. Trabaj\u00f3 en la firma SecurityFocus, que luego fue adquirida por Symantec, y se convirti\u00f3 en editor principal de la revista Wired.</li> <li>Kevin Mitnick: Uno de los hackers m\u00e1s famosos de todos los tiempos. Mitnick fue arrestado por hackear los sistemas de la NASA y el Departamento de Defensa de Estados Unidos. Despu\u00e9s de cumplir su condena, fund\u00f3 la empresa de ciberseguridad Mitnick Security y escribi\u00f3 varios libros, incluyendo El Arte de la Intrusi\u00f3n y El Arte de la Invisibilidad, ambos lecturas recomendadas para cualquier persona interesada en la seguridad inform\u00e1tica.</li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/01.-Historia%20del%20hacking/#ciberdelincuencia-en-la-actualidad","title":"Ciberdelincuencia en la actualidad","text":"<p>La ciberdelincuencia ha aumentado significativamente en los \u00faltimos a\u00f1os, en especial con el auge del teletrabajo durante la pandemia de COVID-19. Los ataques m\u00e1s comunes incluyen fraudes inform\u00e1ticos, ataques de ransomware y hackeos a grandes corporaciones y organismos gubernamentales. Estos ataques paralizan las actividades de las empresas al cifrar su informaci\u00f3n y exigen pagos para liberar los datos secuestrados. Muchas empresas optan por pagar el rescate debido a la falta de planes de seguridad adecuados, lo que perpet\u00faa este tipo de ataques.</p> <p>El caso del hackeo a Twitch en 2021 es un ejemplo reciente de este tipo de delitos, en el que se filtraron 125 GB de datos, incluidos el c\u00f3digo fuente de la plataforma y los ingresos de los creadores de contenido. Otro caso significativo fue el ataque de ransomware al CSIC (Consejo Superior de Investigaciones Cient\u00edficas) en 2022, el cual fue atribuido a actores rusos. Afortunadamente, en este ataque no se perdi\u00f3 informaci\u00f3n cr\u00edtica.</p> <p>M\u00e1s grave fue el ataque con el software esp\u00eda Pegasus a los tel\u00e9fonos de miembros del Gobierno de Espa\u00f1a, incluyendo al Presidente y a la Ministra de Defensa, lo que pudo haber comprometido m\u00e1s de 2 GB de informaci\u00f3n sensible.</p> <p>Los delitos inform\u00e1ticos, como se muestra en las estad\u00edsticas del Observatorio Espa\u00f1ol de Delitos Inform\u00e1ticos, han crecido de manera alarmante, en especial los fraudes inform\u00e1ticos, que se multiplicaron por siete entre 2016 y 2021. Este aumento tambi\u00e9n ha generado una mayor demanda de profesionales en ciberseguridad, aunque la oferta de especialistas no ha crecido al mismo ritmo. Seg\u00fan el INCIBE, en 2024 se necesitar\u00e1n m\u00e1s de 83,000 profesionales en el sector.</p> <p>Finalmente, la protecci\u00f3n de los datos personales ha cobrado una importancia crucial para las empresas. La Agencia Espa\u00f1ola de Protecci\u00f3n de Datos (AEPD) impone multas millonarias a aquellas organizaciones que no protejan adecuadamente la informaci\u00f3n, y en 2021 las sanciones aumentaron un 521% en toda Europa, superando los 1,000 millones de euros en total.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/02.-Conceptos%20b%C3%A1sicos%20de%20la%20seguridad%20de%20la%20informaci%C3%B3n/","title":"02.-Conceptos b\u00e1sicos de la seguridad de la informaci\u00f3n","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/02.-Conceptos%20b%C3%A1sicos%20de%20la%20seguridad%20de%20la%20informaci%C3%B3n/#conceptos-basicos","title":"Conceptos b\u00e1sicos","text":"<p>La seguridad de la informaci\u00f3n es el conjunto de medidas de prevenci\u00f3n, detecci\u00f3n y correcci\u00f3n para proteger la confidencialidad, integridad y disponibilidad de la informaci\u00f3n. Estos tres principios se conocen como principios de la seguridad de la informaci\u00f3n.</p> <p>Las medidas para proteger la informaci\u00f3n se conocen como seguridad defensiva, mientras que las t\u00e9cnicas para vulnerar controles se conocen como seguridad ofensiva. Grandes empresas suelen tener equipos defensivos y ofensivos que compiten para mejorar la seguridad.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/02.-Conceptos%20b%C3%A1sicos%20de%20la%20seguridad%20de%20la%20informaci%C3%B3n/#principios-de-la-seguridad-de-la-informacion","title":"Principios de la seguridad de la informaci\u00f3n","text":"<ul> <li>Confidencialidad: garantiza que la informaci\u00f3n solo sea conocida por personas autorizadas.</li> <li>Integridad: asegura que la informaci\u00f3n no sea alterada sin permiso.</li> <li>Disponibilidad: garantiza el acceso inmediato e ininterrumpido a la informaci\u00f3n.</li> </ul> <p>Otros principios:</p> <ul> <li>Autenticaci\u00f3n: garantiza la identidad del creador de la informaci\u00f3n mediante factores como biometr\u00eda, contrase\u00f1as o tarjetas.</li> <li>No repudio: impide que el emisor o receptor nieguen la transmisi\u00f3n de informaci\u00f3n.</li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/02.-Conceptos%20b%C3%A1sicos%20de%20la%20seguridad%20de%20la%20informaci%C3%B3n/#clasificacion-de-las-medidas-de-seguridad","title":"Clasificaci\u00f3n de las medidas de seguridad","text":"<ul> <li>Seguridad activa: previene da\u00f1os, como controles de acceso y cortafuegos.</li> <li>Seguridad pasiva: repara da\u00f1os ya producidos, como copias de seguridad y sistemas SAI.</li> <li>Seguridad f\u00edsica: protege el hardware de amenazas como incendios o robos.</li> <li>Seguridad l\u00f3gica: protege software y datos de amenazas como malware y ataques DoS.</li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/02.-Conceptos%20b%C3%A1sicos%20de%20la%20seguridad%20de%20la%20informaci%C3%B3n/#hacking-definicion-y-aspectos-legales","title":"Hacking: definici\u00f3n y aspectos legales","text":"<p>La RAE define \"hacker\" como:</p> <ul> <li>Pirata inform\u00e1tico: persona que accede ilegalmente a sistemas ajenos.</li> <li>Persona con habilidades inform\u00e1ticas: investiga sistemas para avisar de fallos y desarrollar mejoras.</li> </ul> <p>Definici\u00f3n de la palabra hacker por la RAE.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/02.-Conceptos%20b%C3%A1sicos%20de%20la%20seguridad%20de%20la%20informaci%C3%B3n/#tipos-de-hackers","title":"Tipos de hackers","text":"<ul> <li>Sombrero blanco: mejora la seguridad encontrando vulnerabilidades y notific\u00e1ndolas.</li> <li>Sombrero negro: usa sus conocimientos para prop\u00f3sitos negativos.</li> <li>Sombrero gris: act\u00faa entre el bien y el mal, como hacktivistas o aquellos que dejan \"puertas traseras\".</li> <li>Script kiddies: sin conocimientos profundos, atacan sistemas usando herramientas creadas por hackers.</li> </ul> <p>En Espa\u00f1a, el c\u00f3digo penal (art\u00edculos 197 a 201) establece que el acceso no autorizado a sistemas, la intercepci\u00f3n de datos o la producci\u00f3n de herramientas para cometer delitos se castigan con prisi\u00f3n o multa.</p> <p>Es esencial tener autorizaci\u00f3n mediante un contrato que establezca el prop\u00f3sito de la actividad. Investigar un sistema sin autorizaci\u00f3n, aunque sea con buenas intenciones, puede llevar a denuncias.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/","title":"03.-Amenazas a la seguridad de la informaci\u00f3n","text":"<p>En seguridad de la informaci\u00f3n, una amenaza (threat) es cualquier suceso que afecta al buen funcionamiento del sistema y a nuestros activos. La norma UNE 71504:2008, que define la Metodolog\u00eda de An\u00e1lisis y Gesti\u00f3n de Riesgos para los Sistemas de Informaci\u00f3n (MAGERIT), la describe como:</p> <p>\u00abCausa potencial de un incidente que puede causar da\u00f1os a un sistema de informaci\u00f3n o a una organizaci\u00f3n\u00bb.</p> <p>Las amenazas pueden ser involuntarias, como un desastre natural, o deliberadas, como un ataque DDoS. MAGERIT (\u2122 MAGERIT v.3) clasifica las amenazas en los siguientes tipos:</p> <ul> <li>De origen natural: terremotos, inundaciones, etc.</li> <li>Del entorno (industrial): cortes de suministro, contaminaci\u00f3n, etc.</li> <li>Defectos de las aplicaciones: vulnerabilidades o fallos de dise\u00f1o.</li> <li>Causadas accidentalmente por personas: errores humanos, facilitaci\u00f3n involuntaria de informaci\u00f3n. Incluye la ingenier\u00eda social.</li> <li>Causadas deliberadamente por personas: amenazas intencionales para obtener beneficio o causar da\u00f1o.</li> </ul> <p>En el \u00e1mbito del hacking \u00e9tico, es crucial conocer las tres \u00faltimas categor\u00edas.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#tipos-de-intrusos-y-motivaciones","title":"Tipos de intrusos y motivaciones","text":"<p>Existen distintos tipos de intrusos o ciberdelincuentes seg\u00fan sus motivaciones:</p> <ul> <li>Cracker: Busca provocar da\u00f1os y obtener beneficios de forma ilegal, utilizando ingenier\u00eda inversa para evitar restricciones de software propietario.</li> <li>Phreaker: Intenta acceder a Internet de forma gratuita a trav\u00e9s de redes telef\u00f3nicas, motivado por el alto coste de estas conexiones.</li> <li>Spammer: Env\u00eda masivamente correos electr\u00f3nicos para obtener ganancias econ\u00f3micas o colapsar servidores.</li> <li>Lamer: Pretende ser un hacker sin conocimientos t\u00e9cnicos reales, limit\u00e1ndose a copiar y pegar. Tambi\u00e9n conocido como script-kiddie.</li> <li>Insider: Empleado que act\u00faa contra su empresa por motivos econ\u00f3micos o venganza.</li> <li>Exempleado: Antiguo trabajador con motivaciones similares al insider.</li> <li>Hacktivist: Busca relevancia pol\u00edtica con acciones contra injusticias o para proteger derechos humanos. Anonymous es un ejemplo.</li> <li>State-Sponsored hacker: Act\u00faa bajo el amparo de un Estado, atacando otras naciones para conseguir informaci\u00f3n o colapsar infraestructuras cr\u00edticas.</li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#codigos-daninos-malware","title":"C\u00f3digos da\u00f1inos: malware","text":"<p>El malware (malicious software) es un programa dise\u00f1ado para introducirse en un sistema y causar control o da\u00f1o, como cifrar informaci\u00f3n, borrar datos o espiar actividades.</p> <p>Las t\u00e9cnicas de propagaci\u00f3n del malware var\u00edan en sofisticaci\u00f3n. Un vector com\u00fan son las tiendas de aplicaciones m\u00f3viles, donde se infiltran apps maliciosas y el usuario acepta permisos sin cuestionar. Tambi\u00e9n se puede ocultar malware en software sospechoso que activa alertas de antivirus. Otra t\u00e9cnica es la esteganograf\u00eda, ocultando malware en ficheros leg\u00edtimos (stegomalware). M\u00e1s detalles en la charla de Alfonso Mu\u00f1oz sobre stegomalware.</p> <p>Un m\u00e9todo m\u00e1s complejo es el malware fileless in-memory, que solo existe en la memoria, dificultando el an\u00e1lisis forense.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#clasificacion-del-malware","title":"Clasificaci\u00f3n del malware","text":"<p>El malware se clasifica seg\u00fan su funcionamiento o da\u00f1o:</p> <ul> <li>Exploit: Aprovecha vulnerabilidades del software.</li> <li>Virus: Se replica acopl\u00e1ndose a programas leg\u00edtimos.</li> <li>Ransomware: Encripta informaci\u00f3n y pide un rescate.</li> <li>Spyware: Esp\u00eda al usuario y env\u00eda la informaci\u00f3n al atacante.</li> <li>Adware: Muestra publicidad constante.</li> <li>Troyano: Se disfraza de software \u00fatil y permite control remoto.</li> <li>Rootkit: Proporciona acceso oculto al sistema.</li> <li>Keylogger: Registra las teclas pulsadas para robar informaci\u00f3n.</li> <li>Gusano: Se autopropaga a trav\u00e9s de redes.</li> <li>Cryptojacking: Usa el sistema para minar criptomonedas.</li> </ul> <p>Estas categor\u00edas no son excluyentes, y un malware puede combinar varias caracter\u00edsticas.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#breve-historia-del-malware","title":"Breve historia del malware","text":"<p>Algunos eventos relevantes en la historia del malware:</p> <ul> <li>Brain (1986): Primer virus difundido fuera de un laboratorio.</li> <li>Jerusalem (1987): Borraba ficheros en el \u00abViernes 13\u00bb.</li> <li>Gusano de Morris (1988): Colaps\u00f3 la red ARPANET.</li> <li>Michelangelo (1992): Actuaba el 6 de marzo.</li> <li>Chernobyl o CIH (1999): Formateaba discos y da\u00f1aba hardware.</li> <li>Melissa (1999): Infect\u00f3 millones de ordenadores por correo.</li> <li>Loveletter (2000): Infect\u00f3 40 millones de ordenadores.</li> <li>Stuxnet (2010): Atac\u00f3 sistemas cr\u00edticos, primera arma cibern\u00e9tica.</li> <li>Wannacry (2017): Infect\u00f3 200 000 dispositivos, detenido por Marcus Hutchins.</li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#tipos-de-ataques","title":"Tipos de ataques","text":"<p>En este apartado se clasifican los tipos de ataques m\u00e1s comunes en un sistema inform\u00e1tico: ataques a contrase\u00f1as, ataques de ingenier\u00eda social, ataques a las conexiones, ataques a la cadena de suministro y ataques invisibles en el c\u00f3digo fuente.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#ataques-a-contrasenas","title":"Ataques a contrase\u00f1as","text":"<p>Estos ataques buscan obtener credenciales de acceso. Su \u00e9xito aumenta si se reutilizan contrase\u00f1as o si estas no son complejas. Usan fuerza bruta o diccionarios de contrase\u00f1as filtradas. Have I been pwned? permite comprobar si una cuenta ha sido comprometida. Para protegerse, se recomienda usar autenticaci\u00f3n multifactor y un gestor de contrase\u00f1as como GuardedBox, que ofrece cifrado End-to-End.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#ataques-de-ingenieria-social","title":"Ataques de ingenier\u00eda social","text":"<p>Estos ataques manipulan a los usuarios para que realicen acciones perjudiciales. Algunos ejemplos comunes son:</p> <ul> <li>Fraude online: Venta falsa de productos o servicios en plataformas oficiales.</li> <li>Phishing, vishing y smishing: Suplantan la identidad de un emisor leg\u00edtimo para robar datos mediante correos, llamadas o SMS.</li> <li>Baiting: Usa cebos para que el usuario descargue software malicioso.</li> <li>Shoulder surfing: Observar a un usuario para obtener informaci\u00f3n confidencial.</li> <li>Dumpster diving: Rebuscar en la basura para obtener informaci\u00f3n relevante.</li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#ataques-a-las-conexiones","title":"Ataques a las conexiones","text":"<p>Estos ataques explotan las redes de comunicaci\u00f3n. Los m\u00e1s comunes son:</p> <ul> <li>DDoS: Sobrecarga de un servicio con peticiones para colapsarlo.</li> <li>Ataques de intermediario (MitM): Un atacante intercepta y modifica el tr\u00e1fico entre dos partes.</li> <li>Suplantaci\u00f3n (spoofing): Falsificar datos de red para hacerse pasar por otro.</li> <li>Escucha de conexiones (sniffing): Capturar tr\u00e1fico no cifrado.</li> <li>Redes trampa (Rogue AP): Crear puntos de acceso falsos en lugares p\u00fablicos para interceptar conexiones.</li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#ataques-a-la-cadena-de-suministro","title":"Ataques a la cadena de suministro","text":"<p>Estos ataques vulneran sistemas de terceros que forman parte de la cadena de suministro del objetivo. Un ejemplo relevante es el ataque a SolarWind, que afect\u00f3 a miles de organizaciones, incluyendo agencias gubernamentales. Para mitigar estos ataques, se recomienda la adopci\u00f3n de arquitecturas de seguridad Zero Trust, donde el principio es \"nunca confiar, siempre comprobar\".</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#ataques-invisibles-en-el-codigo-fuente","title":"Ataques invisibles en el c\u00f3digo fuente","text":"<p>En estos ataques, se insertan caracteres Unicode invisibles en el c\u00f3digo fuente, alterando su comportamiento sin que sea evidente en revisiones. Descubierto en 2021, este tipo de ataque es especialmente peligroso en la cadena de suministro.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#vulnerabilidades","title":"Vulnerabilidades","text":"<p>Una vulnerabilidad o bug es un fallo de dise\u00f1o de un sistema que pone en riesgo su funcionamiento y su seguridad. El primer fallo inform\u00e1tico registrado se produjo el 9 de septiembre de 1947 en el laboratorio de c\u00e1lculo de la Universidad de Harvard. Grace Murray Hopper, quien trabajaba como programadora del ordenador Mark II, anot\u00f3 en el libro de registro un fallo provocado por la presencia de una polilla, coloquialmente conocida como un bicho (bug en ingl\u00e9s), en uno de los rel\u00e9s del computador. De ah\u00ed surgi\u00f3 el t\u00e9rmino \"bug\" para referirse a errores inform\u00e1ticos.</p> <p> Figura 1.3. Imagen de la polilla en el diario del ordenador Mark II. (Fuente: Wikipedia).</p> <p>En los siguientes subapartados se detallan los diferentes tipos de vulnerabilidades, sus causas, y la forma en la que se reportan y documentan.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#causas-y-tipos-de-vulnerabilidades","title":"Causas y Tipos de Vulnerabilidades","text":"<p>Las vulnerabilidades pueden ser de software o hardware. Las de software suelen ser causadas por errores de programaci\u00f3n, fallos de configuraci\u00f3n, o puertas traseras (backdoors) que permiten el acceso remoto. Un ejemplo de puerta trasera intencionada es cuando agencias gubernamentales han tenido acceso a sistemas sin mucho esfuerzo (Microsoft permiti\u00f3 a la NSA acceder a mensajes cifrados).</p> <p>Los errores en el software pueden suceder en cualquier nivel del sistema inform\u00e1tico. Por ejemplo, una aplicaci\u00f3n web puede tener vulnerabilidades en el servidor web, la aplicaci\u00f3n misma, el entorno de ejecuci\u00f3n, o las librer\u00edas de terceros. Incluso si se corrigen todos los errores en la aplicaci\u00f3n, si los componentes externos no se mantienen actualizados, el sistema seguir\u00e1 siendo vulnerable.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#vulnerabilidades-de-software","title":"Vulnerabilidades de Software","text":"<p>Las vulnerabilidades de software afectan a los programas inform\u00e1ticos y suelen ocurrir por errores en el c\u00f3digo fuente o fallos de configuraci\u00f3n. Ejemplos notables incluyen:</p> <ul> <li>Log4shell (CVE-2021-44228): Una vulnerabilidad en la librer\u00eda log4j, ampliamente utilizada para registrar eventos en aplicaciones Java (An\u00e1lisis de Log4Shell).</li> <li>Spring4shell (CVE-2022-22965): Afecta al n\u00facleo del framework Spring, permitiendo la ejecuci\u00f3n remota de c\u00f3digo (RCE).</li> </ul> <p>Tambi\u00e9n existen vulnerabilidades que afectan a sistemas operativos. Estos errores pueden permitir a los atacantes ejecutar c\u00f3digo con privilegios elevados. Ejemplos:</p> <ul> <li>PwnKit (CVE-2021-4034): Vulnerabilidad en polkit\u2019s pkexec que permite la escalada de privilegios en Linux (Local Privilege Escalation en polkit).</li> <li>HiveNightmare (CVE-2021-36934): Permite a cualquier usuario leer el registro de Windows 10 (HiveNightmare aka #SeriousSAM).</li> </ul> <p>Otro error com\u00fan en el software es el mal uso de la criptograf\u00eda. Por ejemplo, Zerologon (CVE-2020-1472) permite a un atacante convertirse en administrador de un dominio debido a un fallo en el protocolo Netlogon Remote Protocol.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#vulnerabilidades-de-hardware","title":"Vulnerabilidades de Hardware","text":"<p>Las vulnerabilidades de hardware permiten a los atacantes evadir las protecciones del sistema operativo y obtener informaci\u00f3n valiosa. Ejemplos:</p> <ul> <li>Meltdown (CVE-2017-5754) y Spectre (CVE-2017-5753, CVE-2017-5715): Aprovechan fallos en la ejecuci\u00f3n especulativa de los procesadores para leer datos a los que no deber\u00edan tener acceso.</li> <li>Retbleed (CVE-2022-29900) y Zenbleed (CVE-2023-20593): Afectan a la ejecuci\u00f3n especulativa y a la serie de procesadores Zen de AMD, respectivamente.</li> </ul> <p>Otro tipo de vulnerabilidad destacada es Rowhammer, que afecta a las memorias DDR DRAM y permite modificar bits tras accesos repetidos.</p> <p>Las vulnerabilidades tambi\u00e9n pueden afectar a dispositivos espec\u00edficos, como consolas de videojuegos. Ejemplos incluyen FreeHDBoot y FreeDVDBoot, utilizadas para evitar sistemas anticopia en consolas PlayStation (Exploit en discos Blu-ray para PS4/PS5).</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#vulnerabilidades-de-dia-cero-zero-day","title":"Vulnerabilidades de D\u00eda Cero (Zero-Day)","text":"<p>Una vulnerabilidad de d\u00eda cero es aquella que no ha sido reportada oficialmente o para la cual a\u00fan no existe un parche. Existen plataformas como Zerodium, que ofrecen grandes sumas de dinero por la venta de estas vulnerabilidades, a diferencia de las plataformas de recompensas (bug bounty), donde los fabricantes pagan por el reporte responsable para corregirlas antes de que se hagan p\u00fablicas.</p> <p> Figura 1.4. Cuant\u00edas por diferentes tipos de vulnerabilidades en plataformas m\u00f3viles. (Fuente: Zerodium).</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/03.-Amenazas%20a%20la%20seguridad%20de%20la%20informaci%C3%B3n/#documentacion-de-vulnerabilidades","title":"Documentaci\u00f3n de Vulnerabilidades","text":"<p>Las vulnerabilidades se documentan usando el sistema CVE (Common Vulnerabilities and Exposures), que asigna un identificador \u00fanico. El identificador se compone de tres elementos: CVE-a\u00f1o-identificador, donde el a\u00f1o indica cu\u00e1ndo se hizo p\u00fablica la vulnerabilidad. El listado completo se encuentra en la web de MITRE.</p> <p>Las vulnerabilidades se eval\u00faan seg\u00fan su gravedad usando el CVSS (Common Vulnerability Scoring System), cuya versi\u00f3n m\u00e1s reciente es la 4. El CVSS asigna una puntuaci\u00f3n entre 0 y 10 para categorizar la severidad de la vulnerabilidad.</p> GRAVEDAD RANGO DE CVSS Baja 0.0 - 3.9 Media 4.0 - 6.9 Alta 7.0 - 8.9 Cr\u00edtica 9.0 - 10.0 <p>Las vulnerabilidades tambi\u00e9n se clasifican por tipo utilizando el sistema CWE (Common Weakness Enumeration), que ofrece una lista exhaustiva de vulnerabilidades de software y hardware. Algunas de las vulnerabilidades m\u00e1s comunes incluyen CWE-79 (Cross-site Scripting), CWE-89 (SQL Injection) y CWE-20 (Improper Input Validation).</p> <p>Para los hackers \u00e9ticos, conocer esta informaci\u00f3n es esencial al realizar auditor\u00edas de seguridad, ya que estas vulnerabilidades tienden a presentarse con cierta frecuencia.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/04.-Test%20de%20intrusi%C3%B3n%20%28Pentest%29/","title":"04.-Test de intrusi\u00f3n (Pentest)","text":"<p>Un test de intrusi\u00f3n, o penetration testing (abreviado pentest), es una actuaci\u00f3n leg\u00edtima de un hacker que trata de vulnerar los servicios de una empresa para hacerse con su control. Los objetivos y el alcance del test de intrusi\u00f3n se establecen por contrato, que incluye, entre otros aspectos, una cl\u00e1usula de confidencialidad.</p> <p>El objetivo del test de intrusi\u00f3n es analizar el estado de seguridad de los servicios de una empresa mediante la b\u00fasqueda activa de vulnerabilidades. De este modo, la empresa que contrata el pentest trata de anticiparse y protegerse ante posibles ataques de cibercriminales. Al concluir el test de intrusi\u00f3n se presenta un informe de resultados donde se describen y analizan los problemas de seguridad descubiertos y se proponen soluciones a los mismos.</p> <p>En Internet se pueden encontrar informes de test de intrusi\u00f3n de empresas y organizaciones que los hacen p\u00fablicos como medida de transparencia de sus servicios o del software que desarrollan (Repositorios con informes p\u00fablicos de test de intrusi\u00f3n https://pentestreports.com/ https://github.com/juliocesarfort/public-pentesting-reports/). Tambi\u00e9n se pueden encontrar informes de empresas de auditor\u00eda que eval\u00faan la seguridad de ciertos servicios y aplicaciones de forma independiente.</p> <p>En los siguientes apartados se profundiza en los distintos elementos que caracterizan un test de intrusi\u00f3n.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/04.-Test%20de%20intrusi%C3%B3n%20%28Pentest%29/#tipos-de-auditorias-en-pentesting","title":"Tipos de Auditor\u00edas en Pentesting","text":"<p>El test de intrusi\u00f3n puede realizarse teniendo en cuenta diversos factores. El primero de ellos es el conocimiento que tiene el pentester de los elementos internos de la empresa, como archivos de configuraci\u00f3n, c\u00f3digo fuente, esquemas de red, pol\u00edticas de seguridad, etc. Seg\u00fan este conocimiento, se diferencian los siguientes tipos de auditor\u00edas:</p> <ul> <li>Auditor\u00eda de caja negra: En este caso, el auditor toma el rol de un hacker que no tiene, a priori, ning\u00fan conocimiento de la organizaci\u00f3n.</li> <li>Auditor\u00eda de caja blanca: El auditor tiene acceso total a la informaci\u00f3n interna de la empresa. Se revisan todos los sistemas, versiones de software y sistemas operativos, configuraciones, pol\u00edticas, etc. Esta auditor\u00eda tambi\u00e9n puede incluir la revisi\u00f3n del c\u00f3digo fuente del software si la empresa se dedica al desarrollo.</li> <li>Auditor\u00eda de caja gris: El auditor dispone de un conocimiento parcial o limitado de la organizaci\u00f3n. Por ejemplo, la auditor\u00eda podr\u00eda consistir en revisar la seguridad de una aplicaci\u00f3n web en la que tendr\u00eda ciertos permisos, pero sin acceso al c\u00f3digo fuente.</li> </ul> <p>Otro factor a considerar al dise\u00f1ar la auditor\u00eda es la posici\u00f3n del pentester con respecto a los recursos de la empresa. En este contexto, se diferencian los siguientes tipos:</p> <ul> <li>Auditor\u00eda perimetral: El auditor asume el papel de un hacker que trata de descubrir una v\u00eda de entrada a los sistemas internos de la organizaci\u00f3n, a trav\u00e9s del an\u00e1lisis de seguridad del per\u00edmetro. Se analizan configuraciones DNS, rangos de direcciones IP y servicios en uso, redes inal\u00e1mbricas y cualquier informaci\u00f3n relevante que pueda ayudar a obtener acceso.</li> <li>Auditor\u00eda interna: El auditor toma el rol de un empleado o insider con escasos o nulos privilegios en la organizaci\u00f3n, o de un invitado que se conecta a la red corporativa. La auditor\u00eda se realiza in situ y comienza desde un segmento de red alejado de los servicios cr\u00edticos.</li> <li>Auditor\u00eda interna con privilegios: Similar a la auditor\u00eda interna, pero en este caso el auditor tiene acceso a configuraciones, c\u00f3digo fuente, pol\u00edticas de seguridad, etc.</li> </ul> <p>Por \u00faltimo, seg\u00fan el alcance de los servicios o recursos que se desean auditar, se distinguen los siguientes tipos:</p> <ul> <li>Auditor\u00eda web: Eval\u00faa la seguridad de la web. Puede ser de forma externa sin permisos (perimetral), con permisos de un usuario con credenciales (interna) o auditando el c\u00f3digo fuente (caja blanca).</li> <li>Auditor\u00eda de aplicaciones m\u00f3viles: Permite conocer el grado de seguridad de las aplicaciones m\u00f3viles de la empresa. Se puede realizar a diferentes niveles, como en el caso de la web.</li> <li>Auditor\u00eda wireless y VoIP: Eval\u00faa el estado de seguridad de las comunicaciones inal\u00e1mbricas y de voz.</li> <li>Prueba de estr\u00e9s DoS/DDoS: Se eval\u00faa la fortaleza de la infraestructura ante situaciones de alta carga.</li> </ul> <p>Los distintos tipos de auditor\u00edas presentados no est\u00e1n compartimentados; cada test de intrusi\u00f3n definir\u00e1 un tipo u otro en funci\u00f3n de los objetivos que se persigan. Por ejemplo, una organizaci\u00f3n puede querer evaluar la seguridad de su per\u00edmetro frente a amenazas externas desconocidas, por lo que una auditor\u00eda perimetral de caja negra ser\u00eda m\u00e1s apropiada. Otra, en cambio, puede estar interesada en conocer el grado de compromiso ante exempleados o empleados descontentos, por lo que una auditor\u00eda interna o perimetral de caja gris ser\u00eda la m\u00e1s adecuada.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/04.-Test%20de%20intrusi%C3%B3n%20%28Pentest%29/#fases-de-un-test-de-intrusion","title":"Fases de un Test de Intrusi\u00f3n","text":"<p>La realizaci\u00f3n de un test de intrusi\u00f3n se desarrolla en diferentes fases o etapas, cada una de las cuales tiene un alcance y un objetivo distinto. Existen diferentes propuestas sobre c\u00f3mo dividir estas etapas, pero de forma general se pueden establecer las siguientes cinco:</p> <ol> <li> <p>Fase de reconocimiento o footprinting    En esta fase se realiza un an\u00e1lisis preliminar del objetivo, recabando toda la informaci\u00f3n posible utilizando fuentes p\u00fablicas. Es importante destacar que esta fase no es intrusiva y no implica ninguna ilegalidad, ya que la informaci\u00f3n recabada est\u00e1 al alcance de cualquiera. Todo lo relacionado con esta fase se estudia en la Unidad 2.</p> </li> <li> <p>Fase de enumeraci\u00f3n o fingerprinting    En esta fase se contin\u00faa con la recopilaci\u00f3n de informaci\u00f3n del objetivo, pero de manera activa, lo que significa que se interact\u00faa directamente con el mismo, por lo que es imprescindible disponer de permiso para ello. Dentro de esta fase se realizan acciones como el escaneo de puertos abiertos, el an\u00e1lisis de servicios y el descubrimiento de vulnerabilidades, que se estudian en la Unidad 3.</p> </li> <li> <p>Fase de explotaci\u00f3n    Con la informaci\u00f3n obtenida en las fases 1 y 2 se dispone de un conocimiento amplio del objetivo. El prop\u00f3sito de esta fase es dise\u00f1ar un vector de ataque para lograr acceso a los sistemas, aprovechando alg\u00fan error de configuraci\u00f3n, contrase\u00f1as d\u00e9biles, servicios vulnerables, aplicaciones inseguras, etc. Las t\u00e9cnicas relacionadas con los objetivos de esta fase se explican en las Unidades 4, 5 y 7.</p> </li> <li> <p>Fase de posexplotaci\u00f3n    Esta fase comienza tras haber obtenido acceso a los sistemas del objetivo. Una vez dentro, se desarrollan acciones de distintos tipos. Una de ellas es comprobar los privilegios disponibles e intentar elevar o escalar estos hacia un usuario m\u00e1s privilegiado. Otra acci\u00f3n consiste en analizar el entorno de red donde se encuentra el sistema comprometido, estudiando posibles saltos a otros sistemas de mayor inter\u00e9s. Todo esto se estudia en la Unidad 6.</p> </li> <li> <p>Fase de documentaci\u00f3n    En esta \u00faltima fase del test de intrusi\u00f3n, se debe elaborar un informe que recoja todos los detalles del proceso. A menudo, se suelen realizar dos tipos de informes: un informe ejecutivo para la alta direcci\u00f3n y un informe t\u00e9cnico dirigido al personal de IT.</p> </li> </ol> <p>Los cibercriminales siguen un esquema similar, salvo en la \u00faltima fase, en la cual ellos tratan de borrar las huellas que hayan podido dejar y garantizar accesos futuros instalando rootkits y herramientas de comando y control (Command &amp; Control - C2) que les permiten manejar y enviar \u00f3rdenes a los equipos comprometidos de forma remota o exfiltrar informaci\u00f3n para luego extorsionar a la empresa (Apartado 6.1.1).</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/04.-Test%20de%20intrusi%C3%B3n%20%28Pentest%29/#el-contrato-del-test-de-intrusion","title":"El contrato del test de intrusi\u00f3n","text":"<p>Los detalles de c\u00f3mo debe llevarse a cabo el test de intrusi\u00f3n, como los servicios que ser\u00e1n auditados o la duraci\u00f3n del test, deben estar acordados previamente con el cliente mediante un contrato firmado por ambas partes. En la bibliograf\u00eda anglosajona, se refieren a este acuerdo como rules of engagement (reglas de compromiso). Este documento debe dar respuesta a preguntas como:</p> <ul> <li>\u00bfEn qu\u00e9 horario debe realizarse el pentest? \u00bfExisten servicios cr\u00edticos donde la carga de trabajo no puede superar cierto umbral?</li> <li>\u00bfSe realizar\u00e1n pruebas de denegaci\u00f3n de servicio?</li> <li>\u00bfEst\u00e1 permitida la ingenier\u00eda social con empleados?</li> <li>\u00bfEl personal de la organizaci\u00f3n o de IT estar\u00e1 al tanto del test?</li> <li>\u00bfEst\u00e1 permitido instalar backdoors o utilizar exploits peligrosos?</li> </ul> <p>Resulta dif\u00edcil encontrar ejemplos de contratos de test de intrusi\u00f3n reales entre corporaciones privadas. Sin embargo, s\u00ed se encuentran ejemplos en los pliegos de contrataciones de organismos p\u00fablicos que deben publicarse en boletines oficiales. Un ejemplo de ello es la contrataci\u00f3n de un test de intrusi\u00f3n por parte de Loter\u00edas y Apuestas del Estado (Procedimiento de selecci\u00f3n de empresas de servicios para la evaluaci\u00f3n de vulnerabilidades y test de intrusi\u00f3n).</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/04.-Test%20de%20intrusi%C3%B3n%20%28Pentest%29/#metodologias-de-pentesting","title":"Metodolog\u00edas de Pentesting","text":"<p>Las fases del test de intrusi\u00f3n pueden variar seg\u00fan la metodolog\u00eda empleada. Una metodolog\u00eda es un documento de referencia que mejora la calidad de los procesos y sirve como gu\u00eda en las auditor\u00edas. No se trata de un documento normativo, sino que cada organizaci\u00f3n puede adaptarlo seg\u00fan sus necesidades.</p> <p>Para profundizar en los elementos de una auditor\u00eda de seguridad, es recomendable consultar la Web Security Testing Guide (WSTG), desarrollada por OWASP. Aunque est\u00e1 enfocada a aplicaciones web, sus primeras secciones aplican a cualquier auditor\u00eda. En particular, la Secci\u00f3n 3.8 revisa las principales metodolog\u00edas de pentesting.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/04.-Test%20de%20intrusi%C3%B3n%20%28Pentest%29/#ptes-penetration-testing-execution-standard","title":"PTES (Penetration Testing Execution Standard)","text":"<p>La metodolog\u00eda PTES (web oficial) fue desarrollada a partir de 2009. Actualmente en la versi\u00f3n 1.0, pronto se espera una versi\u00f3n 2.0 que incluir\u00e1 el concepto de \"niveles\" seg\u00fan la sofisticaci\u00f3n del adversario. PTES divide el pentest en siete fases:</p> <ol> <li>Interacciones previas (Pre-engagement interactions): Definici\u00f3n del alcance, objetivos, coste y contrato del pentest.</li> <li>Recopilaci\u00f3n de inteligencia (Intelligence gathering): Obtenci\u00f3n de informaci\u00f3n relevante del objetivo en tres niveles: automatizado, combinado con an\u00e1lisis manual, y detallado an\u00e1lisis manual.</li> <li>Modelado de amenazas (Threat modeling): Identificaci\u00f3n de activos cr\u00edticos, elaborando el modelo con colaboraci\u00f3n de la empresa.</li> <li>An\u00e1lisis de vulnerabilidades (Vulnerability analysis): Identificaci\u00f3n de fallos aprovechables en los sistemas.</li> <li>Explotaci\u00f3n (Exploitation): Acceso a sistemas, identificando puntos de entrada principales para obtener activos valiosos.</li> <li>Posexplotaci\u00f3n (Post-exploitation): Evaluaci\u00f3n del sistema comprometido, estudio de relaciones de red y exfiltraci\u00f3n de datos.</li> <li>Informe (Reporting): Elaboraci\u00f3n del resumen ejecutivo y del informe t\u00e9cnico detallado para el cliente.</li> </ol> <p>PTES tambi\u00e9n ofrece una gu\u00eda de herramientas \u00fatiles para cada fase.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/04.-Test%20de%20intrusi%C3%B3n%20%28Pentest%29/#osstmm-open-source-security-testing-methodology-manual","title":"OSSTMM (Open Source Security Testing Methodology Manual)","text":"<p>La metodolog\u00eda OSSTMM, publicada en 2001 por ISECOM, est\u00e1 en la versi\u00f3n 3.0 desde diciembre de 2010. Incluye la certificaci\u00f3n de auditor\u00edas mediante el documento STAR (Security Test Audit Report) y utiliza la medida est\u00e1ndar RAV para evaluar la superficie de exposici\u00f3n, que se puede expresar como:</p> <ul> <li>Un valor positivo o negativo, indicando gasto excesivo en controles o insuficiencia de protecci\u00f3n.</li> <li>Un valor logar\u00edtmico en base 10, donde 100 indica balance perfecto.</li> </ul> <p>OSSTMM divide la evaluaci\u00f3n de seguridad en cinco canales:</p> <ul> <li>Seguridad humana: Incluye interacci\u00f3n social, regulaciones, pol\u00edticas de seguridad.</li> <li>Seguridad f\u00edsica: Evaluaci\u00f3n de vulnerabilidad de elementos f\u00edsicos.</li> <li>Seguridad en comunicaciones inal\u00e1mbricas: Auditor\u00eda de comunicaciones en proximidad.</li> <li>Seguridad en telecomunicaciones: An\u00e1lisis de comunicaciones cableadas (anal\u00f3gicas y digitales).</li> <li>Seguridad en redes de datos: Evaluaci\u00f3n de comunicaci\u00f3n entre redes y sistemas operativos.</li> </ul> <p>La metodolog\u00eda consta de cuatro fases:</p> <ol> <li>Fase de inducci\u00f3n: Comprensi\u00f3n de requisitos y alcance.</li> <li>Fase de interacci\u00f3n: Identificaci\u00f3n de sistemas e interacciones.</li> <li>Fase de encuesta: Descubrimiento de informaci\u00f3n desconocida.</li> <li>Fase de intervenci\u00f3n: Evaluaci\u00f3n de penetraci\u00f3n en servicios y validaci\u00f3n de controles.</li> </ol>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/04.-Test%20de%20intrusi%C3%B3n%20%28Pentest%29/#metodologias-del-owasp","title":"Metodolog\u00edas del OWASP","text":"<p>OWASP dispone de tres gu\u00edas para la evaluaci\u00f3n de la seguridad, seg\u00fan el tipo de aplicaci\u00f3n:</p> <ol> <li>OWASP Web Security Testing Guide (WSTG): Centrada en aplicaciones web, con 12 apartados que incluyen recolecci\u00f3n de informaci\u00f3n, autenticaci\u00f3n, autorizaci\u00f3n, gesti\u00f3n de sesiones, validaci\u00f3n de entradas, manejo de errores, criptograf\u00eda d\u00e9bil y auditor\u00eda de APIs.</li> <li>OWASP Mobile Application Security Testing Guide (MASTG): Anteriormente MSTG, describe el proceso de pruebas de seguridad en aplicaciones m\u00f3viles, en alineaci\u00f3n con OWASP MASVS.</li> <li>OWASP Firmware Security Testing Methodology (FSTM): Evaluaci\u00f3n de la seguridad del firmware de dispositivos embebidos, con 9 etapas como recolecci\u00f3n de informaci\u00f3n, an\u00e1lisis y explotaci\u00f3n binaria.</li> </ol>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/04.-Test%20de%20intrusi%C3%B3n%20%28Pentest%29/#otras-metodologias","title":"Otras Metodolog\u00edas","text":"<p>Existen otras metodolog\u00edas que pueden resultar \u00fatiles conocer y estudiar. Algunas de ellas son:</p> <ul> <li>PCIDSS (Payment Card Industry Data Security Standard): Elaborada por el PCI SSC (Security Standards Council), incluye las l\u00edneas y requisitos para proteger los datos de sistemas de pago. Tambi\u00e9n elabora otros est\u00e1ndares como el desarrollo de software seguro o sistemas de pago para dispositivos m\u00f3viles (https://www.pcisecuritystandards.org/document_library/).</li> <li>PTF (Penetration Testing Framework): M\u00e1s que un est\u00e1ndar, recopila informaci\u00f3n de herramientas \u00fatiles en cada fase del test de intrusi\u00f3n y presenta posibles escenarios de ataques (http://www.vulnerabilityassessment.co.uk/Penetration%20Test.html).</li> <li>NIST SP 800-115 (Technical Guide to Information Security and Assessment): Esta gu\u00eda elaborada por el NIST incluye recomendaciones pr\u00e1cticas para dise\u00f1ar, implementar y mantener auditor\u00edas de seguridad (https://csrc.nist.gov/publications/detail/sp/800-115/final). Adem\u00e1s, el NIST est\u00e1 en pleno proceso de publicaci\u00f3n de la versi\u00f3n 2.0 del CSF (Cybersecurity Framework), que ha de servir a cualquier organizaci\u00f3n para garantizar la resiliencia frente a ciberamenazas.</li> <li>CAF (The Cyber Assessment Framework): Esta gu\u00eda est\u00e1 dise\u00f1ada por el NCSC (National Cyber Security Centre) del Reino Unido (https://www.ncsc.gov.uk/collection/caf).</li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/04.-Test%20de%20intrusi%C3%B3n%20%28Pentest%29/#otras-metodologias_1","title":"Otras metodolog\u00edas","text":"<p>Existen otras metodolog\u00edas que pueden resultar \u00fatiles conocer y estudiar. Algunas de ellas son:</p> <ul> <li> <p>PCIDSS (Payment Card Industry Data Security Standard). Elaborada por el PCI SSC (Security Standards Council), incluye las l\u00edneas y requisitos para proteger los datos de sistemas de pago. Tambi\u00e9n elabora otros est\u00e1ndares como el desarrollo de software seguro o sistemas de pago para dispositivos m\u00f3viles (https://www.pcisecuritystandards.org/document_library/).</p> </li> <li> <p>PTF (Penetration Testing Framework). M\u00e1s que un est\u00e1ndar, recopila informaci\u00f3n de herramientas \u00fatiles en cada fase del test de intrusi\u00f3n y presenta posibles escenarios de ataques (http://www.vulnerabilityassessment.co.uk/Penetration%20Test.html).</p> </li> <li> <p>NIST SP 800-115 (Technical Guide to Information Security and Assessment). Esta gu\u00eda elaborada por el NIST incluye recomendaciones pr\u00e1cticas para dise\u00f1ar, implementar y mantener auditor\u00edas de seguridad (https://csrc.nist.gov/publications/detail/sp/800-115/final). Adem\u00e1s, el NIST est\u00e1 en pleno proceso de publicaci\u00f3n de la versi\u00f3n 2.0 del CSF (Cybersecurity Framework), que ha de servir a cualquier organizaci\u00f3n para garantizar la resiliencia frente a ciberamenazas.</p> </li> <li> <p>CAF (The Cyber Assessment Framework). Esta gu\u00eda est\u00e1 dise\u00f1ada por el NCSC (National Cyber Security Centre) del Reino Unido (https://www.ncsc.gov.uk/collection/caf).</p> </li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/04.-Test%20de%20intrusi%C3%B3n%20%28Pentest%29/#equipos-de-seguridad-pentesting-vs-red-teaming","title":"Equipos de seguridad. Pentesting vs red teaming","text":"<p>Habitualmente se distinguen dos tipos de equipos de seguridad:</p> <ul> <li> <p>Red Team (equipo rojo). Realiza labores de seguridad ofensiva, por lo que en ellas se incluyen las acciones de un hacker \u00e9tico.</p> </li> <li> <p>Blue Team (equipo azul). Realiza labores de seguridad defensiva como respuesta a incidentes, an\u00e1lisis forense digital, investigaci\u00f3n de amenazas (threat hunting), bastionado de sistemas, seguridad operativa (SecOps), etc\u00e9tera.</p> </li> </ul> <p>A menudo, los t\u00e9rminos pentesting y red teaming se confunden o se usan indistintamente, pero hay diferencias importantes entre ellos. Un pentest est\u00e1 orientado a una acci\u00f3n concreta sobre un objetivo y su duraci\u00f3n en el tiempo suele ser reducida. En cambio, las labores del Red Team consisten en un ejercicio continuo y constante de prueba de las defensas del objetivo para tratar de superarlas evitando ser descubiertos. Estos ejercicios o simulacros emulan el comportamiento de grupos organizados de ciberdelincuentes, tambi\u00e9n llamados APT (Advanced Persistent Threat), y cuyo modus operandi se encuentra en la matriz de t\u00e1cticas, t\u00e9cnicas y procedimientos (TTP) de MITRE Att&amp;ck (Matriz de t\u00e1cticas, t\u00e9cnicas y procedimientos MITRE Att&amp;ck).</p> <p>Por tanto, el objetivo del Blue Team ser\u00e1 que el Red Team no tenga \u00e9xito. La forma tradicional de organizar estos equipos era que trabajasen de forma independiente. M\u00e1s recientemente aparece el Purple Team, que realiza una puesta en com\u00fan del trabajo de ambos equipos para analizar las debilidades, establecer mejoras y organizar los siguientes ejercicios.</p> <p>Para descubrir qu\u00e9 tipos de ejercicios se llevan a cabo por un Red Team es recomendable visionar la charla Red Team como herramienta de protecci\u00f3n frente APT (Red Team como herramienta de protecci\u00f3n frente a APT (Layakk). XII Jornadas STIC) que la empresa Layakk realiz\u00f3 en las XII Jornadas STIC del CCN-CERT. Adem\u00e1s, puede consultarse el Apartado 5.1.5 donde se explican algunas de las t\u00e9cnicas que emplean estos equipos.</p> <p>Adem\u00e1s, en la bibliograf\u00eda reciente se encuentran referencias a otros equipos de seguridad (orange, green, yellow, white, gold, black...). La Figura 1.6, tomada de un art\u00edculo del investigador de seguridad Daniel Miessler, relaciona los conceptos m\u00e1s importantes en lo que \u00e9l llama la Pir\u00e1mide BAD (Build, Attack, Defend). Los equipos orange, green y yellow, inicialmente propuestos por April Wright en la charla Orange is the new purple en la conferencia BlackHat 2017, representan la labor de los constructores (builders), como por ejemplo los desarrolladores de software. Resulta recomendable consultar el art\u00edculo de Daniel Miessler si se desea profundizar en estos conceptos.</p> <p>Figura 1.6. Pir\u00e1mide BAD (Build, Attack, Defend) donde se representan los diferentes equipos de seguridad. (Fuente: https://danielmiessler.com/study/red-blue-purple-teams/).</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/05.-C%C3%B3mo%20convertirse%20en%20Hacker%20%28from%20zero%20to%20hero%29/","title":"05.-C\u00f3mo convertirse en Hacker (from zero to hero)","text":"<p>En los apartados anteriores se han expuesto los conceptos relacionados con la seguridad de la informaci\u00f3n en general, y de la seguridad ofensiva o hacking \u00e9tico en particular. En las pr\u00f3ximas unidades se presentar\u00e1n los contenidos te\u00f3ricos y pr\u00e1cticos fundamentales para sentar las bases que nos permitir\u00e1n convertirnos en buenos hackers. La lista de todo lo que deber\u00eda saber un hacker es enorme y es imposible abarcarlo todo en este libro. Este es uno de los motivos por los que hemos querido ofrecer multitud de enlaces a laboratorios pr\u00e1cticos, lecturas recomendadas y bibliograf\u00eda adicional a lo largo de las diferentes unidades para ampliar los conocimientos. Adem\u00e1s, se incluye este apartado espec\u00edfico para ofrecer consejos y recursos de aprendizaje que ayudar\u00e1n en el estudio y complementar\u00e1n los contenidos y actividades de este libro.</p> <p>Todos esos conocimientos no se pueden obtener en unas pocas semanas o meses; es necesario mucho trabajo, esfuerzo y dedicaci\u00f3n, adem\u00e1s de experiencia, por lo que es recomendable ser paciente para evitar la frustraci\u00f3n. Deje para futuras revisiones los aspectos m\u00e1s t\u00e9cnicos y detallados, organice su aprendizaje de manera c\u00edclica, volviendo a los aspectos fundamentales siempre que lo necesite, repita las actividades y laboratorios varias veces una vez haya pasado cierto tiempo, intente no mirar las soluciones la segunda vez que lo haga e interiorice los patrones que se repiten entre distintos laboratorios.</p> <p>Por otro lado, adem\u00e1s de adquirir estos conocimientos centrados estrictamente en aspectos t\u00e9cnicos, es necesario desarrollar un m\u00e9todo de trabajo y de aprendizaje que permita desarrollar una actitud cr\u00edtica y de pensamiento \"fuera de la caja\", fomentando la mejora y el aprendizaje continuo.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/05.-C%C3%B3mo%20convertirse%20en%20Hacker%20%28from%20zero%20to%20hero%29/#perfil-de-un-buen-hacker-o-ciberinvestigador","title":"Perfil de un buen hacker o ciberinvestigador","text":"<p>Los conocimientos que debe adquirir un hacker se sustentan sobre una base s\u00f3lida de conocimientos b\u00e1sicos y avanzados del funcionamiento de los sistemas inform\u00e1ticos. Esto incluye materias o \u00e1reas como:</p> <ul> <li>Arquitectura de computadoras y lenguaje ensamblador. Constituye la base del funcionamiento de los elementos hardware y software de los sistemas inform\u00e1ticos.</li> <li>Redes de ordenadores y protocolos de red. Incluye las diferentes arquitecturas de red, los tipos de redes (cableadas, inal\u00e1mbricas, fibra \u00f3ptica...), los dispositivos que intervienen en las redes de comunicaciones, la capa de protocolos TCP/IP y OSI, y los protocolos de encaminamiento.</li> <li>Administraci\u00f3n de sistemas operativos. Instalar y configurar sistemas operativos, tanto Windows como GNU/Linux, que incluyen elementos como pol\u00edticas de seguridad, permisos y roles de usuarios y grupos, administraci\u00f3n de servicios (DHCP, DNS, FTP, HTTP, SSH...), administraci\u00f3n de dominios, gesti\u00f3n de cuotas, configuraci\u00f3n de reglas de cortafuegos, etc.</li> <li>Gesti\u00f3n y administraci\u00f3n de bases de datos. Conocer los diferentes lenguajes de modelado de datos (SQL y noSQL), diferentes sistemas gestores de bases de datos (relacionales, orientados a objetos), su estructura y comandos de administraci\u00f3n.</li> <li>Lenguajes de programaci\u00f3n. Es un \u00e1rea muy amplia que va desde lenguajes de bajo nivel (C, C++, Go, Rust) hasta lenguajes orientados a objetos (Java, C#), programaci\u00f3n orientada a aplicaciones m\u00f3viles (Android, iOS), tecnolog\u00edas web (JavaScript, Jakarta EE framework, PHP, ASP, NodeJs), lenguajes de scripting (Python, Bash, PowerShell). La lista no es exhaustiva y es posible que un lenguaje o tecnolog\u00eda encaje en m\u00e1s de una categor\u00eda.</li> <li>Criptograf\u00eda. Son \u00fatiles los conocimientos desde dos perspectivas: los fundamentos matem\u00e1ticos detr\u00e1s de los algoritmos criptogr\u00e1ficos y la aplicaci\u00f3n pr\u00e1ctica de t\u00e9cnicas criptogr\u00e1ficas.</li> </ul> <p>Se asume que se tienen conocimientos m\u00ednimos en todas las \u00e1reas mencionadas anteriormente. En algunas secciones se repasan algunos de los conceptos fundamentales que son necesarios conocer, pero no siempre es posible hacerlo. Si se carece de esta base necesaria, ser\u00e1 m\u00e1s dif\u00edcil avanzar. Por ello, si en alg\u00fan momento siente que no entiende los conceptos detr\u00e1s de alguna explicaci\u00f3n, se recomienda volver a la base del funcionamiento del elemento que se est\u00e1 explicando antes de continuar adelante.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/05.-C%C3%B3mo%20convertirse%20en%20Hacker%20%28from%20zero%20to%20hero%29/#aprendizaje-continuo-mediante-retos-ctf-capture-the-flag","title":"Aprendizaje continuo mediante retos CTF (Capture The Flag)","text":"<p>Como se ha mencionado al comienzo de la unidad, realizar acciones de hacking \u00e9tico sin permiso est\u00e1 considerado delito. Para practicar y mejorar nuestras habilidades, disponemos de numerosos entornos de prueba que simulan escenarios reales y han sido dise\u00f1ados para ser explotados.</p> <p>Los retos de captura la bandera o Capture The Flag (CTF) consisten en la obtenci\u00f3n de un c\u00f3digo oculto (flag) en el reto, que solo es accesible para aquellos que descubren la vulnerabilidad o el punto d\u00e9bil del reto. En este tipo de retos prima el resultado sobre el proceso, por lo que no es necesario explicar c\u00f3mo se logr\u00f3 resolver. Basta con obtener la bandera para demostrar las habilidades necesarias. Para evitar trampas, existen c\u00f3digos de conducta que deben respetarse. El m\u00e1s importante es no hacer p\u00fablica la soluci\u00f3n a un reto (writeup o walkthrough) hasta que el reto deje de estar activo.</p> <p>Los tipos de CTF se pueden clasificar en tres grandes categor\u00edas:</p> <ul> <li>Retos (challenges). Los challenges son retos que sirven como modelo para un tipo de habilidad t\u00e9cnica o vulnerabilidad concreta. Son los m\u00e1s habituales en los concursos o campeonatos organizados anualmente por diversas empresas, organizaciones, universidades, etc. El tipo de CTF m\u00e1s com\u00fan es Jeopardy, que consta de una serie de retos de distintas categor\u00edas que otorgan puntuaci\u00f3n seg\u00fan su nivel de dificultad. Al finalizar el campeonato, gana el individuo o equipo que m\u00e1s puntos ha acumulado.</li> <li>M\u00e1quinas (boxes). Este tipo de CTF consiste en explotar una m\u00e1quina a trav\u00e9s de alg\u00fan servicio vulnerable o mal configurado. La explotaci\u00f3n se lleva a cabo en dos fases: la obtenci\u00f3n de la bandera de usuario y la escalada de privilegios para obtener la bandera de administrador. Tambi\u00e9n se incluyen las competiciones de ataque y defensa (attack &amp; defense), donde se debe proteger la propia m\u00e1quina y atacar la del contrario.</li> <li>Redes (networks o labs). Consiste en un entorno que simula una red empresarial donde se deben explotar diferentes m\u00e1quinas y realizar pivotaje en la red hasta lograr alcanzar el objetivo final.</li> </ul> <p>Existen numerosas plataformas en Internet para practicar este tipo de retos, algunas orientadas a challenges y otras a la resoluci\u00f3n de m\u00e1quinas vulnerables. Entre las m\u00e1s conocidas est\u00e1n Atenea, HackTheBox, TryHackMe y VulnHub.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/05.-C%C3%B3mo%20convertirse%20en%20Hacker%20%28from%20zero%20to%20hero%29/#recursos-de-aprendizaje","title":"Recursos de aprendizaje","text":"<p>En Internet existen varias gu\u00edas interesantes donde se ofrecen recursos de aprendizaje, algunos gratuitos y otros de pago, para lograr obtener la certificaci\u00f3n de ciberseguridad OSCP (Offensive Security Certified Professional), una de las m\u00e1s valoradas y perseguidas. Entre las m\u00e1s recomendadas est\u00e1n la gu\u00eda elaborada por TJNull, The Journey to Try Harder, y la gu\u00eda de John Jackson, OSCP Reborn - 2023 Exam Preparation Guide.</p> <p>Tambi\u00e9n destacan algunos streamers y creadores de contenido que publican recursos \u00fatiles para el aprendizaje continuo, como Ippsec, John Hammond, LiveOverflow y HackerSploit.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/05.-C%C3%B3mo%20convertirse%20en%20Hacker%20%28from%20zero%20to%20hero%29/#certificaciones-de-ciberseguridad","title":"Certificaciones de ciberseguridad","text":"<p>El mundo de las certificaciones se mueve en una delgada l\u00ednea entre un negocio lucrativo y la utilidad pr\u00e1ctica. Algunas de las certificaciones m\u00e1s relevantes en el \u00e1mbito de la seguridad ofensiva son:</p> <ul> <li>CEH (EC Council Certified Ethical Hacker)</li> <li>Pentest+ (CompTIA)</li> <li>eJPT (eLearnSecurity Junior Penetration Tester)</li> <li>eCPPT (eLearnSecurity Certified Professional Penetration Tester)</li> <li>HTB CPTS (HackTheBox Certified Penetration Testing Specialist)</li> <li>PNPT (TCM Security Practical Network Penetration Tester)</li> <li>OSCP (Offensive Security Certified Professional)</li> </ul> <p>Si est\u00e1 empezando en el hacking \u00e9tico, nuestro consejo es que no se obsesione con las certificaciones; el aprendizaje es largo y lleva tiempo adquirir los conocimientos suficientes. T\u00f3mese su tiempo para ganar experiencia.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/05.-C%C3%B3mo%20convertirse%20en%20Hacker%20%28from%20zero%20to%20hero%29/#plataformas-de-recompensas-bug-bounty","title":"Plataformas de recompensas (bug bounty)","text":"<p>Un programa de recompensas (bug bounty) es un mecanismo por el que grandes empresas, fabricantes, etc., pagan una cantidad econ\u00f3mica a un hacker por reportar vulnerabilidades en sus sistemas o software. Las empresas suelen gestionar sus programas de recompensas a trav\u00e9s de plataformas intermediarias como Bugcrowd, HackerOne, Intigriti e Immunefi.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/05.-C%C3%B3mo%20convertirse%20en%20Hacker%20%28from%20zero%20to%20hero%29/#distribuciones-para-pentesting","title":"Distribuciones para pentesting","text":"<p>Para llevar a cabo labores de pentesting se necesita un buen arsenal de herramientas, que se pueden instalar manualmente o usar alguna de las distribuciones creadas espec\u00edficamente para esta tarea. Entre las distribuciones m\u00e1s destacadas se encuentran Kali Linux, ParrotOS, BlackArch y CommandoVM.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/05.-C%C3%B3mo%20convertirse%20en%20Hacker%20%28from%20zero%20to%20hero%29/#mantenerse-bien-informado","title":"Mantenerse bien informado","text":"<p>El mundo de la tecnolog\u00eda avanza r\u00e1pidamente, lo mismo ocurre en ciberseguridad; por tanto, es preciso mantenerse al d\u00eda de todo lo que ocurre. Para ello, se recomienda seguir blogs especializados como Una al d\u00eda, Un inform\u00e1tico en el lado del mal, Flu Project, Hackplayers, The Hacker Way y Google Project Zero.</p> <p>Tambi\u00e9n se pueden seguir conferencias de seguridad que se organizan cada a\u00f1o, como Blackhat, DEFCON, RootedCON, Navaja Negra, DragonJar y Congreso c1b3rWall.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/06.-Links%20de%20inter%C3%A9s/","title":"06.-Links de inter\u00e9s","text":"<ol> <li> <p>Historia del hacking en Espa\u00f1a    Hackstory es un repositorio que documenta la historia del hacking en Espa\u00f1a, cubriendo eventos y personajes clave.</p> </li> <li> <p>Manifiesto Hacker    El famoso manifiesto escrito por The Mentor, publicado originalmente en Phrack, es una declaraci\u00f3n ic\u00f3nica sobre la filosof\u00eda hacker.</p> </li> <li> <p>Biograf\u00eda de John T. Draper    Un libro que detalla la vida y obra de John T. Draper, uno de los hackers m\u00e1s influyentes del mundo conocido como \"Capit\u00e1n Crunch\".</p> </li> <li> <p>Estad\u00edsticas de ciberdelitos en Espa\u00f1a    El Observatorio Espa\u00f1ol de Delitos Inform\u00e1ticos ofrece estad\u00edsticas actualizadas sobre los ciberdelitos en Espa\u00f1a.</p> </li> <li> <p>Hackeo de LexNET    Noticia sobre el hackeo al sistema de LexNET y la posterior denuncia del hacker que lo descubri\u00f3.</p> </li> <li> <p>Metodolog\u00eda de An\u00e1lisis y Gesti\u00f3n de Riesgos (MAGERIT)    P\u00e1gina oficial que explica la metodolog\u00eda MAGERIT para la gesti\u00f3n de riesgos en sistemas de informaci\u00f3n.</p> </li> <li> <p>Malware sin archivos (fileless malware)    Art\u00edculo de Cybereason que explica c\u00f3mo funcionan los ataques de malware sin archivos.</p> </li> <li> <p>Charla sobre stegomalware en APT modernos - Alfonso Mu\u00f1oz    Video que muestra la t\u00e9cnica de ocultar malware usando esteganograf\u00eda en amenazas persistentes avanzadas.</p> </li> <li> <p>An\u00e1lisis de la vulnerabilidad Log4Shell    Art\u00edculo del INCIBE que profundiza en la vulnerabilidad presente en la librer\u00eda Log4j.</p> </li> <li> <p>Vulnerabilidad PwnKit (CVE-2021-4034)     Publicaci\u00f3n de Qualys sobre una vulnerabilidad en el componente polkit, que permite escalada de privilegios en Linux.</p> </li> <li> <p>Vulnerabilidad HiveNightmare (CVE-2021-36934)     Explicaci\u00f3n sobre la vulnerabilidad que afecta al registro de Windows, conocida como SeriousSAM.</p> </li> <li> <p>Vulnerabilidad Zerologon (CVE-2020-1472)     Explicaci\u00f3n sobre la vulnerabilidad que afecta al protocolo Netlogon en servidores Windows, permitiendo la escalada de privilegios en la red.</p> </li> <li> <p>Ataque Meltdown en procesadores     P\u00e1gina oficial dedicada a las vulnerabilidades Meltdown y Spectre en los procesadores modernos.</p> </li> <li> <p>White Paper sobre Zero Trust Security Architecture - NIST     Documento del NIST que describe los principios y estrategias para implementar arquitecturas de confianza cero.</p> </li> <li> <p>NIST SP-800-207: Gu\u00eda sobre Zero Trust Security     Gu\u00eda especial del NIST sobre la implementaci\u00f3n de arquitecturas de confianza cero en redes y sistemas.</p> </li> <li> <p>Ataque Trojan Source     P\u00e1gina sobre c\u00f3mo los caracteres invisibles en el c\u00f3digo fuente pueden provocar vulnerabilidades de seguridad.</p> </li> <li> <p>Precios de vulnerabilidades m\u00f3viles en Zerodium     Tabla que muestra los precios que Zerodium paga por distintas vulnerabilidades en sistemas m\u00f3viles.</p> </li> <li> <p>Calculadora CVSS 3.1 para vulnerabilidades     Herramienta de FIRST para calcular el puntaje de gravedad de vulnerabilidades usando el sistema CVSS 3.1.</p> </li> <li> <p>Common Weakness Enumeration (CWE)     Sitio oficial del MITRE donde se documentan las debilidades m\u00e1s comunes en sistemas y software.</p> </li> <li> <p>Gu\u00eda de auditor\u00eda de seguridad web del OWASP     Gu\u00eda oficial del OWASP para la evaluaci\u00f3n y pruebas de seguridad en aplicaciones web.</p> </li> <li> <p>NIST SP 800-115: Gu\u00eda de seguridad de la informaci\u00f3n y evaluaci\u00f3n t\u00e9cnica     Gu\u00eda del NIST que ofrece recomendaciones para la evaluaci\u00f3n de la seguridad inform\u00e1tica.</p> </li> <li> <p>Matriz MITRE Att&amp;ck     Recurso del MITRE que organiza y documenta las t\u00e1cticas, t\u00e9cnicas y procedimientos utilizados por grupos APT.</p> </li> <li> <p>Pir\u00e1mide BAD (Build, Attack, Defend) - Daniel Miessler     Art\u00edculo de Daniel Miessler donde se introduce la pir\u00e1mide BAD para clasificar equipos de ciberseguridad.</p> </li> <li> <p>Gu\u00eda OSCP de TJNull     Una completa gu\u00eda de preparaci\u00f3n para el examen OSCP, elaborada por TJNull.</p> </li> <li> <p>Gu\u00eda OSCP de John Jackson     Otra gu\u00eda de preparaci\u00f3n para el OSCP, con recursos y enlaces \u00fatiles para principiantes.</p> </li> <li> <p>Curso de hacking de The Cyber Mentor (TCM)     Curso gratuito en YouTube sobre hacking \u00e9tico, impartido por The Cyber Mentor.</p> </li> <li> <p>Blog de TCM sobre hacking \u00e9tico     Blog de The Cyber Mentor con una gu\u00eda completa para convertirse en hacker \u00e9tico en 2023.</p> </li> <li> <p>Academia de Hack4u - Curso de hacking \u00e9tico     Curso online en espa\u00f1ol sobre hacking \u00e9tico, creado por s4vitar.</p> </li> <li> <p>Proyecto Clb3rWall - Polic\u00eda Nacional     Proyecto de formaci\u00f3n en ciberseguridad de la Polic\u00eda Nacional de Espa\u00f1a, accesible online.</p> </li> <li> <p>HackTricks - Recurso para pentesters     Recurso gratuito que documenta t\u00e9cnicas de explotaci\u00f3n y detecci\u00f3n de vulnerabilidades.</p> </li> <li> <p>HackTricks Cloud - Pentesting en entornos de nube     Nueva publicaci\u00f3n orientada a la seguridad en plataformas de nube.</p> </li> <li> <p>Canal de Ippsec en YouTube     Canal de YouTube donde se resuelven retos de HackTheBox y otras plataformas.</p> </li> <li> <p>Canal de John Hammond en YouTube     Canal de YouTube con videos sobre an\u00e1lisis de malware, retos CTF y hacking en general.</p> </li> <li> <p>Canal de LiveOverflow en YouTube     Canal de YouTube enfocado en explicar conceptos avanzados de hacking y seguridad.</p> </li> <li> <p>Canal de HackerSploit en YouTube     Videos sobre hacking, seguridad inform\u00e1tica y administraci\u00f3n de sistemas.</p> </li> <li> <p>Mapa de certificaciones de ciberseguridad - Paul Jeremy     Clasificaci\u00f3n interactiva de las certificaciones de ciberseguridad seg\u00fan su dificultad y \u00e1reas de conocimiento.</p> </li> <li> <p>Bugcrowd - Programas de recompensas por vulnerabilidades     Plataforma global para programas de recompensas por descubrimiento de fallos de seguridad.</p> </li> <li> <p>HackerOne - Programas de recompensas por vulnerabilidades     Una de las mayores plataformas para recompensas de descubrimiento de vulnerabilidades.</p> </li> <li> <p>Intigriti - Programas de recompensas en Europa     Plataforma europea enfocada en programas de bug bounty, financiada por la UE.</p> </li> <li> <p>Immunefi - Recompensas en proyectos DeFi y criptomonedas     Plataforma especializada en recompensas por fallos de seguridad en proyectos de finanzas descentralizadas.</p> </li> <li> <p>Kali Linux - Distribuci\u00f3n para pentesting     Distribuci\u00f3n de Linux dise\u00f1ada espec\u00edficamente para pruebas de seguridad y hacking \u00e9tico.</p> </li> <li> <p>ParrotOS - Distribuci\u00f3n para seguridad y desarrollo     Sistema operativo dise\u00f1ado para seguridad inform\u00e1tica y desarrollo de software.</p> </li> <li> <p>BlackArch - Distribuci\u00f3n para pentesting en Arch Linux     Distribuci\u00f3n basada en Arch Linux con miles de herramientas de seguridad.</p> </li> <li> <p>CommandoVM - Herramientas para convertir Windows en un entorno de pentestingConjunto de herramientas dise\u00f1ado para usar Windows como plataforma de pruebas de seguridad.</p> </li> <li> <p>Archivo security.txt de Google     Archivo de Google que detalla c\u00f3mo reportar vulnerabilidades de seguridad.</p> </li> </ol>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/01.-Retos%20de%20la%20plataforma%20Atenea/","title":"01.-Retos de la plataforma Atenea","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/01.-Retos%20de%20la%20plataforma%20Atenea/#mi-primer-ctf-retos-de-la-plataforma-atenea","title":"Mi primer CTF. Retos de la plataforma Atenea","text":"<p>Este laboratorio es una introducci\u00f3n a la resoluci\u00f3n de retos CTF. Para ello, se ha elegido la plataforma Atenea, que dispone de retos en castellano y distintas categor\u00edas de retos b\u00e1sicos de iniciaci\u00f3n y otros retos m\u00e1s avanzados. Una vez realizado el registro en la web, hay que dirigirse a la secci\u00f3n Retos y en ella a la pesta\u00f1a B\u00e1sica. Aparecer\u00e1 un listado de retos desplegables que estar\u00e1n accesibles conforme se vaya avanzando y resolviendo todos los anteriores (Figura 1.9).</p> <p>La soluci\u00f3n a los retos se env\u00eda a trav\u00e9s de un campo de texto en el interior de cada reto. Deben leerse bien las instrucciones y verificar que se est\u00e1 introduciendo la flag de forma correcta, ya que solo se dispone de 3 intentos de env\u00edo. Si la flag es correcta, se recibir\u00e1n los puntos que se tengan signados en ese momento y se marcar\u00e1 como resuelto con un color de fondo verde.</p> <p>Los siguientes apartados sirven de guia para la resoluci\u00f3n de los cuatro primeros retos de esta categoria. Se anima al lector a que contin\u00fae y complete los retos restantes.</p> <p></p> <p>Figura 1.9. Retos de la categor\u00eda B\u00e1sica en la plataforma Atenea.</p> <p>Los siguientes apartados sirven de gu\u00eda para la resoluci\u00f3n de los cuatro primeros retos de esta categor\u00eda. Se anima al lector a que contin\u00fae y complete los retos restantes.</p> <p></p> <p>Figura 1.9. Retos de la categor\u00eda B\u00e1sica en la plataforma Atenea.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/01.-Retos%20de%20la%20plataforma%20Atenea/#hash-1","title":"Hash 1","text":"<p>El primer reto introduce las funciones de resumen o funciones hash, un tipo de funci\u00f3n que se emplea en criptograf\u00eda para el almacenamiento de contrase\u00f1as (Apartado 5.2.2). El enunciado del reto es el siguiente:</p> <p>Reto</p> <p>La contrase\u00f1a para superar este reto es <code>LearnTheHashFunction</code>.</p> <p>Tendr\u00e1s que calcular su hash md5 y ponerla en el formato de la plataforma, esto es: <code>flag{md5}</code>.</p> <p>Por ejemplo: <code>flag{378041508fcb2574e1724f8917369be9}</code>.</p> <p>Por tanto, hay que calcular el hash md5 de la cadena indicada y ponerla en el formato en el que se introducen las flags en Atenea, que siempre es de la misma forma: <code>flag{md5}</code>.</p> <p>Para calcular este valor se emplea la l\u00ednea de comandos:</p> <pre><code>$ echo -n LearnTheHashFunction | md5sum\nb2f2d6b27b264d83fe1abe0169b7613e -\n</code></pre> <p>La opci\u00f3n <code>-n</code> elimina el salto de l\u00ednea que a\u00f1ade la funci\u00f3n <code>echo</code> por defecto. De no usarlo, el hash generado ser\u00eda distinto y, por tanto, err\u00f3neo. De esta forma, se pasa la cadena mediante una tuber\u00eda a la funci\u00f3n <code>md5sum</code> disponible en la l\u00ednea de comandos de Linux. Tambi\u00e9n se puede utilizar el sitio web CyberChef (https://gchq.github.io/CyberChef/) para hallar el mismo resultado.</p> <p>Soluci\u00f3n: <code>flag{b2f2d6b27b264d83fe1abe0169b7613e}</code></p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/01.-Retos%20de%20la%20plataforma%20Atenea/#hash-2","title":"Hash 2","text":"<p>Este segundo reto presenta una nueva funci\u00f3n hash, sha256. El enunciado del reto es el siguiente:</p> <p>Reto</p> <p>La contrase\u00f1a para superar este reto es <code>ThisIsAMoreSecureHashFunction</code>.</p> <p>Tendr\u00e1s que calcular su hash sha256 y posteriormente calcular su md5 para poder poner la soluci\u00f3n en el formato de la plataforma, esto es: <code>flag{md5}</code>.</p> <p>Para calcularlo, hay que seguir el mismo procedimiento del reto anterior, utilizando adem\u00e1s el comando <code>sha256sum</code>:</p> <pre><code>$ echo -n ThisIsAMoreSecureHashFunction | sha256sum\nd191ce0a9d8061acb609be613d0abdecd13d93946fa3e8aa3c0c40a2102502ff -\n\n$ echo -n d191ce0a9d8061acb609be613d0abdecd13d93946fa3e8aa3c0c40a2102502ff | md5sum\ndd321a22229e0bbb5f8271e370b61eb0 -\n</code></pre> <p>N\u00f3tese que la salida de los comandos <code>sha256sum</code> y <code>md5sum</code> a\u00f1aden espacios, un car\u00e1cter <code>-</code> y un salto de l\u00ednea al final del hash, por lo que no es posible usar una tuber\u00eda entre ellos directamente. Podr\u00eda utilizarse de manera intermedia el comando <code>awk</code> para extraer de la salida solo la cadena correspondiente del hash <code>sha256sum</code>:</p> <pre><code>$ echo -n ThisIsAMoreSecureHashFunction | sha256sum | awk '{printf $1}' | md5sum\ndd321a22229e0bbb5f8271e370b61eb0\n</code></pre> <p>En el interior de <code>awk</code> se utiliza la funci\u00f3n <code>printf</code> en lugar de <code>print</code> para evitar que se introduzca un salto de l\u00ednea.</p> <p>Soluci\u00f3n: <code>flag{dd321a22229e0bbb5f8271e370b61eb0}</code></p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/01.-Retos%20de%20la%20plataforma%20Atenea/#hash-3","title":"Hash 3","text":"<p>En este reto se explica que las funciones hash son de un \u00fanico sentido, es decir, a partir del hash calculado no se puede obtener la cadena de texto original. Al menos esta es la teor\u00eda, ya que se pueden realizar ataques de fuerza bruta o por diccionario para tratar de hallar la cadena que genera ese hash. El enunciado de este reto es el siguiente:</p> <p>Reto</p> <p>Para superar este reto deber\u00e1s calcular la cadena de texto cuyo hash md5 se corresponde con el siguiente: <code>54f662a095fa3d5fbbdaac72d176701b</code>.</p> <p>Una vez obtenida, deber\u00e1s poner esa cadena de texto en may\u00fasculas y calcular su hash md5 para poder enviar la soluci\u00f3n siguiendo el formato de la plataforma: <code>flag{md5}</code>.</p> <p>Debe recuperarse la cadena que corresponde con ese hash, que tiene apariencia de haber sido generado con la funci\u00f3n md5 por su longitud (32 caracteres hexadecimales). En los retos aparecen referencias que pueden servir de ayuda; en este se menciona CrackStation, una web que permite comprobar si un determinado hash ha sido ya calculado (Figura 1.10).</p> <p></p> <p>Figura 1.10. B\u00fasqueda de la cadena de texto que genera un hash.(https://crackstation.net/).</p> <p>Tal y como indican las instrucciones, debe pasarse la cadena a may\u00fasculas y obtener su hash md5.</p> <pre><code>$ echo MASTEROFPUPPETS | md5sum\nf395885371dd0ad12136d8a733e05e22\n</code></pre> <p>Tambi\u00e9n se dispone del comando <code>tr</code> que se usa para transformar cadenas de caracteres. El comando en una l\u00ednea ser\u00eda el siguiente:</p> <pre><code>$ echo -n masterofpuppets | tr a-z A-Z | md5sum\nf395885371dd0ad12136d8a733e05e22 -\n</code></pre> <p>Soluci\u00f3n: <code>flag{f395885371dd0ad12136d8a733e05e22}</code></p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/01.-Retos%20de%20la%20plataforma%20Atenea/#base64","title":"Base64","text":"<p>Este reto es una introducci\u00f3n a la codificaci\u00f3n de caracteres y a la diferencia entre cifrar y codificar. Una de las codificaciones m\u00e1s frecuentes es base64, que se emplea, por ejemplo, para transferir ficheros binarios a trav\u00e9s del protocolo HTTP, correos electr\u00f3nicos, etc\u00e9tera.</p> <p>El enunciado del reto es el siguiente:</p> <p>Reto</p> <p>Para superar este reto tendr\u00e1s que descodificar el fichero adjunto y poner la contrase\u00f1a en el formato de la plataforma, esto es: <code>flag{md5}</code>.</p> <p>El contenido del fichero descargado es el siguiente:</p> <pre><code>UmVjdWVyZGEgcXV1LIGN1YWS5kbyBjb2RpZm1jYXMgYWxnbyB1biBiYXNINjQgTk8gbG8gZXNOw6FzIGNpZnJhbmRvLCBzaW5vIHF1ZSBzaW1wbGVtZW50ZSBsbyBlc3TDoXMgY29kaWZpY2FuZG8uDQoNCkxhIGNvbnRyYXNlw7FhIHBhemEgce3VwZXJhciBlc3R1IHJ1dG8gZXM6IHJ1Y3V1cemRhcXV1YmFzZTYOTK91c2NpZnJhcg0KCg==\n</code></pre> <p>Se puede emplear el comando <code>base64</code> con la opci\u00f3n <code>-d</code> o <code>--decode</code> para decodificar esta cadena:</p> <pre><code>$ base64 -d base64.txt\n</code></pre> <p>Recuerda que cuando codificas algo en base64 NO lo est\u00e1s cifrando, sino que simplemente lo est\u00e1s codificando.</p> <p>La contrase\u00f1a para superar este reto es: recuerdaquebase64NOescifrar.</p> <p>Se obtiene la flag de la manera habitual:</p> <pre><code>$ echo -n recuerdaquebase64NOescifrar | md5sum\ncf9df460535b4ec175a464c6c120d3fe -\n</code></pre> <p>Soluci\u00f3n: <code>flag{cf9df460535b4ec175a464c6c120d3fe}</code></p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/02.-Mi%20primera%20m%C3%A1quina%20vulnerable%20%28boot2root%29%20DC-1/","title":"02.-Mi primera m\u00e1quina vulnerable (boot2root) DC-1","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/02.-Mi%20primera%20m%C3%A1quina%20vulnerable%20%28boot2root%29%20DC-1/#mi-primera-maquina-vulnerable-boot2root-dc-1","title":"Mi primera m\u00e1quina vulnerable (boot2root): DC-1","text":"<p>Hackearemos una m\u00e1quina que tiene diversas vulnerabilidades. Este tipo de retos llamados boot2root tienen dos objetivos. En primer lugar, lograr acceso a la m\u00e1quina y obtener la primera flag de usuario, y en segundo lugar escalar privilegios y obtener la segunda flag de root o administrador.</p> <p>Para ello se utilizar\u00e1 una m\u00e1quina sencilla disponible en VulnHub: DC-1 (M\u00e1quina en VulnHub: DC-1). Esta m\u00e1quina fue publicada en 2019 y presenta un sitio web construido con el CMS Drupal.</p> <p>En multitud de ocasiones las m\u00e1quinas se distribuyen en formato OVF. </p> <ul> <li> <p>Un paquete OVF contiene metadatos y elementos de archivo que describen las m\u00e1quinas  virtuales, adem\u00e1s de informaci\u00f3n adicional importante para la  implementaci\u00f3n y el funcionamiento de las aplicaciones en el paquete  OVF. Su extensi\u00f3n de nombre de archivo es <code>.ovf</code>.</p> </li> <li> <p>Un dispositivo virtual abierto (OVA) es un paquete OVF en un \u00fanico archivo de archivos con la extensi\u00f3n <code>.ova</code>.</p> </li> </ul> <p>Sin m\u00e1s dilaci\u00f3n, hay que descargar la OVA y exportarla en KVM/Qemu para lo cual nos ayudaremos de las siguientes instrucciones que encontrar\u00e1s en los Anexos. Emplearemos nuestra m\u00e1quina atacante Kali Linux para llevar a cabo el test de intrusi\u00f3n. La configuraci\u00f3n de red de las m\u00e1quinas en VirtualBox ser\u00e1 de red NAT.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/02.-Mi%20primera%20m%C3%A1quina%20vulnerable%20%28boot2root%29%20DC-1/#escaneo-y-enumeracion","title":"Escaneo y enumeraci\u00f3n","text":"<p>El primer paso tras arrancar la m\u00e1quina es averiguar la direcci\u00f3n IP que tiene asignada. Puesto que estamos en el mismo segmento de red se puede emplear el comando netdiscover que utiliza el protocolo ARP para descubrir los equipos activos en una red local:</p> <pre><code>$ sudo netdiscover -r 10.0.1.0/24\n</code></pre> <p>La Figura 1.11 muestra el resultado de este escaneo. Las tres primeras direcciones IP corresponden a VirtualBox, por lo que a la m\u00e1quina objetivo le corresponde la direcci\u00f3n 10.0.1.12.</p> <p></p> <p>Figura 1.11. Direcci\u00f3n IP de la m\u00e1quina objetivo DC-1 descubierta con netdiscover.</p> <p>Una vez fijado el objetivo, se puede realizar un ping para comprobar que est\u00e1 activa. El siguiente paso es comprobar los puertos abiertos y enumerar los servicios que se est\u00e1n ejecutando en cada uno de ellos. Para ello se utiliza el comando <code>nmap</code> con una serie de opciones de enumeraci\u00f3n (Apartado 3.3).</p> <p></p> <p>La salida muestra tres puertos abiertos. El que resulta m\u00e1s interesante es el puerto 80 donde se ejecuta el CMS Drupal en su versi\u00f3n 7. Al visitar la web se ve un formulario de login sin ning\u00fan enlace m\u00e1s a simple vista. Las credenciales predeterminadas no funcionan, por lo que se podr\u00eda comenzar a realizar fuzzing web (Apartado 3.4.3). Tambi\u00e9n se podr\u00eda usar una herramienta espec\u00edfica de enumeraci\u00f3n para Drupal como <code>droopescan</code> o <code>drupwn</code> para tratar de averiguar los plugins y temas instalados, la versi\u00f3n espec\u00edfica, las cuentas de usuario, etc. Nos saltaremos estos pasos.</p> <p>Durante la labor de pentesting es importante tener en cuenta el periodo temporal en el que se lleva a cabo y conocer las vulnerabilidades m\u00e1s graves recientemente publicadas. La m\u00e1quina se public\u00f3 en 2019 y en aquel momento la versi\u00f3n 7 de Drupal puede que estuviera desactualizada, por lo que se puede ver si existe alg\u00fan exploit para esta. El comando <code>searchsploit</code> permite realizar esta b\u00fasqueda de forma sencilla.</p> <pre><code>$ searchsploit drupal 7\n</code></pre> <p>La salida del comando es extensa. Destacan una serie de vulnerabilidades graves llamadas Drupalgeddon que permiten la ejecuci\u00f3n de c\u00f3digo remoto (RCE). Dadas las versiones y el espacio temporal, se sabe que el CMS del objetivo podr\u00eda ser vulnerable a Drupalgeddon 2 (CVE-2018-7600), que afect\u00f3 a las versiones 6, las anteriores a la 7.58, y a diferentes ramas de la versi\u00f3n 8. Se emplear\u00e1 un script en Python desarrollado por kahliya (CVE-2018-7600-drupalgeddon2-scanner) para chequear si realmente el CMS del objetivo es vulnerable.</p> <p>La Figura 1.12 muestra la ejecuci\u00f3n del script confirmando que el objetivo es vulnerable. Por tanto, se puede pasar a la fase de explotaci\u00f3n.</p> <p></p> <p>Figura 1.12. Confirmaci\u00f3n de la vulnerabilidad CVE-2018-7600 en el CMS Drupal del objetivo.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/02.-Mi%20primera%20m%C3%A1quina%20vulnerable%20%28boot2root%29%20DC-1/#explotacion","title":"Explotaci\u00f3n","text":"<p>Existen diversos exploits que se pueden utilizar para aprovechar la vulnerabilidad encontrada. Algunos de ellos, que aparecen en la salida del comando <code>searchsploit</code>, forman parte del framework Metasploit. El funcionamiento de Metasploit se explica en el Apartado 5.4, por lo que dejamos al lector revisarlo y que tras ello vuelva aqu\u00ed y trate de explotar esta m\u00e1quina con Metasploit.</p> <p>Encontrar un exploit adecuado puede requerir diversas pruebas, pero es f\u00e1cil encontrarlos a trav\u00e9s de b\u00fasquedas en Google. Para explotar esta vulnerabilidad, se ha elegido un exploit escrito en Python por lorddemon (drupalgeddon2).</p> <p>El script es antiguo y est\u00e1 escrito en Python 2; por suerte, en Kali todav\u00eda hay soporte y est\u00e1 correctamente configurado para poder ejecutarlo sin problemas.</p> <pre><code>$ python2 drupalgeddon2-exploit.py -h http://10.0.1.12 -c 'whoami'\nwww-data\n</code></pre> <p>Como se ha comprobado, este script permite ejecutar comandos, por lo que se pueden realizar acciones de enumeraci\u00f3n local (Apartado 6.3.1), pero antes de eso es recomendable obtener una shell reversa estable en nuestra m\u00e1quina. La Figura 1.13 muestra c\u00f3mo se ha logrado. En la parte inferior se ejecuta un listener con netcat y en la parte superior se ejecuta el exploit al que se le pasa el comando que inicia la shell reversa. Tras ejecutarlo, se inicia la conexi\u00f3n de la m\u00e1quina explotada en nuestro listener. En la imagen se muestra la ejecuci\u00f3n del comando <code>id</code> en DC-1 desde nuestra m\u00e1quina Kali. En el Apartado 5.6.1 se explica en profundidad c\u00f3mo se lleva a cabo este proceso.</p> <p></p> <p>Figura 1.13. Obtenci\u00f3n de una shell reversa con netcat en la m\u00e1quina DC-1.</p> <p>Buscando la flag de usuario, encontraremos el fichero <code>flag1.txt</code> en <code>/var/www</code> y otra en <code>/home/flag4/flag4.txt</code>.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/02.-Mi%20primera%20m%C3%A1quina%20vulnerable%20%28boot2root%29%20DC-1/#posexplotacion","title":"Posexplotaci\u00f3n","text":"<p>El \u00faltimo paso que nos queda es tratar de escalar privilegios y convertirnos en root. Existen muchas v\u00edas para hacerlo, y la correcta depender\u00e1 de la configuraci\u00f3n de la m\u00e1quina objetivo. Una de las opciones que primero debe comprobarse son los binarios SUID que hay en el sistema (Apartado 6.3.4) con el comando <code>find</code>.</p> <pre><code>www-data@DC-1:/var/www$ find / -perm -u=s 2&gt;/dev/null\n...\n/usr/bin/gpasswd\n/usr/bin/procmail\n/usr/bin/find\n/usr/sbin/exim4\n/usr/lib/pt_chown\n...\n</code></pre> <p>Vemos que en esta lista est\u00e1 el comando <code>find</code>. Al consultar la p\u00e1gina de GTFOBins, se ve que es posible aprovechar este binario para escalar privilegios y obtener una shell como root.</p> <pre><code>$ find . -exec /bin/bash -p \\; -quit\n</code></pre> <pre><code>bash-4.2# cd /root/\nbash-4.2# ls\nthefinalflag.txt\n</code></pre> <p>De este modo podemos navegar al directorio <code>/root</code> donde se sit\u00faa habitualmente la \u00faltima flag de la m\u00e1quina. Por tanto, hemos finalizado el reto de explotaci\u00f3n boot2root.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/04.-Laboratorios%20de%20Introducci%C3%B3n%20al%20hacking%20en%20Tryhackme/","title":"04.-Laboratorios de Introducci\u00f3n al hacking en Tryhackme","text":"<ul> <li>En la Unidad 1 hemos visto los conceptos b\u00e1sicos del hacking \u00e9tico. Para profundizar en los contenidos pr\u00e1cticos aprendidos anteriormente, se propone realizar una serie de laboratorios guiados disponibles en la plataforma TryHackMe, sobre estos contenidos.</li> </ul> <p>Los laboratorios que hay que realizar son los siguientes:</p> <p>Introducci\u00f3n y fases del hacking \u00e9tico:</p> <ul> <li>Principles of Security</li> <li>Security Awareness</li> <li>Common Attacks</li> <li>Intro to Offensive Security</li> <li>Pentesting fundamentals</li> <li>Red Team Fundamentals</li> <li>Red Team Engagements</li> <li>MITRE</li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/05.-Fichero%20de%20configuraci%C3%B3n%20de%20Tmux/","title":"05.-Fichero de configuraci\u00f3n de Tmux","text":"<pre><code># Fichero de configuraci\u00f3n para tmux. \n# Copia este fichero en el directorio home de tu usuario y ren\u00f3mbralo a .tmux.conf\n# Ruta de ejemplo: /home/kali/.tmux.conf\n# Es necesario tener instalado el paquete xclip: apt install xclip\n# Autor: Jos\u00e9 L. Berenguel.\n# ----------------------------------------------------------------------------------------------\n\n# Permite copiar texto en la terminal utilizando el rat\u00f3n.\n# El texto se copia autom\u00e1ticamente en el portapapeles.\nset -g mouse on\nsetw -g mode-keys vi\nset-option -s set-clipboard off\nbind P paste-buffer\nbind-key -T copy-mode-vi v send-keys -X begin-selection\nbind-key -T copy-mode-vi y send-keys -X rectangle-toggle\nunbind -T copy-mode-vi Enter\nbind-key -T copy-mode-vi Enter send-keys -X copy-pipe-and-cancel 'xclip -se c -i'\nbind-key -T copy-mode-vi MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel 'xclip -se c -i'\n\n# Establece el directorio de trabajo actual en los nuevos paneles\nbind c new-window -c \"#{pane_current_path}\"\nbind '\"' split-window -c \"#{pane_current_path}\"\nbind % split-window -h -c \"#{pane_current_path}\"\n</code></pre>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/01.-De%20comprobaci%C3%B3n/","title":"01.-De comprobaci\u00f3n","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/01.-De%20comprobaci%C3%B3n/#11-cual-es-el-origen-de-la-palabra-hacker-y-su-significado","title":"1.1. \u00bfCu\u00e1l es el origen de la palabra hacker y su significado?","text":"<p>Proviene del t\u00e9rmino ingl\u00e9s hack, utilizado en los inicios de la computaci\u00f3n para denominar soluciones ingeniosas, por extensi\u00f3n a la persona que realiza esos hacks se le llama hacker.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/01.-De%20comprobaci%C3%B3n/#12-indica-en-cada-caso-que-principio-de-la-seguridad-de-la-informacion-se-ha-visto-afectado","title":"1.2. Indica, en cada caso, qu\u00e9 principio de la seguridad de la informaci\u00f3n se ha visto afectado.","text":"<p>a) Un empleado descontento ha sacado informaci\u00f3n confidencial de la empresa en un pendrive para venderla en la dark web.</p> <p>Confidencialidad</p> <p>b) Un apag\u00f3n que ha sucedido durante las horas de trabajo de una empresa ha impedido el desarrollo normal de la actividad.</p> <p>Disponibilidad</p> <p>c) Un intruso ha logrado acceder a los sistemas inform\u00e1ticos y desviar los pagos de algunas facturas a una cuenta de su propiedad.</p> <p>Integridad</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/01.-De%20comprobaci%C3%B3n/#13-que-amenazas-a-la-seguridad-son-relevantes-para-el-hacking-etico","title":"1.3. \u00bfQu\u00e9 amenazas a la seguridad son relevantes para el hacking \u00e9tico?","text":"<p>De origen natural, del entorno, defectos de las aplicaciones, causadas por las personas de forma accidental \u00f3 causadas por las personas de forma deliberada.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/01.-De%20comprobaci%C3%B3n/#14-explica-las-diferencias-entre-los-siguientes-terminos","title":"1.4. Explica las diferencias entre los siguientes t\u00e9rminos:","text":"<p>a) Hacker vs cracker.</p> <p>Hacker como ciberinvestigador busca vulnerabilidades con fines \u00e9ticos vs cracker busca hacer da\u00f1o u obtener un beneficio</p> <p>b) White hat vs black hat.</p> <p>Hacker \u00e9tico vs ciberdelincuente</p> <p>c) Lamer vs wannabes.</p> <p>Ambos son personas con pocos conocimientos aunque el Lamer tiene connotaciones un tanto delictivas</p> <p>d) Hacktivist vs state-sponsored.</p> <p>Ambos tiene motivaciones pol\u00edticas aunque el Hactivista reivindica una justicia social mientras que los state-sponsored act\u00faan bajo el paraguas de un gobierno.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/01.-De%20comprobaci%C3%B3n/#15-que-tipo-de-ataque-busca-vulnerar-los-sistemas-de-un-tercero-para-lograr-comprometer-la-seguridad-de-un-objetivo-que-confia-en-ese-tercero","title":"1.5. \u00bfQu\u00e9 tipo de ataque busca vulnerar los sistemas de un tercero para lograr comprometer la seguridad de un objetivo que conf\u00eda en ese tercero?","text":"<p>Ataque a la cadena de suministro</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/01.-De%20comprobaci%C3%B3n/#16-indica-a-que-fases-de-un-test-de-intrusion-se-corresponden-las-siguientes-actuaciones","title":"1.6. Indica a qu\u00e9 fases de un test de intrusi\u00f3n se corresponden las siguientes actuaciones:","text":"<p>a) Se ejecuta un exploit que aprovecha una vulnerabilidad en una aplicaci\u00f3n web con una versi\u00f3n desactualizada, logrando el acceso al sistema de la v\u00edctima.</p> <p>Fase de explotaci\u00f3n</p> <p>b) Se busca informaci\u00f3n en Internet de los empleados de la empresa objetivo, sus relaciones, redes sociales, etc\u00e9tera.</p> <p>Fase de reconocimiento  o footprinting</p> <p>c) Se presentan los resultados del test de intrusi\u00f3n al equipo del departamento de IT.</p> <p>Fase de documentaci\u00f3n</p> <p>d) Se realiza un movimiento lateral en la red de la corporaci\u00f3n de la v\u00edctima, accediendo a otra m\u00e1quina donde se encuentra el servidor de bases de datos e informaci\u00f3n importante.</p> <p>Fase de posexplotaci\u00f3n</p> <p>e) Por medio de una herramienta que realiza un esc\u00e1ner de vulnerabilidades, se descubre que hay un CMS con una versi\u00f3n antigua vulnerable.</p> <p>Fase de enumeraci\u00f3n, escaneo o fingerprinter</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/01.-De%20comprobaci%C3%B3n/#17-responde-a-las-siguientes-cuestiones-relacionadas-con-las-metodologias-de-pentesting","title":"1.7. Responde a las siguientes cuestiones relacionadas con las metodolog\u00edas de pentesting:","text":"<p>a) \u00bfQu\u00e9 metodolog\u00eda incluye entre sus fases la elaboraci\u00f3n de un modelo de amenazas?</p> <p>PTES</p> <p>b) \u00bfQu\u00e9 metodolog\u00eda utiliza el RAV para medir la superficie de exposici\u00f3n?</p> <p>OSSTMM</p> <p>c) \u00bfQu\u00e9 nombre recibe el documento elaborado por el OWASP para realizar las auditor\u00edas de aplicaciones para m\u00f3viles?</p> <p>MASTG (Mobile Application Security Testing Guide)</p> <p>d) \u00bfQu\u00e9 metodolog\u00eda incluye cuatro fases de ejecuci\u00f3n, entre las que se encuentra la fase de encuesta?</p> <p>OSSTMM</p> <p>e) \u00bfQu\u00e9 metodolog\u00eda se emplea para la auditor\u00eda de tarjetas de cr\u00e9dito?</p> <p>PCIDSS</p> <p>f) \u00bfQu\u00e9 metodolog\u00eda incluye una serie de canales sobre los que se debe probar la seguridad de la organizaci\u00f3n, como el canal de seguridad humana?</p> <p>OSSTMM</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/01.-De%20comprobaci%C3%B3n/#18-explica-las-diferencias-entre-pentesting-y-red-teaming","title":"1.8. Explica las diferencias entre pentesting y red teaming.","text":"<p>Un pentest est\u00e1 orientado a la auditor\u00eda de unos activos concretos y bien definidos, con una duraci\u00f3n temporal corta. En cambio, Red Team consite en ejercicios de mayor duraci\u00f3n o de forma continua y constante; las defensas est\u00e1n siempre a prueba. Simula amenazas avanzadas conocidas como APT (Advanced Persistence Threat).</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/01.-De%20comprobaci%C3%B3n/#19-segun-la-piramide-bad-propuesta-por-daniel-miessler-que-equipos-se-incluyen-entre-los-defensores","title":"1.9. Seg\u00fan la pir\u00e1mide BAD propuesta por Daniel Miessler, \u00bfqu\u00e9 equipos se incluyen entre los defensores?","text":"<p>Blue Team y el Purple Team</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/01.-De%20comprobaci%C3%B3n/#110-como-se-denominan-los-retos-en-los-que-hay-que-encontrar-un-secreto-oculto","title":"1.10. \u00bfC\u00f3mo se denominan los retos en los que hay que encontrar un secreto oculto?","text":"<p>CTF (Capture the Falg)</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/02.-De%20aplicaci%C3%B3n/","title":"02.-De aplicaci\u00f3n","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/02.-De%20aplicaci%C3%B3n/#111-para-desempenar-nuestra-labor-de-hacker-etico-de-forma-profesional-debemos-mantenernos-informados-de-las-brechas-de-seguridad-y-vulnerabilidades-que-afectan-al-software-y-al-hardware-puesto-que-esas-mismas-vulnerabilidades-nos-las-encontraremos-tarde-o-temprano-en-alguna-de-nuestras-auditorias-investiga-sobre-vulnerabilidades-graves-que-hayan-aparecido-recientemente-cvss-superior-a-7-y-muestra-los-siguientes-datos","title":"1.11. Para desempe\u00f1ar nuestra labor de hacker \u00e9tico de forma profesional debemos mantenernos informados de las brechas de seguridad y vulnerabilidades que afectan al software y al hardware, puesto que esas mismas vulnerabilidades nos las encontraremos, tarde o temprano, en alguna de nuestras auditor\u00edas. Investiga sobre vulnerabilidades graves que hayan aparecido recientemente (CVSS superior a 7) y muestra los siguientes datos:","text":"<ul> <li>Nombre de la vulnerabilidad (si se ha bautizado), CVE y CVSS.</li> <li>Breve descripci\u00f3n de en qu\u00e9 consiste, a qu\u00e9 software afecta (versiones) y con qu\u00e9 categor\u00eda de CWE se corresponde.</li> <li>Atribuci\u00f3n del descubrimiento, a\u00f1adiendo la referencia original a la publicaci\u00f3n correspondiente si es posible, y si esa persona u organizaci\u00f3n tiene otros descubrimientos interesantes.</li> </ul> <p>Los resultados de este ejercicio son abiertos, ya que existen numerosas vulnerabilidades y otras muchas que ir\u00e1n apareciendo. A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo podr\u00eda presentarse esta respuesta con dos vulnerabilidades mencionadas en la unidad (Zerologon y Log4shell).</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/02.-De%20aplicaci%C3%B3n/#zerologon-cve-2020-1472","title":"Zerologon. CVE-2020-1472.","text":"<ul> <li> <p>CVSS: 10.0 (base score).</p> </li> <li> <p>CWE-330 (Use of Insufficiently Random Values).</p> </li> <li> <p>Versiones afectadas: Windows Server 2008 R2 SP1, Windows Server 2012, Windows Server 2012 R2, Windows Server 2016, Windows Server 2016:1903, Windows Server 2016:1909, Windows Server 2016:2014, Windows Server 2019.</p> </li> <li> <p>Descripci\u00f3n: esta vulnerabilidad se aprovecha de un fallo de implementaci\u00f3n en la criptograf\u00eda del protocolo Netlogon Remote Protocol, que se emplea para la autenticaci\u00f3n de usuarios y m\u00e1quinas en redes de dominio de Microsoft Windows, y, en particular, en la elecci\u00f3n del vector de inicializaci\u00f3n del algoritmo criptogr\u00e1fico empleado: AES-CFB8.   Descubrimiento: fue descubierta en septiembre de 2020 por Tom Tervoort, analista de seguridad en la empresa Secura. Previamente hab\u00eda descubierto una vulnerabilidad similar en el protocolo Netlogon clasificada en el CVE-2019-1424.</p> </li> <li> <p>Referencia: https://www.secura.com/blog/zero-logon.</p> </li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/02.-De%20aplicaci%C3%B3n/#log4shell-cve-2021-44228","title":"Log4shell. CVE-2021-44228.","text":"<ul> <li>CVSS: 10.0 (base score).</li> <li>CWE: CWE-917 (Improper Neutralization of Special Elements used in an Expression Language Statement), CWE-20 (Improper Input Validation), CWE-400 (Uncontrolled Resource Consumption), CWE-502 (Deserialization of Untrusted Data).</li> <li>Versiones afectadas: 2.0 a 2.15 (excepto 2.12.2, 2.12.3 y 2.3.1).</li> <li>Descripci\u00f3n: la vulnerabilidad afecta a la librer\u00eda log4j utilizada por desarrolladores Java para registrar eventos e informaci\u00f3n relevante en logs. La explotaci\u00f3n se realiza a trav\u00e9s de una petici\u00f3n HTTP, permitiendo la ejecuci\u00f3n remota de c\u00f3digo sin necesidad de autenticaci\u00f3n en el servidor (Unauthenticated RCE).</li> <li>Descubrimiento: el investigador chino Chen Zhaojun de Alibaba Cloud Security Team fue el primero en reportar la vulnerabilidad a Apache el 24 de noviembre. El gobierno chino castig\u00f3 a la empresa por no informar previamente al Estado, lo que habr\u00eda permitido la ejecuci\u00f3n de zeroday en una cantidad enorme de dispositivos.</li> <li>Referencia: https://www.incibe.es/incibe-cert/blog/log4shell-analisis-vulnerabilidades-log4j</li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/02.-De%20aplicaci%C3%B3n/#112-una-de-las-labores-del-hacker-etico-una-vez-que-ha-terminado-el-test-de-intrusion-es-elaborar-y-presentar-un-informe-al-cliente-donde-se-recogen-las-vulnerabilidades-y-los-problemas-de-seguridad-encontrados-y-las-recomendaciones-para-solucionar-o-mitigar-esas-vulnerabilidades-para-conocer-las-caracteristicas-que-tienen-estos-informes-puedes-analizar-alguno-de-los-informes-profesionales-publicados-en-internet-trata-de-responder-a-algunas-preguntas-como","title":"1.12. Una de las labores del hacker \u00e9tico, una vez que ha terminado el test de intrusi\u00f3n, es elaborar y presentar un informe al cliente donde se recogen las vulnerabilidades y los problemas de seguridad encontrados y las recomendaciones para solucionar o mitigar esas vulnerabilidades. Para conocer las caracter\u00edsticas que tienen estos informes, puedes analizar alguno de los informes profesionales publicados en Internet. Trata de responder a algunas preguntas, como:","text":"<ul> <li>\u00bfQu\u00e9 aspecto tiene el informe en cuanto a estilo, redacci\u00f3n, estructura y extensi\u00f3n?</li> <li>\u00bfQu\u00e9 metodolog\u00eda de pentesting se ha aplicado?</li> <li>\u00bfC\u00f3mo se identifican y clasifican las vulnerabilidades?</li> <li>\u00bfSe ofrecen mitigaciones a los problemas de seguridad encontrados?</li> <li>Escribe tus propias conclusiones acerca de c\u00f3mo debe elaborarse y las caracter\u00edsticas que debe tener un informe que tuvieras que escribir.</li> </ul> <p>Ejemplo de soluci\u00f3n</p> <p>Este es un informe de ejemplo de la empresa TrustFoundry en la que se realiza un test de intrusi\u00f3n a una aplicaci\u00f3n web llamada \u201cEasyTransfer\u201d. Para el test de intrusi\u00f3n se facilita la direcci\u00f3n IP que debe ser auditada, 107.170.68.146. El documento est\u00e1 estructurado en dos grandes secciones. En primer lugar un resumen del trabajo realizado que incluye la metodolog\u00eda y el resumen ejecutivo, y un resumen con las vulnerabilidades encontradas. En el resumen se incluye una tabla con las fechas m\u00e1s importantes del proceso de auditor\u00eda: reuni\u00f3n inicial, comienzo del test de intrusi\u00f3n, finalizaci\u00f3n del test de intrusi\u00f3n y env\u00edo del informe. En cuanto a la metodolog\u00eda empleada, se indica que dispone de las siguientes fases: Pre-Assessment, Enumeration, Unauthenticated Testing, Authenticated Testing, Reporting. No se sigue ninguna de las metodolog\u00edas estudiadas pero s\u00ed se indica que se siguen las buenas pr\u00e1cticas de seguridad del OWASP Top 10. Adem\u00e1s, en esta misma secci\u00f3n se presenta un listado gen\u00e9rico de herramientas que pueden ser utilizadas durante el test de intrusi\u00f3n, muchas de las cuales son estudiadas m\u00e1s adelante, como BeEF (The Browser Explotation Framework Project), dirbuster/gobuster, Nessus, Nikto, nmap y sqlmap. El sumario ejecutivo ofrece un resumen de alto nivel de las vulnerabilidades encontradas, as\u00ed como de las buenas pr\u00e1cticas que se han identificado en el entorno auditado. Se han encontrado 10 vulnerabilidades, siendo el Top 3:</p> <ol> <li>La m\u00e1s grave permite la inyecci\u00f3n de comandos a usuarios autenticados.</li> <li>La segunda m\u00e1s grave permite leer ficheros arbitrarios en el sistema por un procesamiento incorrecto de XML.</li> <li>La tercera permite a un atacante saltarse el proceso de reseteo de contrase\u00f1as debido a criptograf\u00eda d\u00e9bil.</li> </ol> <p>Adem\u00e1s, el resumen tambi\u00e9n ofrece tablas y gr\u00e1ficos que resumen los datos analizados, lo que ayuda a tener una visi\u00f3n global de la auditor\u00eda. El resumen de vulnerabilidades encontradas incluye una tabla con la categor\u00eda de la vulnerabilidad y la gravedad de esta. En esta tabla, las vulnerabilidades se encuentran ordenadas de mayor a menor \u00edndice de gravedad, algo que es recomendable realizar si tenemos que elaborar alg\u00fan informe. A continuaci\u00f3n, el informe ofrece informaci\u00f3n detallada para cada vulnerabilidad. En cada una de ellas aparecen las siguientes secciones:</p> <ul> <li>Severity. Gravedad de la vulnerabilidad, puede ser Critical, High, Medium, Low, Informational. El documento no explica c\u00f3mo se realiza esta clasificaci\u00f3n y no menciona valores de CWE o CVSS, lo que ser\u00eda recomendable.</li> <li>Finding Information. Se explica d\u00f3nde se encuentra la vulnerabilidad y c\u00f3mo activarla.</li> <li>Evidence. En esta secci\u00f3n se realiza la demostraci\u00f3n o prueba de concepto (PoC) de la explotaci\u00f3n de la vulnerabilidad. Incluye capturas de pantalla y una explicaci\u00f3n paso a paso de todo el proceso.</li> <li>Affected URLs. Un listado de las URL o endpoints que est\u00e1n afectados por la vulnerabilidad. Esta secci\u00f3n es adecuada, puesto que se trata de una aplicaci\u00f3n web, pero no aparecer\u00e1 en todos los informes que se realicen.</li> <li>Impact. Aqu\u00ed se explica el impacto que supone para el sistema que un atacante logre explotar esta vulnerabilidad. Por ejemplo, comprometer el sistema completamente, exfiltrar datos del servidor, etc.</li> <li>Recommendations. Se ofrecen las medidas y recomendaciones adecuadas para solucionar o mitigar el problema de seguridad.</li> <li>Additional Information. En algunos casos aparece esta secci\u00f3n donde se presentan direcciones URL con m\u00e1s informaci\u00f3n relacionada con la vulnerabilidad en cuesti\u00f3n.</li> </ul> <p>Aparte de elaborar el an\u00e1lisis del informe, un complemento a esta actividad puede ser que el alumnado realice una exposici\u00f3n con sus conclusiones para que compartan entre ellos los diferentes estilos, formatos, tipos de vulnerabilidades encontradas y pueda ser mucho m\u00e1s enriquecedor.</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/02.-De%20aplicaci%C3%B3n/#113-este-ejercicio-se-puede-realizar-en-grupos-un-grupo-asume-el-rol-de-la-empresa-de-ciberseguridad-y-el-otro-el-rol-de-la-empresa-que-desea-contratar-un-test-de-intrusion-el-segundo-grupo-debe-plantear-un-supuesto-sobre-como-es-su-empresa-que-estructura-tiene-los-sistemas-con-los-que-trabaja-etcetera","title":"1.13. Este ejercicio se puede realizar en grupos: un grupo asume el rol de la empresa de ciberseguridad y el otro el rol de la empresa que desea contratar un test de intrusi\u00f3n. El segundo grupo debe plantear un supuesto sobre c\u00f3mo es su empresa, qu\u00e9 estructura tiene, los sistemas con los que trabaja, etc\u00e9tera.","text":"<ul> <li>Elabora un cuestionario previo que ayude a determinar el tipo y alcance de la auditor\u00eda que se realizar\u00e1, as\u00ed como los equipos y servicios que se auditar\u00e1n.</li> <li>Tras la entrevista, elabora una tabla con los activos internos y externos de la organizaci\u00f3n, y otra informaci\u00f3n necesaria para elaborar el acuerdo.</li> <li> <p>Elabora un acuerdo de auditor\u00eda, donde se recoger\u00e1n los activos implicados en ella, el tipo de auditor\u00eda que se realizar\u00e1 sobre cada activo y la duraci\u00f3n del mismo.</p> </li> <li> <p>Recursos para la actividad: </p> </li> <li>Modelo 1</li> <li>Modelo 2</li> </ul> <p>En esta actividad, el alumnado en grupo, o individualmente, puede asumir los dos roles, el de empresa auditada y el de empresa de ciberseguridad. La actividad anterior de an\u00e1lisis de informes puede ser un buen punto de partida. No hay una soluci\u00f3n \u00fanica a este ejercicio, ya que depender\u00e1 mucho de la creatividad del alumnado, por lo que daremos algunas l\u00edneas que sirvan para orientar su realizaci\u00f3n. El alumnado puede inspirarse en empresas conocidas, donde trabajen o hayan trabajado o realizado pr\u00e1cticas de empresa, siempre y cuando no vulneren las pol\u00edticas de privacidad de estas y no desvelen datos confidenciales. Otro lugar de referencia que puede ayudar a inspirar o documentar al alumnado es analizar las condiciones de los programas de recompensas que tienen las empresas en plataformas como Bugcrowd, HackerOne, Intigriti, etc., y que se han mencionado en la unidad. En ellas pueden verse lo que se paga por cada tipo de vulnerabilidad, los activos que est\u00e1n dentro del \u00e1mbito del programa y los que quedan fuera, as\u00ed como aquellos reportes que no se consideran vulnerabilidades sin un an\u00e1lisis m\u00e1s profundo. Algunos programas que se pueden consultar a modo de ejemplo:</p> <ul> <li>Suivo. https://app.intigriti.com/programs/suivo/suivoweb/detail</li> <li>Tomorrowland. https://app.intigriti.com/programs/tomorrowland/tomorrowland/detail</li> <li> <p>Grupo Kinepolis. https://app.intigriti.com/programs/kinepolis/website/detail Otro lugar muy interesante para documentar la actividad son las convocatorias de entidades p\u00fablicas para la realizaci\u00f3n de test de intrusi\u00f3n de sus servicios. Se puede pedir al alumnado que haga una b\u00fasqueda de investigaci\u00f3n y se inspire en los recursos encontrados. Por ejemplo, aqu\u00ed se indican algunas de ellas muy interesantes.</p> </li> <li> <p>Pliego de condiciones para un test de intrusi\u00f3n a Loter\u00edas y Apuestas del Estado: https://contrataciondelestado.es/wps/wcm/connect/bdcb7521-7811-43dc-9c98-397112832819/DOC20160107124924pliego+test+vulnerabilidades+e+intrusion.pdf?MOD=AJPERES</p> </li> <li>Test de intrusi\u00f3n en los sistemas de informaci\u00f3n de la Diputaci\u00f3n de Le\u00f3n. https://www.dipuleon.es/file/p-vgUPL1mlg;jsessionid=FAF4A397C71B52A484FF41B4077E4383</li> <li>Test de intrusi\u00f3n en la red WiFi del servicio de aguas municipales de Vitoria-Gasteiz. https://www.euskadi.eus/anuncio_contratacion/test-intrusion-wifi/web01-tramite/es/</li> <li>Servicio de revisi\u00f3n t\u00e9cnica de seguridad del sistema de informaci\u00f3n GEA de la Consejer\u00eda de la Presidencia, Administraci\u00f3n P\u00fablica e Interior de la Junta de Andaluc\u00eda. https://www.juntadeandalucia.es/haciendayadministracionpublica/apl/pdc_sirec/perfiles-licitaciones/detalle-licitacion.jsf?idExpediente=000000263747</li> </ul> <p>Por \u00faltimo, enumeramos algunas de las preguntas que pueden ser interesantes para elaborar el documento: - \u00bfHa realizado la empresa alguna auditor\u00eda de seguridad previamente? En caso afirmativo \u00bfcu\u00e1les fueron los resultados? - \u00bfCu\u00e1l es el rango y n\u00famero de direcciones IP que deben ser auditadas? - \u00bfQu\u00e9 servicios se ejecutan en esas direcciones IP que deben ser auditados (HTTP, DNS, VPN, SMTP...)? - En auditor\u00edas internas, \u00bfcu\u00e1l es el n\u00famero de equipos a ser auditados?\u00bfQu\u00e9 sistema operativo y software corre en dichos equipos? \u00bfExiste alg\u00fan documento o plan de seguridad que deba revisarse?</p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/02.-De%20aplicaci%C3%B3n/#114-realiza-todos-los-retos-basicos-de-la-plataforma-atenea-continuando-con-el-laboratorio-de-la-unidad","title":"1.14. Realiza todos los retos b\u00e1sicos de la plataforma Atenea continuando con el laboratorio de la unidad.","text":"<p>Reto 5. ASCII Para pasar este reto deber\u00e1s encontrar los caracteres correspondientes a la siguiente codificaci\u00f3n ASCII:</p> <pre><code>080 097 115 115 119 111 114 100 032 112 097 114 097 032 115 117 112 101 114 097 114 032 101\n108 032 114 101 116 111 058 032 084 104 101 065 083 067 073 073 084 097 098 108 101 033\n</code></pre> <p>La web http://www.unit-conversion.info/texttools/ascii/ contiene una herramienta para convertir ASCII a texto en la que se puede introducir los d\u00edgitos de la codificaci\u00f3n. Se obtiene el mensaje:</p> <p><code>Password para superar el reto: TheASCIITable!</code></p> <pre><code>$ echo -n TheASCIITable! | md5sum\nbac4354dbd68068622f69e0c18dab871 -\n</code></pre> <p>Soluci\u00f3n: <code>flag{bac4354dbd68068622f69e0c18dab871}</code></p> <p>Reto 6. Hex Para pasar este reto deber\u00e1s decodificar la siguiente cadena hexadecimal:</p> <pre><code>50617373776f72643a2044346d7054686548337821\n</code></pre> <p>Accedemos a un conversor hexadecimal a texto, por ejemplo: http://www.unit- conversion.info/texttools/hexadecimal/ Obtenemos la siguiente cadena:  <code>Password: D4mpTheH3x!</code> Tambi\u00e9n se puede usar el comando <code>xxd</code> con la opci\u00f3n <code>-r</code> para convertir de hexadecimal a binario, y <code>-p</code> para mostrar el texto correspondiente a dicha codificaci\u00f3n.</p> <pre><code>$ echo -n 50617373776f72643a2044346d7054686548337821 | xxd -r -p\nPassword: D4mpTheH3x!\n</code></pre> <p>Y obtenemos el MD5 de la contrase\u00f1a.</p> <pre><code>$ echo -n D4mpTheH3x! | md5sum\n6020e8ded1d1dc711271c3f6c6d0a4ce -\n</code></pre> <p>Soluci\u00f3n: <code>flag{6020e8ded1d1dc711271c3f6c6d0a4ce}</code></p> <p>Reto 8. Entrop\u00eda Usamos el comando ent en Linux para obtener la entrop\u00eda de cada fichero.</p> Listado de archivos Comando ent file_entropy.py aircraft-2806035_1920.jpg 7.970380 7.97038043643 blue-2705642_1920.jpg 7.956820 7.95681981138 cello-2830670_1920.jpg 7.978028 7.97802786028 chess-2730034_1920.jpg 7.912812 7.91281227014 chestnut-2740751_1280.jpg 7.972699 7.97269867537 fire-2777580_1920.jpg 7.970071 7.9700705656 fly-agaric-2817723_1920.jpg 7.968973 7.96897289084 seemed-2823949_1280.jpg 7.972986 7.9729858271 waffle-heart-2697904_1280.jpg 7.956901 7.95690057534 <pre><code>$ echo -n cello-2830670_1920.jpg | md5sum\n462b9e713bd4a8d06f8ef506be634b66 -\n</code></pre> <p>Soluci\u00f3n: <code>flag{462b9e713bd4a8d06f8ef506be634b66}</code></p> <p>Reto 9. Magic Number Usamos el comando <code>file</code> para ver qu\u00e9 informaci\u00f3n nos ofrece:</p> <pre><code>$ file magicnumber-67351bf4490e9405b4195d544a1c290e\nmagicnumber-67351bf4490e9405b4195d544a1c290e: ISO Media, MP4 v2 [ISO 14496-14]\n</code></pre> <p>Usamos el comando <code>hexdump</code>:</p> <pre><code>$ hexdump -C magicnumber-67351bf4490e9405b4195d544a1c290e | head\n00000000 00 00 00 20 66 74 79 70 6d 70 34 32 00 00 00 00 |... ftypmp42....|\n00000010 6d 70 34 32 6d 70 34 31 69 73 6f 6d 61 76 63 31 |mp42mp41isomavc1|\n00000020 00 00 12 75 6d 6f 6f 76 00 00 00 6c 6d 76 68 64 |...umoov...lmvhd|\n...\n00000090 00 00 00 02 00 00 00 21 69 6f 64 73 00 00 00 00 |.......!iods....|\n</code></pre> <p>En negrita hemos marcado los bytes correspondientes al n\u00famero m\u00e1gico para el tipo de fichero MP4v2:</p> <pre><code>$ echo -n 00000020667479706D703432 | md5sum\nc2cc5e2f05d57fa0ed169bd17efa57eb -\n</code></pre> <p>Soluci\u00f3n: <code>flag{c2cc5e2f05d57fa0ed169bd17efa57eb}</code></p> <p>Reto 10. Strings Usamos el comando <code>strings</code> de Linux:</p> <pre><code>$ strings lookinside-64d0177d2ee53c67e46d5748183d0098 | grep www\nwww.thisisthedomainyouarelookingfor.com\n</code></pre> <p>Convertimos la URL a MD5:</p> <pre><code>$ echo -n www.thisisthedomainyouarelookingfor.com | md5sum\n053a600c94f86724a8ead596fb178e4c -\n</code></pre> <p>Soluci\u00f3n: <code>flag{053a600c94f86724a8ead596fb178e4c}</code></p> <p>Reto 11. Metadatos Comprobamos los metadatos con la herramienta <code>exiftool</code>:</p> <pre><code>$ exiftool LoremIpsum-1e40fa12a5e7ce47ebcaaace81f6fd06.pdf\n</code></pre> <p>La soluci\u00f3n la encontramos en el apartado Author:</p> <pre><code>$ echo -n Aldus Corporation | md5sum\nea930a810edfb6bc250effaf1e504027 -\n</code></pre> <p>Soluci\u00f3n: <code>flag{ea930a810edfb6bc250effaf1e504027}</code></p> <p>Reto 12. Metadatos 2 Usamos la herramienta <code>exiftool</code> para obtener la informaci\u00f3n del archivo:</p> <pre><code>$ exiftool balloon-fc416bf4b40d82bcaa2b941bd38a42cd.jpg\n</code></pre> <p>La soluci\u00f3n la encontramos en el valor Camera Model Name:</p> <pre><code>$ echo -n ILCE-6000 | md5sum\na00f40c5781331e16c25b73516e6202f -\n</code></pre> <p>Soluci\u00f3n: <code>flag{a00f40c5781331e16c25b73516e6202f}</code></p> <p>Reto 13. Variable Para este reto, identificamos el tipo de dato err\u00f3neo en las declaraciones de variables. La declaraci\u00f3n de <code>int max = \"1000\";</code> es incorrecta ya que el literal <code>\"1000\"</code> representa una cadena.</p> <pre><code>$ echo -n max | md5sum\n2ffe4e77325d9a7152f7086ea7aa5114 -\n</code></pre> <p>Soluci\u00f3n: <code>flag{2ffe4e77325d9a7152f7086ea7aa5114}</code></p> <p>Reto 14. Variable 2 Para encontrar el equivalente en BASH de <code>PRINT \"Atenea\"</code> en BASIC, utilizamos:</p> <pre><code>$ echo -n 'echo \"Atenea\"' | md5sum\nbbf02728ac533b306fb112c4a5b66926 -\n</code></pre> <p>Soluci\u00f3n: <code>flag{bbf02728ac533b306fb112c4a5b66926}</code></p> <p>Reto 15. Python Ejecutamos el siguiente script en Python y a\u00f1adimos <code>print(result)</code> al final:</p> <pre><code>import base64\nfrom Crypto import Random\nfrom Crypto.Cipher import AES\nAKEY = 'mysixteenbytekey'\niv = 'what_a_cool_iv!!'\ndef decode(cipher):\n    obj2 = AES.new(AKEY, AES.MODE_CFB, iv)\n    return obj2.decrypt(base64.urlsafe_b64decode(cipher))\nresult = decode(\"5fMfiISsxcG4gKWAXwkL1Bu6zW26FlhG1613\")\nprint(result)\n</code></pre> <p>Se obtiene la salida: <code>b'Password: pythonSnakeBite77'</code>. Calculamos su MD5:</p> <pre><code>$ echo -n pythonSnakeBite77 | md5sum\n6cff35575e778bd78557444667db48bd -\n</code></pre> <p>Soluci\u00f3n: <code>flag{6cff35575e778bd78557444667db48bd}</code></p> <p>Reto 16. C Compilamos y ejecutamos el siguiente c\u00f3digo en C:</p> <pre><code>#include &lt;stdio.h&gt;\nvoid main() {\n    int a = 65535;\n    printf(\"Password : %d\\n\",a &lt;&lt; 7);\n}\n</code></pre> <p>Obtenemos la salida <code>Password : 8388480</code>, y convertimos el valor en MD5:</p> <pre><code>$ echo -n 8388480 | md5sum\ncd703af39fe04b065fc563993d236f37 -\n</code></pre> <p>Soluci\u00f3n: <code>flag{cd703af39fe04b065fc563993d236f37}</code></p> <p>Reto 17. Java Decompilamos el c\u00f3digo Java y encontramos la variable <code>ThisIsTheVariableYouAreLookingFor = \"30853506b923083a\";</code>. Luego, generamos el hash MD5:</p> <pre><code>$ echo -n 30853506b923083a | md5sum\na4bd3cbd2dc7b2be8f20db69aac9d356 -\n</code></pre> <p>Soluci\u00f3n: <code>flag{a4bd3cbd2dc7b2be8f20db69aac9d356}</code></p>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/02.-De%20aplicaci%C3%B3n/#115-realiza-tu-segunda-maquina-boot2root-con-el-reto-simple-ctf-de-tryhackme-reto-ctf-en-tryhackme-simplectf-en-este-reto-se-explota-una-vulnerabilidad-del-cms-instalado-en-la-maquina-que-permite-recuperar-y-crackear-los-hashes-de-las-credenciales-ssh-de-los-usuarios-una-vez-en-el-sistema-la-escalada-de-privilegios-se-lleva-a-cabo-con-sudo","title":"1.15. Realiza tu segunda m\u00e1quina boot2root con el reto Simple CTF de TryHackMe (Reto CTF en TryHackMe - SimpleCTF). En este reto se explota una vulnerabilidad del CMS instalado en la m\u00e1quina que permite recuperar y crackear los hashes de las credenciales SSH de los usuarios. Una vez en el sistema, la escalada de privilegios se lleva a cabo con <code>sudo</code>.","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/03.-De%20ampliaci%C3%B3n/","title":"03.-De ampliaci\u00f3n","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/03.-De%20ampliaci%C3%B3n/#116-haz-una-lista-de-empresas-u-organismos-que-hayan-sufrido-ataques-ciberneticos-y-trata-de-encontrar-informacion-tecnica-al-respecto-sobre-como-se-realizaron","title":"1.16. Haz una lista de empresas u organismos que hayan sufrido ataques cibern\u00e9ticos y trata de encontrar informaci\u00f3n t\u00e9cnica al respecto sobre c\u00f3mo se realizaron.","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/03.-De%20ampliaci%C3%B3n/#117-en-la-plataforma-atenea-dispones-de-otras-categorias-de-retos-basicos-red-web-correo-electronico-ransomware-y-telefono-movil-completa-alguno-o-varios-de-ellos","title":"1.17. En la plataforma Atenea dispones de otras categor\u00edas de retos b\u00e1sicos: red, web, correo electr\u00f3nico, ransomware y tel\u00e9fono m\u00f3vil. Completa alguno o varios de ellos.","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/03.-De%20ampliaci%C3%B3n/#118-realiza-la-maquina-bandit-de-los-wargames-de-overthewire-overthewire-bandit-esta-maquina-esta-enfocada-a-principiantes-y-guia-en-el-uso-de-la-interfaz-de-comandos-por-lo-que-sirve-como-entrenamiento-y-aprendizaje","title":"1.18. Realiza la m\u00e1quina Bandit, de los Wargames de OverTheWire (OverTheWire - Bandit). Esta m\u00e1quina est\u00e1 enfocada a principiantes y gu\u00eda en el uso de la interfaz de comandos, por lo que sirve como entrenamiento y aprendizaje.","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/03.-De%20ampliaci%C3%B3n/#119-una-buena-practica-de-un-hacker-etico-y-que-puede-ser-util-en-algunas-actividades-es-disponer-de-un-sistema-funcional-en-un-dispositivo-externo-usb-que-permita-almacenar-informacion-que-por-seguridad-deberia-estar-cifrada-para-esto-puedes-seguir-el-manual-de-offensive-security-para-instalar-kali-linux-en-un-usb-con-cifrado-y-persistencia-instrucciones-para-la-instalacion-de-kali-linux-en-un-usb-con-cifrado-y-persistencia","title":"1.19. Una buena pr\u00e1ctica de un hacker \u00e9tico y que puede ser \u00fatil en algunas actividades es disponer de un sistema funcional en un dispositivo externo USB, que permita almacenar informaci\u00f3n que, por seguridad, deber\u00eda estar cifrada. Para esto, puedes seguir el manual de Offensive Security para instalar Kali Linux en un USB con cifrado y persistencia (Instrucciones para la instalaci\u00f3n de Kali Linux en un USB con cifrado y persistencia).","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/03.-De%20ampliaci%C3%B3n/#120-el-uso-eficiente-de-la-terminal-de-comandos-es-una-cualidad-muy-recomendable-la-herramienta-tmux-terminal-multiplexer-permite-trabajar-con-diferentes-sesiones-ventanas-y-paneles-empleando-combinaciones-de-teclas-es-recomendable-aprender-como-se-maneja-puedes-ver-los-videos-de-ippsec-y-hackersploit-donde-explican-su-funcionamiento-basico-ademas-en-la-web-de-paraninfo-encontraras-un-fichero-de-configuracion-para-tmux-tmuxconf-que-puedes-descargar-y-utilizar","title":"1.20. El uso eficiente de la terminal de comandos es una cualidad muy recomendable. La herramienta <code>tmux</code> (terminal multiplexer) permite trabajar con diferentes sesiones, ventanas y paneles empleando combinaciones de teclas. Es recomendable aprender c\u00f3mo se maneja. Puedes ver los v\u00eddeos de Ippsec y HackerSploit donde explican su funcionamiento b\u00e1sico. Adem\u00e1s, en la web de Paraninfo encontrar\u00e1s un fichero de configuraci\u00f3n para tmux (.tmux.conf) que puedes descargar y utilizar.","text":"<ul> <li>Recursos:</li> <li>Ippsec - Introduction to tmux</li> <li>HackerSploit - Complete tmux tutorial</li> </ul>"},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/03.-De%20ampliaci%C3%B3n/#121-explora-los-laboratorios-gratuitos-de-tryhackme-laboratorios-en-paraninfo-y-realiza-alguno-que-este-relacionado-con-los-contenidos-de-esta-unidad","title":"1.21 Explora los laboratorios gratuitos de TryHackMe (laboratorios en Paraninfo) y realiza alguno que est\u00e9 relacionado con los contenidos de esta unidad.","text":""},{"location":"01.-Introducci%C3%B3n%20al%20Hacking%20%C3%89tico/07.-Laboratorio%20de%20pr%C3%A1cticas/03.-Actividades%20finales/03.-De%20ampliaci%C3%B3n/#_1","title":"03.-De ampliaci\u00f3n","text":""},{"location":"99.-Anexos/","title":"Index","text":"<p>01.-Conversor de OVA a QCOW2</p>"},{"location":"99.-Anexos/01.-Conversor%20de%20OVA%20a%20QCOW2/","title":"01.-Conversor de OVA a QCOW2","text":"<p>Este documento describe el proceso para convertir una m\u00e1quina virtual en formato <code>.ova</code> a <code>.qcow2</code>, e incluye los pasos para iniciar la m\u00e1quina convertida en KVM/QEMU.</p>"},{"location":"99.-Anexos/01.-Conversor%20de%20OVA%20a%20QCOW2/#requisitos-previos","title":"Requisitos Previos","text":"<p>Es necesario tener <code>qemu-img</code> y <code>virt-manager</code> o <code>virsh</code> instalados para la conversi\u00f3n y puesta en marcha de la VM. En distribuciones Debian/Ubuntu puedes instalarlos con:</p> <pre><code>sudo apt update\nsudo apt install qemu-utils libvirt-daemon-system virt-manager\n</code></pre>"},{"location":"99.-Anexos/01.-Conversor%20de%20OVA%20a%20QCOW2/#pasos-para-la-conversion-manual","title":"Pasos para la Conversi\u00f3n Manual","text":"<ol> <li> <p>Extrae el archivo <code>.ova</code>:     Utiliza <code>tar</code> para descomprimir el archivo <code>.ova</code>, que suele contener archivos <code>.vmdk</code>.     <code>bash     tar -xvf archivo.ova</code></p> </li> <li> <p>Convierte el archivo <code>.vmdk</code> a <code>.qcow2</code>:     Utiliza <code>qemu-img</code> para convertir el archivo <code>.vmdk</code> extra\u00eddo al formato <code>.qcow2</code>.     <code>bash     qemu-img convert -f vmdk archivo.vmdk -O qcow2 archivo.qcow2</code></p> </li> <li> <p>Verifica la conversi\u00f3n:     <code>bash     qemu-img info archivo.qcow2</code></p> </li> </ol>"},{"location":"99.-Anexos/01.-Conversor%20de%20OVA%20a%20QCOW2/#script-en-bash-para-automatizar-la-conversion","title":"Script en Bash para automatizar la conversi\u00f3n","text":"<p>El siguiente script en Bash automatiza la conversi\u00f3n de <code>.ova</code> a <code>.qcow2</code>.</p> <pre><code>#!/bin/bash\n\n# Verifica que se haya proporcionado un archivo OVA como argumento\nif [ \"$#\" -ne 1 ]; then\n    echo \"Uso: $0 archivo.ova\"\n    exit 1\nfi\n\nOVA_FILE=$1\nBASE_NAME=$(basename \"$OVA_FILE\" .ova)\nTARGET_DIR=\"${BASE_NAME}_extracted\"\nQCOW2_FILE=\"${BASE_NAME}.qcow2\"\n\n# Verifica que el archivo OVA existe\nif [ ! -f \"$OVA_FILE\" ]; then\n    echo \"Error: el archivo $OVA_FILE no existe.\"\n    exit 1\nfi\n\n# Crea un directorio temporal para extraer los archivos\nmkdir -p \"$TARGET_DIR\"\necho \"Extrayendo $OVA_FILE a $TARGET_DIR...\"\ntar -xvf \"$OVA_FILE\" -C \"$TARGET_DIR\"\n\n# Encuentra el archivo .vmdk en el directorio extra\u00eddo\nVMDK_FILE=$(find \"$TARGET_DIR\" -name \"*.vmdk\" | head -n 1)\n\n# Verifica que se haya encontrado un archivo VMDK\nif [ -z \"$VMDK_FILE\" ]; then\n    echo \"Error: no se encontr\u00f3 un archivo .vmdk en $OVA_FILE.\"\n    exit 1\nfi\n\n# Convierte el archivo VMDK a QCOW2\necho \"Convirtiendo $VMDK_FILE a $QCOW2_FILE...\"\nqemu-img convert -f vmdk \"$VMDK_FILE\" -O qcow2 \"$QCOW2_FILE\"\n\n# Verifica que la conversi\u00f3n fue exitosa\nif [ $? -eq 0 ]; then\n    echo \"Conversi\u00f3n exitosa. El archivo QCOW2 se encuentra en $QCOW2_FILE.\"\nelse\n    echo \"Error: la conversi\u00f3n fall\u00f3.\"\n    exit 1\nfi\n\n# Limpia el directorio temporal\necho \"Limpiando archivos temporales...\"\nrm -rf \"$TARGET_DIR\"\n\necho \"Proceso completado.\"\n</code></pre>"},{"location":"99.-Anexos/01.-Conversor%20de%20OVA%20a%20QCOW2/#instrucciones","title":"Instrucciones","text":"<ol> <li>Guardar el script como <code>ova2qcow2.sh</code>.</li> <li>Hacer el script ejecutable:</li> </ol> <pre><code>    $ chmod +x ova2qcow2.sh\n</code></pre> <ol> <li>Ejecutar el script pasando como argumento el archivo <code>.ova</code>:     <code>bash     $ ./ova2qcow2.sh archivo.ova</code></li> </ol>"},{"location":"99.-Anexos/01.-Conversor%20de%20OVA%20a%20QCOW2/#configuracion-de-la-maquina-virtual-en-kvmqemu","title":"Configuraci\u00f3n de la M\u00e1quina Virtual en KVM/QEMU","text":"<p>Una vez convertido el archivo <code>.qcow2</code>, es necesario crear una nueva VM en KVM/QEMU que use el disco <code>.qcow2</code> resultante. Se puede hacer con <code>virt-manager</code> o con <code>virsh</code> desde la l\u00ednea de comandos.</p>"},{"location":"99.-Anexos/01.-Conversor%20de%20OVA%20a%20QCOW2/#usando-virt-manager","title":"Usando Virt-Manager","text":"<ol> <li>Abrir <code>virt-manager</code>.</li> <li>Crear una nueva m\u00e1quina virtual y selecciona la opci\u00f3n Importar imagen de disco existente.</li> <li>Seleccionar el archivo <code>.qcow2</code> generado.</li> <li>Asignar la cantidad de CPU, RAM y otras configuraciones de hardware seg\u00fan tus necesidades.</li> <li>Completar el asistente y comienza la m\u00e1quina virtual.</li> </ol>"},{"location":"99.-Anexos/01.-Conversor%20de%20OVA%20a%20QCOW2/#usando-virsh","title":"Usando Virsh","text":"<p>Alternativamente, puedes usar <code>virsh</code> para definir la m\u00e1quina virtual:</p> <pre><code># Definir la VM usando virsh\nsudo virt-install \\  \n\u00a0--name MV01 \\  \n\u00a0--ram 2048 \\  \n\u00a0--vcpus 2 \\  \n\u00a0--disk path=/var/lib/libvirt/images/MV01.qcow2,format=qcow2 \\  \n\u00a0--import \\  \n\u00a0--os-variant generic \\  \n\u00a0--network network=default \\  \n\u00a0--graphics spice \\  \n\u00a0--console pty,target_type=serial\n</code></pre> <p>Este comando crea y lanza una m\u00e1quina virtual utilizando el archivo <code>.qcow2</code>.</p> <ul> <li><code>--name</code>: Nombre de la VM.</li> <li><code>--memory</code>: Cantidad de memoria en MB.</li> <li><code>--vcpus</code>: N\u00famero de CPUs.</li> <li><code>--disk</code>: Ruta del archivo <code>.qcow2</code> y su formato.</li> <li><code>--import</code>: Indica que importamos una m\u00e1quina</li> <li><code>--os-variant</code>: Indica el sistema operativo que contiene la m\u00e1quina. En caso de desconocer <code>generic</code>.</li> <li><code>--network</code>: Configuraci\u00f3n de red, por ejemplo, <code>network=default</code> para una red NAT.</li> <li><code>--graphics</code>: Configura la conexi\u00f3n gr\u00e1fica; <code>spice</code> \u00f3 <code>vnc</code> para acceder remotamente.</li> </ul>"},{"location":"99.-Anexos/01.-Conversor%20de%20OVA%20a%20QCOW2/#explicacion-del-proceso","title":"Explicaci\u00f3n del Proceso","text":"<ul> <li>Conversi\u00f3n: El script convierte el archivo <code>.vmdk</code> en <code>.qcow2</code> autom\u00e1ticamente.</li> <li>Importaci\u00f3n en KVM: Puedes iniciar la VM utilizando <code>virt-manager</code> o <code>virsh</code> para aprovechar el formato <code>.qcow2</code> en un entorno KVM/QEMU.</li> </ul>"}]}